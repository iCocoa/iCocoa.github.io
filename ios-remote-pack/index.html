<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>iOS 远程打包脚本制作 - Haisheng Wu's Tech Blog</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="Example article description"><meta property="og:title" content="iOS 远程打包脚本制作"><meta property="og:description" content="Example article description"><meta property="og:type" content="article"><meta property="og:url" content="https://redscarf.me/ios-remote-pack/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-23T20:00:50+10:00"><meta property="article:modified_time" content="2018-07-23T20:00:50+10:00"><meta itemprop=name content="iOS 远程打包脚本制作"><meta itemprop=description content="Example article description"><meta itemprop=datePublished content="2018-07-23T20:00:50+10:00"><meta itemprop=dateModified content="2018-07-23T20:00:50+10:00"><meta itemprop=wordCount content="1698"><meta itemprop=keywords content="iOS,Python,"><meta name=twitter:card content="summary"><meta name=twitter:title content="iOS 远程打包脚本制作"><meta name=twitter:description content="Example article description"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><header class=header><div class="logo logo--mixed"><div class=container><a class=logo__link href=/ title="Haisheng Wu's Blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.png></div><div class="logo__item logo__text"><div class=logo__title>Haisheng Wu's Blog</div><div class=logo__tagline>Tech Blog</div></div></a></div></div></header><div class=divider></div><div class="container wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>iOS 远程打包脚本制作</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2018-07-23T20:00:50+10:00>2018-07-23</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/ios/ rel=category>IOS</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#准备工作>准备工作</a><ul><li><a href=#appconfigjson-文件内容>appConfig.json 文件内容</a></li><li><a href=#secretjson-文件内容>secret.json 文件内容</a></li></ul></li><li><a href=#python-打包脚本>Python 打包脚本</a><ul><li><a href=#下载-ios-工程代码到指定目录>下载 iOS 工程代码到指定目录</a></li><li><a href=#将客户端上传的-www-文件资源拷贝到-ios-工程目录>将客户端上传的 www 文件资源拷贝到 iOS 工程目录</a></li><li><a href=#修改-ios-工程配置>修改 iOS 工程配置</a></li><li><a href=#导入证书到系统钥匙串>导入证书到系统钥匙串</a></li><li><a href=#导入-mobileprovision-文件>导入 mobileprovision 文件</a></li><li><a href=#编译工程>编译工程</a></li><li><a href=#导出-ipa-安装包>导出 ipa 安装包</a></li></ul></li></ul></nav></div></div><div class="content post__content clearfix"><p>在 iOS 开发中，一般打发布包都是在本地打包，也就是工程师在自己开发电脑上使用 Xcode 编译并导出安装包来进行发布，为了提高效率可能会制作一些自动化打包脚本。本文聊的是远程打包的内容，通过资源拷贝及参数替换然后编译完成打包。</p><p>由于 HTML5 跨平台的特点，很多技术团队考虑到代码复用，在部分模块中会采用 h5 来描述界面。甚至有些不需要太复杂交互的 app，全部界面采用 h5 来编写，也就是一个 web 工程。对于大部分现有的 web 工程，能打包成 app 就已经满足了业务诉求。DCloud 团队开发的 HBuilder（IDE）工具中提供了云打包的功能，用起来很方便，简单的说，就是把 web 工程上传到云打包服务器，最后打包生成 app，点击下载即可安装使用。</p><p><img src=https://res.cloudinary.com/dtbpgyfsc/image/upload/v1625297147/web/dcloud-pack-param_atnmdu.png alt=dcloud-pack-param></p><p>虽然云打包服务很方便，但上传源码总感觉不太妥当，总有些秘密不想让别人看见，并且其他同事也有打包的需求，但不一定会使用 HBuilder。因此，搭建一个自己的打包服务很有必要。</p><p>按照 HBuilder 提供的云打包功能，先定一个初步的需求：</p><ul><li>支持修改应用 id、版本号 、icon、启动图</li><li>支持导入签名文件</li></ul><p>开工！！！</p><h2 id=准备工作>准备工作</h2><p>首先，需要一台安装了 MacOS 的电脑（当做服务器使用）。</p><p>笔者手头上刚好有台闲置的电脑就拿来当服务器使用了，装了 WMWare，然后装了 MacOS 虚拟机（问题较多，不建议使用虚拟机）。</p><blockquote><p>物理机 windows7，内存 4G；虚拟机 MacOS，内存 3G。</p></blockquote><p>其次，在服务器上部署一个 web 服务，提供打包交互界面方便客户端上传资源文件及下载安装包。我们的界面只提供了一个 <code>www</code> zip 包的上传入口，所有应用资源及打包相关的配置文件都在里面。www 目录结构如下：</p><p><img src=https://res.cloudinary.com/dtbpgyfsc/image/upload/v1625297146/web/paf-www-dir_aabjio.png alt=paf-www-dir></p><h3 id=appconfigjson-文件内容>appConfig.json 文件内容</h3><pre tabindex=0><code>{
	&#34;id&#34;:&#34;com.domain.pack&#34;,
	&#34;appName&#34;:&#34;我的应用&#34;,
	&#34;debug&#34;:true,
	&#34;launchPath&#34;: &#34;index.html&#34;,
	&#34;version&#34;: {
		&#34;name&#34;: &#34;1.0.0&#34;,
		&#34;code&#34;: &#34;100&#34;
	},
	...
}
</code></pre><p><code>launchPath</code> 对应 web 应用入口文件，iOS 工程使用这个文件路径作为 webview 的加载入口。</p><h3 id=secretjson-文件内容>secret.json 文件内容</h3><pre tabindex=0><code>{
	&#34;ios&#34; : {
		&#34;p12Password&#34; : &#34;123456&#34;
	},
	&#34;android&#34; : {
		&#34;keyAlias&#34; : &#34;keyAlias&#34;,
		&#34;keyPassword&#34; : &#34;123456&#34;,
		&#34;storePassword&#34; : &#34;123456&#34;,
		&#34;amapApiKey&#34; : &#34;&#34;,
		&#34;jpushApiKey&#34; : &#34;&#34;,
		...
	}
}
</code></pre><p>除了交互界面外，打包服务还需要提供调起 Python 脚本的功能。</p><h2 id=python-打包脚本>Python 打包脚本</h2><p>基本所有的功能都使用脚本实现，使用 Python 编写打包脚本是因为 Python 用起来方便，刚开始打算用 Shell 来编写，执行效果可能好一些，但是对这个不熟，只好将就用 Python。我们的 web 服务采用 Java 编写，Java 是可以调用 Python 脚本的 <code>ProcessBuilder pb = new ProcessBuilder(command.split(" ")); </code>。打包脚本事先准备好，放在 web 服务站点根目录下，在解压完 <code>www</code> zip 包之后，把脚本拷贝到与 www 目录同级目录中，然后执行脚本打包。打包脚本主要做以下几件事情：</p><ul><li>下载 iOS 工程代码到指定目录</li><li>将客户端上传的 www 文件资源拷贝到 iOS 工程目录，应用图标、启动图等</li><li>修改 iOS 工程配置</li><li>导入证书到系统钥匙串</li><li>导入 mobileprovision 文件</li><li>编译工程</li><li>导出 ipa 安装包</li></ul><blockquote><p>打包脚本和客户端上传的 www 文件夹需要放在同一目录下。</p></blockquote><p>实现难度不是很大，但是细节很多，需要反复实践尝试。脚本全部内容见文章末尾。</p><h3 id=下载-ios-工程代码到指定目录>下载 iOS 工程代码到指定目录</h3><pre tabindex=0><code>svnChekoutCmd = &#39;svn co --username=%s --password=%s %s %s&#39; %(SVN_USERNAME, SVN_PASSWORD, SVN_URL, checkoutPath())
p = subprocess.Popen(svnChekoutCmd, shell=True, stderr=subprocess.PIPE)
p.wait()
</code></pre><p>从 svn 仓库拉取 iOS 工程代码，使用 <code>svn checkout</code> 命令把代码拷贝到指定目录，后面会使用这个目录下的工程进行编译。</p><h3 id=将客户端上传的-www-文件资源拷贝到-ios-工程目录>将客户端上传的 www 文件资源拷贝到 iOS 工程目录</h3><pre tabindex=0><code>sourceWWWDir = currentDir() + &#39;/www&#39;
projectWWWDir = &#39;/packProject/www&#39;
destinationWWWDir = checkoutPath() + projectWWWDir
copyFiles(sourceWWWDir, destinationWWWDir)
for file in os.listdir(destinationWWWDir):
    if file.startswith(&#39;secret.json&#39;) or file.endswith(&#39;.mobileprovision&#39;) or file.endswith(&#39;.p12&#39;):
        os.remove(destinationWWWDir + &#39;/&#39; + file)
</code></pre><p>将客户端上传的 <code>www</code> 文件夹拷贝到 iOS 工程中的 www 目录下。</p><pre tabindex=0><code>iconAssetDirectory = checkoutPath() + &#39;/packProject/Assets.xcassets/AppIcon.appiconset&#39;
iconSrcDirectory = projectWWWDir + &#39;/Icons/ios&#39;
items = os.listdir(iconSrcDirectory)
for filename in items:
    copyFile(iconSrcDirectory + &#39;/&#39; + filename, iconAssetDirectory + &#39;/&#39; + filename)
clearDir(iconSrcDirectory)
</code></pre><p>将 <code>www/Icons/ios</code> 文件夹中的各种尺寸的应用图标拷贝到 <code>Assets.xcassets/AppIcon.appiconset</code> 目录中。这个需要事先编写好 <code>AppIcon.appiconset</code> 中的 <code>Contents.json</code> 文件，为每种尺寸的 icon 指定文件名，这里的文件名与 <code>Icons/ios</code> 目录下的图片文件名一一对应，所以，<code>Icons/ios</code> 中的图片名称是固定不变的。<code>Contents.json</code> 文件部分内容：</p><pre tabindex=0><code>{
  &#34;images&#34; : [
    {
      &#34;idiom&#34; : &#34;iphone&#34;,
      &#34;size&#34; : &#34;20x20&#34;,
      &#34;filename&#34; : &#34;40x40.png&#34;,
      &#34;scale&#34; : &#34;2x&#34;
    },
    {
      &#34;idiom&#34; : &#34;iphone&#34;,
      &#34;size&#34; : &#34;20x20&#34;,
      &#34;filename&#34; : &#34;60x60.png&#34;,
      &#34;scale&#34; : &#34;3x&#34;
    },
    {
      &#34;idiom&#34; : &#34;iphone&#34;,
      &#34;size&#34; : &#34;29x29&#34;,
      &#34;filename&#34; : &#34;58x58.png&#34;,
      &#34;scale&#34; : &#34;2x&#34;
    },
    {
      &#34;idiom&#34; : &#34;iphone&#34;,
      &#34;size&#34; : &#34;29x29&#34;,
      &#34;filename&#34; : &#34;87x87.png&#34;,
      &#34;scale&#34; : &#34;3x&#34;
    },
    {
      &#34;idiom&#34; : &#34;iphone&#34;,
      &#34;size&#34; : &#34;40x40&#34;,
      &#34;filename&#34; : &#34;80x80.png&#34;,
      &#34;scale&#34; : &#34;2x&#34;
    },
}
</code></pre><p>启动图资源的拷贝跟应用图标的拷贝一样，需要事先编写好 <code>Contents.json</code> 文件，并且启动图的名称也是固定的。</p><h3 id=修改-ios-工程配置>修改 iOS 工程配置</h3><p>需要根据客户端上传的配置文件 <code>appConfig.json</code> 来修改工程配置。</p><p>首先，读取配置文件的内容，包括应用 id 、名称、版本号、编译号、应用入口等。Python 读取 json 文件字符串类型的值默认会转为 unicode 编码表示，需要进行处理，笔者专门写了一个 <code>json_load_byteified</code> 函数来处理这个问题。</p><p>其次，使用从配置文件中获取到的内容来修改 <code>info.plist</code> 文件。这里需要使用 MacOS 系统自带的工具 <code>PlistBuddy</code> 来辅助修改。</p><h3 id=导入证书到系统钥匙串>导入证书到系统钥匙串</h3><pre tabindex=0><code>p12FilePath = findFileInDirectory(&#39;.p12&#39;, sourceWWWDir)
unlockKeychainCmd = &#39;security unlock-keychain -p %s&#39; %MacOS_ADMIN_PASSWORD
p = subprocess.Popen(unlockKeychainCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
p.wait()
if p.returncode != 0:
    print p.stderr.read()
    return
importCertCmd = &#39;security import %s -P %s -T /usr/bin/codesign&#39; % (p12FilePath, p12Password)
p = subprocess.Popen(importCertCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
p.wait()
if p.returncode != 0:
    print p.stderr.read()
</code></pre><p>使用系统 <code>security</code> 工具将 p12 文件导入到系统钥匙串中，先打开系统钥匙串并提供系统管理员密码，然后再导入。</p><blockquote><p>证书和私钥需要客户端事先准备好，并导出为 p12 文件一并放入 www 文件夹中上传（如何导出 p12 文件请自行查看官方文档）。p12 文件的密码规定写在 <code>secret.json</code> 文件中。</p></blockquote><h3 id=导入-mobileprovision-文件>导入 mobileprovision 文件</h3><pre tabindex=0><code>provisionFileExtension = &#39;.mobileprovision&#39;
provisionFilePath = findFileInDirectory(provisionFileExtension, sourceWWWDir)
if not len(provisionFilePath) &gt; 0:
    print (&#34;[packageFailed]: Not found \&#39;%s\&#39; file in \&#39;www\&#39; directory.&#34;) %(provisionFileExtension)
    return
teamIdentifier = getMobileProvisionItem(provisionFilePath, &#39;TeamIdentifier&#39;)
provisionUUID = getMobileProvisionItem(provisionFilePath, &#39;UUID&#39;)
provisionName = getMobileProvisionItem(provisionFilePath, &#39;Name&#39;)
# type – prints mobileprovision profile type (debug, ad-hoc, enterprise, appstore)
provisionType = getMobileProvisionItem(provisionFilePath, &#39;type&#39;)
teamName = getMobileProvisionItem(provisionFilePath, &#39;TeamName&#39;)
desProvisionFilePath = PROVISONING_PROFILE_DIRECTORY + provisionUUID + provisionFileExtension
copyFile(provisionFilePath, desProvisionFilePath)
</code></pre><p>读取 <code>.mobileprovision</code> 文件的信息，并将 uuid 作为它的文件名保存到 <code>/Users/%s/Library/MobileDevice/Provisioning Profiles/</code> 目录，完成导入。如果先前已经导入过该类文件（一般双击文件导入），打开这个目录可以看到，文件名都是 uuid。这里，除了 uuid 之外，还可以读取团队 id、名称以及文件类型（debug, ad-hoc, enterprise, appstore）等信息。</p><p>为了方便读取 <code>.mobileprovision</code> 文件信息，这里使用一个第三方命令行小工具。安装命令如下：</p><pre tabindex=0><code>curl https://raw.githubusercontent.com/0xc010d/mobileprovision-read/master/main.m | clang -framework Foundation -framework Security -o /usr/local/bin/mobileprovision-read -x objective-c - 
</code></pre><p>安装命令会使用 curl 工具下载源码，然后使用 clang 编译并将可执行文件输出到 <code>/usr/local/bin/</code> 目录，命名为 <code>mobileprovision-read</code>，用法：</p><p><code>mobileprovision-read -f fileName [-o option]</code></p><p>该工具实现比较简单，使用 <code>security</code> 库解析 <code>mobileprovision</code> 文件，然后根据命令行输入的 option 选择输出结果，因为笔者没有对源码进行修改，所以需要对输出结果中的控制字符 <code>\n</code> 进行处理（<code>removeControlChars</code> 函数的作用）。</p><h3 id=编译工程>编译工程</h3><p>编译源码。以前在苹果线上开发者文档可以查看 <code>xcodebuild</code> 用法，不知道什么时候删掉了，现在只能使用 <code>man xcodebuild</code> 查看 <code>xcodebuild</code> 用法，这个不多说。需要注意的是，刚才只是导入了 <code>.mobileprovision</code> 文件，工程配置并没有修改，所以没有关联起来。在 <code>project.pbxproj</code> 文件中有以下几个字段需要进行替换，替换完之后才算完成整个工程编译变量的配置。</p><pre tabindex=0><code>PRODUCT_BUNDLE_IDENTIFIER
PROVISIONING_PROFILE_SPECIFIER
PROVISIONING_PROFILE
</code></pre><p>可以在命令行传入这几个编译变量完成替换，命令行中传入的编译变量优先级最高。</p><p><em><code>project.pbxproj</code> 不是常见的文件格式，在不知道 xcodebuild 可以注入编译变量之前，找了一圈发现没有方便的工具可以用来编辑。有人建议先转成 json 然后再使用 json 编辑工具进行修改。笔者没有采纳，笔者想到用 sed，但 sed 只对简单的文本内容有效，这种嵌套层级太多的内容貌似匹配不了，所以，无法进行修改。awk 应该可以，但这个我没有尝试。</em></p><h3 id=导出-ipa-安装包>导出 ipa 安装包</h3><p>创建 <code>exportOptions.plist</code> 文件并导出 <code>.ipa </code>安装包。把生成的 <code>.ipa</code> 文件路径输出给 java 进程，java 进程将结果显示在界面上，方便客户端进行下载。</p><blockquote><p>注意：
Python 脚本没有执行权限，需要使用 <a href=https://zh.wikipedia.org/wiki/Chmod>Chmod</a> 命令添加执行权限。</p></blockquote><p>脚本全部内容如下（详见 <a href=https://github.com/iCocoa/PackScript>github 源码</a>）：</p><pre tabindex=0><code>#!/usr/bin/env python
# _*_ coding:utf-8 _*_

import subprocess
import os
import json
import re

SVN_USERNAME = &#39;Hansen&#39;
SVN_PASSWORD = &#39;123456&#39;
SVN_URL = &#39;https://Hansen@svn.domain.com/svn/****/trunk/iOS/packProject&#39;
CHECKOUT_FOLDER = &#39;ios_source_code&#39;
MacOS_ADMIN_USER = &#39;packrobot&#39;
MacOS_ADMIN_PASSWORD = &#39;123456&#39;
EXPORT_MAIN_DIRECTORY = &#34;/Users/%s/Documents/ios_appArchive/&#34; % MacOS_ADMIN_USER
PROVISONING_PROFILE_DIRECTORY = &#34;/Users/%s/Library/MobileDevice/Provisioning Profiles/&#34; % MacOS_ADMIN_USER

def json_load_byteified(file_handle):
    return _byteify(
        json.load(file_handle, object_hook=_byteify),
        ignore_dicts=True
    )

def json_loads_byteified(json_text):
    return _byteify(
        json.loads(json_text, object_hook=_byteify),
        ignore_dicts=True
    )

def _byteify(data, ignore_dicts = False):
    # if this is a unicode string, return its string representation
    if isinstance(data, unicode):
        return data.encode(&#39;utf-8&#39;)
    # if this is a list of values, return list of byteified values
    if isinstance(data, list):
        return [ _byteify(item, ignore_dicts=True) for item in data ]
    # if this is a dictionary, return dictionary of byteified keys and values
    # but only if we haven&#39;t already byteified it
    if isinstance(data, dict) and not ignore_dicts:
        return {
            _byteify(key, ignore_dicts=True): _byteify(value, ignore_dicts=True)
            for key, value in data.iteritems()
        }
    # if it&#39;s anything else, return it in its original form
    return data

def currentDir():
    return os.path.split(os.path.realpath(__file__))[0]

def checkoutPath():
    return currentDir() + &#39;/&#39; + CHECKOUT_FOLDER

def pullSvnSourceCode():
    svnChekoutCmd = &#39;svn co --username=%s --password=%s %s %s&#39; %(SVN_USERNAME, SVN_PASSWORD, SVN_URL, checkoutPath())
    p = subprocess.Popen(svnChekoutCmd, shell=True, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print (&#39;[packageFailed]: %s&#39;) %p.stderr.read()
    else:
        print (&#39;Sucessfullly checkout source code at path: %s&#39;) %(checkoutPath())

def clearDir(Dir):
    cleanCmd = &#34;rm -r %s&#34; %(Dir)
    process = subprocess.Popen(cleanCmd, shell=True)
    (stdoutdata, stderrdata) = process.communicate()

def getAppConfig():
    projectWWWDir = &#39;packProject/www&#39;
    destinationWWWDir = currentDir() + &#39;/&#39; + CHECKOUT_FOLDER + &#39;/&#39; + projectWWWDir;
    appConfigFilePath = destinationWWWDir + &#39;/appConfig.json&#39;
    if os.path.exists(appConfigFilePath):
        appConfigReader = open(appConfigFilePath, &#39;r&#39;)
        appConfig = json_load_byteified(appConfigReader)
        appConfigReader.close()
        return appConfig
    return None


def copyFiles(sourceDir, destinationDir):
    if not os.path.exists(sourceDir):
        print (&#39;[packageFailed]: Copy file -- sourceDir doesn\&#39;t exist &#39;)
        pass

    clearDir(destinationDir)
    for file in os.listdir(sourceDir):
        sourceFile = os.path.join(sourceDir, file)
        destinationFile = os.path.join(destinationDir, file)
        if os.path.isfile(sourceFile):
            if not os.path.exists(destinationDir):
                os.makedirs(destinationDir)
            if not os.path.exists(destinationFile) or (os.path.exists(destinationFile) and (os.path.getsize(destinationFile) != os.path.getsize(sourceFile))):
                open(destinationFile, &#34;wb&#34;).write(open(sourceFile, &#34;rb&#34;).read())
        if os.path.isdir(sourceFile):
            copyFiles(sourceFile, destinationFile)
    print (&#39;Copy assets success!&#39;)

def copyFile(srcFile, dstFile):
    srcReader = open(srcFile, &#34;rb&#34;)
    desWriter = open(dstFile, &#34;wb&#34;)
    desWriter.write(srcReader.read())
    srcReader.close()
    desWriter.close()

def cleanArchiveFile(archiveFile):
    cleanCmd = &#34;rm -r %s&#34; %(archiveFile)
    process = subprocess.Popen(cleanCmd, shell=True)
    (stdoutdata, stderrdata) = process.communicate()

def buildExportDirectory():
    dateCmd = &#39;date &#34;+%Y-%m-%d_%H-%M-%S&#34;&#39;
    process = subprocess.Popen(dateCmd, stdout=subprocess.PIPE, shell=True)
    (stdoutdata, stderrdata) = process.communicate()
    exportDirectory = &#34;%s%s&#34; %(EXPORT_MAIN_DIRECTORY, stdoutdata.strip())
    return exportDirectory

def getMobileProvisionItem(filepath, key):
    cmd = &#39;mobileprovision-read -f %s -o %s&#39; %(filepath ,key)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    p.wait()
    return removeControlChars(p.stdout.read())

def updatePlistEntry(filePath, key, value):
    cmd = &#34;/usr/libexec/PlistBuddy -c &#39;Set :%s %s&#39; %s&#34; % (key, value, filePath)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print p.stderr.read()

def deletePlistEntry(filePath, key):
    cmd = &#34;/usr/libexec/PlistBuddy -c &#39;Delete :%s&#39; %s&#34; %(key, filePath)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print p.stderr.read()

def addPlistEntry(filePath, key, _type, value):
    cmd = &#34;/usr/libexec/PlistBuddy -c &#39;Add :%s %s %s&#39; %s&#34; % (key, _type, value, filePath)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print p.stderr.read()

def findFileInDirectory(ext, dir):
    fileName = &#39;&#39;
    items = os.listdir(dir)
    for name in items:
        if name.endswith(ext):
            fileName = name
            break
    if not len(fileName) &gt; 0:
        return &#39;&#39;
    return dir + &#39;/&#39; + fileName

def removeControlChars(s):
    control_chars = &#39;&#39;.join(map(unichr, range(0,32) + range(127,160)))
    control_char_re = re.compile(&#39;[%s]&#39; % re.escape(control_chars))
    return control_char_re.sub(&#39;&#39;, s)

def main():

    # Pull ios project source code from svn.
    pullSvnSourceCode()

    # Copy &#39;www&#39; files. 
    sourceWWWDir = currentDir() + &#39;/www&#39;
    projectWWWDir = &#39;/packProject/www&#39;
    destinationWWWDir = checkoutPath() + projectWWWDir
    copyFiles(sourceWWWDir, destinationWWWDir)
    for file in os.listdir(destinationWWWDir):
        if file.startswith(&#39;secret.json&#39;) or file.endswith(&#39;.mobileprovision&#39;) or file.endswith(&#39;.p12&#39;):
            os.remove(destinationWWWDir + &#39;/&#39; + file)

    # Copy app icons.
    iconAssetDirectory = checkoutPath() + &#39;/packProject/Assets.xcassets/AppIcon.appiconset&#39;
    iconSrcDirectory = projectWWWDir + &#39;/Icons/ios&#39;
    items = os.listdir(iconSrcDirectory)
    for filename in items:
        copyFile(iconSrcDirectory + &#39;/&#39; + filename, iconAssetDirectory + &#39;/&#39; + filename)
    clearDir(iconSrcDirectory)

    # Copy launch images.
    launchImageAssetDirectory = checkoutPath() + &#39;/packProject/Assets.xcassets/LaunchImage.launchimage&#39;
    LaunchImageSrcDirectory = projectWWWDir + &#39;/LaunchImages/ios&#39;
    items = os.listdir(LaunchImageSrcDirectory)
    for filename in items:
        copyFile(LaunchImageSrcDirectory + &#39;/&#39; + filename, launchImageAssetDirectory + &#39;/&#39; + filename)
    clearDir(launchImageAssetDirectory)

    # Read &#39;appConfig.json&#39; file.
    appConfig = getAppConfig()
    if appConfig is None:
        print (&#34;[packageFailed]: Not found \&#39;%s\&#39; file in \&#39;www\&#39; directory.&#34;) % (&#39;appConfig.json&#39;)
        return
    versionName = appConfig[&#39;version&#39;][&#39;name&#39;]
    versionCode = int(appConfig[&#39;version&#39;][&#39;code&#39;])
    applicationId = appConfig[&#39;id&#39;]
    appName = appConfig[&#39;appName&#39;]
    mode = &#39;Debug&#39; if appConfig[&#39;debug&#39;] else &#39;Release&#39;

    # Modify &#39;info.plist&#39; file in project/workspace according to appconfig params those read from &#39;appConfig.json&#39; file.
    infoPlistPath = checkoutPath() + &#39;/packProject/&#39; + &#39;info.plist&#39;
    updatePlistEntry(infoPlistPath, &#39;CFBundleShortVersionString&#39;, versionName)
    updatePlistEntry(infoPlistPath, &#39;CFBundleVersion&#39;, versionCode)
    updatePlistEntry(infoPlistPath, &#39;CFBundleIdentifier&#39;, applicationId)
    updatePlistEntry(infoPlistPath, &#39;CFBundleDisplayName&#39;, appName)

    # Get p12 file&#39;s password.
    secretFilePath = sourceWWWDir + &#39;/secret.json&#39;
    if os.path.exists(secretFilePath):
        secretReader = open(secretFilePath, &#39;r&#39;)
        secretKeyDict = json_load_byteified(secretReader)
        secretReader.close()
    else:
        print (&#34;[packageFailed]: Not found \&#39;%s\&#39; file in \&#39;www\&#39; directory.&#34;) % (&#39;secret.json&#39;)
        return
    iosKeyDict = secretKeyDict[&#39;ios&#39;] if &#39;ios&#39; in secretKeyDict else None
    p12Password = iosKeyDict[&#39;p12Password&#39;] if &#39;p12Password&#39; in iosKeyDict else &#39;123456&#39;

    # Import p12 file into system keychain.
    p12FilePath = findFileInDirectory(&#39;.p12&#39;, sourceWWWDir)
    unlockKeychainCmd = &#39;security unlock-keychain -p %s&#39; %MacOS_ADMIN_PASSWORD
    p = subprocess.Popen(unlockKeychainCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print p.stderr.read()
        return
    importCertCmd = &#39;security import %s -P %s -T /usr/bin/codesign&#39; % (p12FilePath, p12Password)
    p = subprocess.Popen(importCertCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print p.stderr.read()

    # Read mobileprovision profile info.
    provisionFileExtension = &#39;.mobileprovision&#39;
    provisionFilePath = findFileInDirectory(provisionFileExtension, sourceWWWDir)
    if not len(provisionFilePath) &gt; 0:
        print (&#34;[packageFailed]: Not found \&#39;%s\&#39; file in \&#39;www\&#39; directory.&#34;) %(provisionFileExtension)
        return
    teamIdentifier = getMobileProvisionItem(provisionFilePath, &#39;TeamIdentifier&#39;) #MNxxxxx8
    provisionUUID = getMobileProvisionItem(provisionFilePath, &#39;UUID&#39;)
    provisionName = getMobileProvisionItem(provisionFilePath, &#39;Name&#39;)
    # type – prints mobileprovision profile type (debug, ad-hoc, enterprise, appstore)
    provisionType = getMobileProvisionItem(provisionFilePath, &#39;type&#39;)
    teamName = getMobileProvisionItem(provisionFilePath, &#39;TeamName&#39;)
    desProvisionFilePath = PROVISONING_PROFILE_DIRECTORY + provisionUUID + provisionFileExtension
    copyFile(provisionFilePath, desProvisionFilePath)

    # Build
    archiveName = &#34;%s_%s.xcarchive&#34; % (applicationId, versionName)
    archiveFilePath = currentDir() + &#39;/&#39; + archiveName
    xcworkspaceFilePath = findFileInDirectory(&#39;.xcworkspace&#39;, checkoutPath())
    projectSettingParams = &#39;PRODUCT_BUNDLE_IDENTIFIER=%s PROVISIONING_PROFILE_SPECIFIER=%s PROVISIONING_PROFILE=%s&#39; %(applicationId, provisionName, provisionUUID)
    archiveCmd = &#39;xcodebuild -workspace %s -scheme %s -configuration %s archive -archivePath %s -destination generic/platform=iOS build %s&#39; % (xcworkspaceFilePath, &#39;packProject&#39;, mode, archiveFilePath, projectSettingParams)
    p = subprocess.Popen(archiveCmd, shell=True, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print (&#34;[packageFailed]: %s&#34;) %p.stderr.read()
        return

    # Create &#39;exportOptions.plist&#39; file and export ipa.
    exportOptionsPlistFilePath = currentDir() + &#39;/&#39; + &#39;exportOptions.plist&#39;
    addPlistEntry(exportOptionsPlistFilePath, &#39;provisioningProfiles&#39;, &#39;dict&#39;, &#39;&#39;)
    addPlistEntry(exportOptionsPlistFilePath, &#39;provisioningProfiles:&#39;+ applicationId, &#39;string&#39;, provisionUUID)
    addPlistEntry(exportOptionsPlistFilePath, &#39;teamID&#39;, &#39;string&#39;, teamIdentifier)
    # {app-store, ad-hoc, enterprise, development}
    method = &#39;development&#39; if cmp(provisionType, &#39;debug&#39;) == 0 else provisionType
    method = &#39;app-store&#39; if cmp(method, &#39;appstore&#39;) == 0 else method
    addPlistEntry(exportOptionsPlistFilePath, &#39;method&#39;, &#39;string&#39;, method)
    exportDirectory = buildExportDirectory()
    exportCmd = &#34;xcodebuild -exportArchive -archivePath %s -exportPath %s -exportOptionsPlist %s&#34; % (archiveFilePath, exportDirectory, exportOptionsPlistFilePath)
    p = subprocess.Popen(exportCmd, shell=True, stderr=subprocess.PIPE)
    p.wait()
    if p.returncode != 0:
        print (&#34;[packageFailed]: %s&#34;) %p.stderr.read()
    else:
        ipaVersion = str(versionCode) if mode == &#39;Debug&#39; else versionName
        ipaName = applicationId + &#39;_&#39; + ipaVersion + &#39;.ipa&#39;
        os.rename(exportDirectory + &#39;/packProject.ipa&#39;, exportDirectory + &#39;/&#39; + ipaName)
        print(&#34;[packageName]: %s&#34;) % (ipaName)
        print(&#34;[packagePath]: %s&#34;) % (exportDirectory)

    cleanArchiveFile(archiveFilePath)

    p = subprocess.Popen(&#39;security lock-keychain&#39;, shell=True)
    p.wait()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre><p><em>欢迎留言交流</em></p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/ios/ rel=tag>iOS</a></li><li class=tags__item><a class="tags__link btn" href=/tags/python/ rel=tag>Python</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><p class=authorbox__warning><strong>WARNING:</strong> Authorbox is activated, but [Author] parameters are not specified.</p></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/android-gradle-build/ rel=prev><span class=pager__subtitle>«&#8201;上一篇</span><p class=pager__title>Android Gradle 注入编译变量</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/ios-wvjb-sc-analyse/ rel=next><span class=pager__subtitle>下一篇&#8201;»</span><p class=pager__title>WebViewJavascriptBridge 源码剖析</p></a></div></nav></div><aside class="sidebar sidebar--left"><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=搜索... name=q aria-label=搜索...>
</label><input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://redscarf.me/></form></div><div class="widget-recent widget"><h4 class=widget__title>近期文章</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/economy-fp-hsbc/>付鹏11月24日在HSBC内部演讲速记</a></li><li class=widget__item><a class=widget__link href=/db-dynamic-column/>数据库的动态列</a></li><li class=widget__item><a class=widget__link href=/multi-tenant/>多租户</a></li><li class=widget__item><a class=widget__link href=/prompt-template/>Prompt 框架模版</a></li><li class=widget__item><a class=widget__link href=/kafka-1/>Kafka 总结</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>分类</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/ai/>AI</a></li><li class=widget__item><a class=widget__link href=/categories/android/>Android</a></li><li class=widget__item><a class=widget__link href=/categories/c/>C</a></li><li class=widget__item><a class=widget__link href=/categories/db/>DB</a></li><li class=widget__item><a class=widget__link href=/categories/diary/>Diary</a></li><li class=widget__item><a class=widget__link href=/categories/docker/>Docker</a></li><li class=widget__item><a class=widget__link href=/categories/ios/>IOS</a></li><li class=widget__item><a class=widget__link href=/categories/java/>Java</a></li><li class=widget__item><a class=widget__link href=/categories/news/>News</a></li><li class=widget__item><a class=widget__link href=/categories/tech/>Tech</a></li><li class=widget__item><a class=widget__link href=/categories/web/>Web</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BF%BB%E8%AF%91/>翻译</a></li><li class=widget__item><a class=widget__link href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>标签</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/android/ title=Android>Android (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/arc/ title=ARC>ARC (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/autolayout/ title=AutoLayout>AutoLayout (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/block/ title=Block>Block (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/bluetooth/ title=Bluetooth>Bluetooth (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/c/ title=C>C (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/chatgpt/ title=ChatGPT>ChatGPT (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/container/ title=Container>Container (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/db/ title=DB>DB (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/devops/ title=Devops>Devops (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/diary/ title=Diary>Diary (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/docker/ title=Docker>Docker (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/dynamic/ title=Dynamic>Dynamic (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/economy/ title=Economy>Economy (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/gcd/ title=GCD>GCD (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/gradle/ title=Gradle>Gradle (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/hook/ title=Hook>Hook (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/ios/ title=IOS>IOS (13)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/java/ title=Java>Java (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/javascript/ title=JavaScript>JavaScript (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/kafka/ title=Kafka>Kafka (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/management/ title=Management>Management (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/mariadb/ title=Mariadb>Mariadb (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/multi-tenant/ title=Multi-Tenant>Multi-Tenant (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/mysql/ title=MySQL>MySQL (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/nginx/ title=Nginx>Nginx (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/notification/ title=Notification>Notification (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/plugin/ title=Plugin>Plugin (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/privacy/ title=Privacy>Privacy (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/prompt/ title=Prompt>Prompt (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/python/ title=Python>Python (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/saas/ title=SAAS>SAAS (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/security/ title=Security>Security (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/terminology/ title=Terminology>Terminology (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/token/ title=Token>Token (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/tool/ title=Tool>Tool (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/web/ title=Web>Web (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/webview/ title=WebView>WebView (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/ title=中间件>中间件 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=源码剖析>源码剖析 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=读书笔记>读书笔记 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%BD%AC%E8%BD%BD/ title=转载>转载 (1)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">社交</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/iCocoa target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg>
<span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:whs543@sina.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg>
<span>whs543@sina.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 Haisheng Wu.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/pfadfinder-konstanz/hugo-dpsg/ rel="nofollow noopener" target=_blank>DPSG</a>主題</span>
<span><a href=/imprint>Imprint and Privacy</a></span></div><div class=footer__copyright>Donate!</div></div></footer><script async defer src=/js/menu.js></script><script src=/js/custom.js></script></body></html>