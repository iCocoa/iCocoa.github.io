<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on Haisheng Wu&#39;s Tech Blog</title>
    <link>http://localhost:1313/tags/nginx/</link>
    <description>Recent content in Nginx on Haisheng Wu&#39;s Tech Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 08 Nov 2016 20:09:40 +1000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HTTPS 单向/双向认证</title>
      <link>http://localhost:1313/https-uni-bidirectional-authentication/</link>
      <pubDate>Tue, 08 Nov 2016 20:09:40 +1000</pubDate>
      <guid>http://localhost:1313/https-uni-bidirectional-authentication/</guid>
      <description>&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg&#34; alt=&#34;http&amp;amp;https&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。&lt;/p&gt;&#xA;&lt;p&gt;Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。&lt;/p&gt;&#xA;&lt;p&gt;SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg&#34; alt=&#34;asymmetric-encryption&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;单向认证&#34;&gt;单向认证&lt;/h2&gt;&#xA;&lt;p&gt;客户端校验服务端证书&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg&#34; alt=&#34;unidirectional-authentication&#34;&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;client hello&lt;/strong&gt;&#xA;客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;server hello&lt;/strong&gt;&#xA;服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;authentication&lt;/strong&gt;&#xA;客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;send premaster key&lt;/strong&gt;&#xA;客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;decrypt premaster key&lt;/strong&gt;&#xA;服务端解密 premaster key&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;create session key&lt;/strong&gt;&#xA;客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;client send finished&lt;/strong&gt;&#xA;客户端使用 session key 加密一条 finished 消息并发送给服务端。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
