<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on Haisheng Wu's Tech Blog</title><link>http://www.redscarf.me/categories/web/</link><description>Recent content in Web on Haisheng Wu's Tech Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 24 Jul 2023 19:30:32 +1000</lastBuildDate><atom:link href="http://www.redscarf.me/categories/web/index.xml" rel="self" type="application/rss+xml"/><item><title>多租户</title><link>http://www.redscarf.me/multi-tenant/</link><pubDate>Mon, 24 Jul 2023 19:30:32 +1000</pubDate><guid>http://www.redscarf.me/multi-tenant/</guid><description>&lt;h1 id="多租户软件架构概述">多租户软件架构概述&lt;/h1>
&lt;h2 id="多租户软件架构简介">多租户软件架构简介&lt;/h2>
&lt;p>在多租户软件架构中，一个应用程序实例及其底层的数据库和硬件资源服务于多个租户（或用户账户）。一个租户可以是单个用户，但更常见的是一组用户，例如一个客户组织，他们共享同一个应用程序实例。每个租户的数据与其他租户的数据相互隔离，彼此不可见，从而确保所有租户的数据安全和隐私。&lt;/p>
&lt;h2 id="多租户架构的优势">多租户架构的优势&lt;/h2>
&lt;h3 id="1-低成本">1. 低成本&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>成本效益&lt;/strong>：软件提供商可以通过单一应用程序实例和基础设施为多个租户提供服务，租户共同分担软件维护、基础设施和数据中心运营的成本，因此持续成本通常低于单租户安排。SaaS软件通常以可预测的月度或年度订阅价格提供，价格基于用户数量、使用级别或应用程序中管理的数据量。&lt;/li>
&lt;/ul>
&lt;h3 id="2-可伸缩性">2. 可伸缩性&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>按需扩展&lt;/strong>：租户可以根据需求进行扩展，新用户可以访问相同的应用程序实例，通常只需增加相应的订阅费用。&lt;/li>
&lt;/ul>
&lt;h3 id="3-无代码定制化">3. 无代码定制化&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>高度可配置&lt;/strong>：SaaS多租户产品具有高度可配置性，每个租户客户无需昂贵、耗时且有时风险较高的定制开发，即可根据其特定业务需求定制应用程序。&lt;/li>
&lt;/ul>
&lt;h3 id="4-持续更新与维护">4. 持续更新与维护&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>持续更新&lt;/strong>：多租户软件提供商负责更新和补丁。新功能添加或修复应用无需客户参与，且只需更新一次（与单租户架构不同，提供商必须更新每个软件实例）。&lt;/li>
&lt;/ul>
&lt;h3 id="5-提高生产率">5. 提高生产率&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>专注核心业务&lt;/strong>：租户无需管理基础设施或软件，可以专注于更重要的任务，从而提高生产率。&lt;/li>
&lt;/ul>
&lt;h2 id="多租户实现方式">多租户实现方式&lt;/h2>
&lt;h3 id="red-hat-多租户实现">Red Hat 多租户实现&lt;/h3>
&lt;p>Red Hat 使用以下三种方式实现多租户：&lt;/p>
&lt;h4 id="1-应用层多租户">1. 应用层多租户&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>应用层多租户&lt;/strong>：在应用程序级别实现多租户，通过逻辑隔离不同租户的数据和资源。&lt;/li>
&lt;/ul>
&lt;h4 id="2-使用命名空间">2. 使用命名空间&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>命名空间&lt;/strong>：命名空间将全局系统资源封装在一个抽象中，使其在命名空间内的进程看来，它们拥有全局资源的独立实例。对全局资源的更改对命名空间内的其他进程可见，但对其他进程不可见。命名空间的一个用途是实现容器。&lt;/li>
&lt;/ul>
&lt;h4 id="3-集群层多租户">3. 集群层多租户&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>集群层多租户&lt;/strong>：在集群级别实现多租户，通过物理隔离不同租户的资源和数据。&lt;/li>
&lt;/ul>
&lt;h3 id="linux-命名空间">Linux 命名空间&lt;/h3>
&lt;p>Linux 命名空间是一种操作系统层级的资源隔离技术，能够将 Linux 的全局资源划分为命名空间范围内的资源，不同命名空间间的资源彼此透明，不同命名空间里的进程无法感知到其他命名空间里面的进程和资源。Linux 命名空间实现了 6 项资源隔离，涵盖了一个小型操作系统的运行要素，包括主机名、用户权限、文件系统、网络、进程号、进程间通信。Linux 命名空间是操作系统虚拟化技术（如容器）的底层实现支撑。&lt;/p>
&lt;p>&lt;a href="https://developers.redhat.com/articles/2022/05/09/approaches-implementing-multi-tenancy-saas-applications#using_application_logic_to_provide_multi_tenancy">Approaches to implementing multi-tenancy in SaaS applications&lt;/a>
&lt;a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">linux namespace&lt;/a>&lt;/p></description></item><item><title>Json Web Token</title><link>http://www.redscarf.me/jwt/</link><pubDate>Wed, 09 Oct 2019 22:15:32 +1000</pubDate><guid>http://www.redscarf.me/jwt/</guid><description/></item><item><title>HTTPS 单向/双向认证</title><link>http://www.redscarf.me/https-uni-bidirectional-authentication/</link><pubDate>Tue, 08 Nov 2016 20:09:40 +1000</pubDate><guid>http://www.redscarf.me/https-uni-bidirectional-authentication/</guid><description>&lt;h2 id="https">HTTPS&lt;/h2>
&lt;p>&lt;img src="https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg" alt="http&amp;amp;https">&lt;/p>
&lt;p>HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。&lt;/p>
&lt;p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。&lt;/p>
&lt;p>SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。&lt;/p>
&lt;p>&lt;img src="https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg" alt="asymmetric-encryption">&lt;/p>
&lt;h2 id="单向认证">单向认证&lt;/h2>
&lt;p>客户端校验服务端证书&lt;/p>
&lt;p>&lt;img src="https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg" alt="unidirectional-authentication">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>client hello&lt;/strong>
客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>server hello&lt;/strong>
服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>authentication&lt;/strong>
客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>send premaster key&lt;/strong>
客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>decrypt premaster key&lt;/strong>
服务端解密 premaster key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>create session key&lt;/strong>
客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>client send finished&lt;/strong>
客户端使用 session key 加密一条 finished 消息并发送给服务端。&lt;/p></description></item></channel></rss>