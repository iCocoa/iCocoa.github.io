<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Tech - Haisheng Wu's Tech Blog</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Tech"><meta property="og:description" content="This is Haisheng Wu's Tech Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://redscarf.me/categories/tech/"><meta itemprop=name content="Tech"><meta itemprop=description content="This is Haisheng Wu's Tech Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tech"><meta name=twitter:description content="This is Haisheng Wu's Tech Blog"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel=alternate type=application/rss+xml href=/categories/tech/index.xml title="Haisheng Wu's Tech Blog"><link rel="shortcut icon" href=/favicon.ico></head><body class=body><header class=header><div class="logo logo--mixed"><div class=container><a class=logo__link href=/ title="Haisheng Wu's Blog" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.png></div><div class="logo__item logo__text"><div class=logo__title>Haisheng Wu's Blog</div><div class=logo__tagline>Tech Blog</div></div></a></div></div></header><div class=divider></div><div class="container wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>Tech</h1></header><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/ai-idea-deepseek/ rel=bookmark>IntelliJ IDEA 集成 DeepSeek 辅助编程</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2025-02-05T21:53:32+10:00>2025-02-05</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/tech/ rel=category>Tech</a>, <a class=meta__link href=/categories/ai/ rel=category>AI</a></span></div></div></header><div class="content list__excerpt post__content clearfix">在人工智能辅助编程工具日益普及的今天，DeepSeek 以其卓越的性能和实惠的价格在开发者社区中迅速走红。作为一名从 DeepSeek v1 就开始使用的资深用户，我见证了它在代码生成、问题解答和开发建议等方面的持续进步。当时为什么选择用它？一方面，与 ChatGPT 相比，DeepSeek 不仅提供了更具竞争力的 API 定价策略，其网页版对话应用更是完全免费。另一方面，经过与国内其他同类产品的深入对比测试，我发现 DeepSeek 的回复更加简洁精准，特别适合技术场景下的使用需求。
随着 DeepSeek-R1 版本的发布，其性能指标在多个基准测试中均表现出显著优势。本文将详细介绍如何将这一强大的 AI 模型集成到 IntelliJ IDEA 中，为您的开发工作流程注入新的活力。
环境准备 在开始集成之前，请确保您的开发环境满足以下要求：
IntelliJ IDEA 2023 或更高版本 （注：较早版本的 IDEA 可能无法完全支持 codeGPT 插件的 UI 显示） 下载地址：IntelliJ IDEA 官方下载页面
安装 codeGPT 插件 codeGPT 是一个功能强大的插件，它充当了 IDE 与 AI 模型之间的桥梁。通过它，开发者可以直接在 IDE 中调用 DeepSeek 的服务。
安装步骤：
打开 IntelliJ IDEA 进入插件市场（File -> Settings -> Plugins） 搜索 &ldquo;codeGPT&rdquo; 并安装 重启 IDE 完成安装 获取 DeepSeek API 密钥 访问 DeepSeek 开发者平台：https://platform.</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/ai-idea-deepseek/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/d-route-alg/ rel=bookmark>应用层数据分布路由算法</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-11-11T20:15:32+10:00>2024-11-11</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/web/ rel=category>Web</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a>, <a class=meta__link href=/categories/algorithm/ rel=category>Algorithm</a></span></div></div></header><div class="content list__excerpt post__content clearfix">应用层数据分布路由算法主要用于分布式系统中，将数据或请求分配到多个节点（服务器、存储设备或服务实例）上，以实现负载均衡、高可用性和扩展性。常见的有： 哈希取模（Modulo Hashing）、随机路由 (Random Routing)、一致性哈希（Consistent Hashing）等等。
随机路由 (Random Routing) 原理：随机选择一个节点处理请求。
特点： 简单直观，但不能保证均匀分布。 不适合高负载系统，因为可能导致数据倾斜。
应用：用于初步负载均衡或测试场景。
哈希取模（Modulo Hashing） 原理：使用简单的哈希函数对节点数量取模，将请求分配到相应节点。
公式：节点 = Hash(Key) % N，其中 N 是节点数量。
特点：简单高效，易于实现。
缺点：节点增减时，所有数据都需要重新分配，无法满足动态性要求。
应用：适用于小规模系统或节点数固定的场景。
一致性哈希（Consistent Hashing） 原理：将节点和数据映射到一个逻辑环上，数据存储在与其哈希值最接近的节点中。
特点： 高动态性：节点增减时，仅影响邻近的节点，减少数据迁移量。 负载均衡：通过虚拟节点均衡数据分布。
应用： 分布式缓存（如 Memcached、Redis）。 分布式存储（如 Cassandra、Amazon Dynamo）。 微服务负载均衡。
一致性哈希算法实现 一致性Hash首先构建一个Hash 环的结构。环的大小是 0 到2^32-1，也就是无符号整型的取值范围，0 和最后一个 2^32-1 首尾相连，构成一个 Hash 环。将每个缓存服务节点 hash值放到环上。每次一次进行服务器查找路由计算的时候，都是根据key 的hash 值顺时针查找距离它最近的服务器节点。通过这种方式，key 不变的情况下找到的总是相同的服务器。但是，Hash 值是一个随机值，把一个随机值放到一个环上以后，可能是不均衡的，也就是某两个服务器节点在环上的距离可能很近，而和其它的服务器节点距离很远。这会导致有些服务负载压力特别大，有些服务器的负载压力特别小。在实践中，需要使用虚拟节点对方法进行改进，把一个服务节点放到环上时，把它虚拟成200个虚拟节点，然后把 200 个虚拟节点随机放到环上。key 依然是按照顺时针查找距离它最近的虚拟节点，再根据映射关系找到真正的物理节点。
Java 代码实现如下：
public class Consistent { SortedMap&lt;Long, PhysicalNode> ring; int virtualNodeCount; public Consistent(int virtualNodeCount) { ring = new TreeMap(); this.</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/d-route-alg/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/ai-note/ rel=bookmark>AI 笔记</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-01-09T20:10:22+10:00>2024-01-09</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/ai/ rel=category>AI</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">如何找落地场景 从最熟悉的领域入手 让 AI 学习最厉害员工的能力，再让 ta 辅助其他员工，实现降本增效 找 【文本进，文本出】的场景 别求大而全。将任务拆解，先解决小任务、小场景（小切口、大纵深） 通俗原理 通过上文，猜测下一个词出现的概率。
大模型阅读了大量人类说过的所有话（训练），就是机器学习 把一串 token 后面跟着的不同 token 的概率存入神经网络，保存的数据就是参数，也叫权重 当我们给它若干 token，大模型就能算出概率最高的下一个 token 是什么。这就是生成，也叫推理 用生成的 token，再加上上文，就能继续生成下一个 token。以此类推，生成更多文字 如何用好 AI？ 数字神经网络和人脑的生物神经网络，在数学原理上是一样的。 ——OpenAI 首席科学家 Ilya Sutskever
所以，把 AI 当人看！！！和人怎么相处就和 AI 怎么相处。
使用 AI 的几种模式 Embedding AI（少） AI Copilot（协助） AI Agent（代理） 从上往下，AI 参与处理的任务越多。
AI 相关的编程基本是 Python 语言。 安装 OpenAI pip3 install --upgrade openai 大模型里面的角色 System Role：主要是定义系统的行为规范和全局设置。 Assistant Role：主要负责与用户的交互，根据用户的输入生成响应。 这两种角色在构建对话系统时是互补的，共同决定了系统的整体行为和用户体验。
LangChain 里面的 LLM 模块和 ChatModel LLM：通常用于生成单个文本输出，适合一次性提示和响应的场景。 ChatModel：专门用于处理对话，能够记住对话历史并生成连贯的回复，适合构建多轮对话系统。 框架对比 Llamaindex：主要用于构建和管理向量数据库，特别适合文档检索和知识库管理。 Semantic Kernel：专注于构建对话系统，支持多轮对话和上下文管理，适合构建复杂的对话应用。 LangChain：全面的框架，支持链式处理和多种模型，适合构建多样化的语言模型应用。 Replicate Replicate 是一个云端 AI 模型运行平台，它允许用户通过云端 API 直接运行机器学习模型，非专业人士也能上手。</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/ai-note/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/db-dynamic-column/ rel=bookmark>数据库的动态列</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-07-25T20:17:32+10:00>2023-07-25</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/db/ rel=category>DB</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">动态列的几种设计思路 在需求开发过程中，我们有时会遇到一种场景：某个具体业务中的属性是动态的。在理想情况下，我们可以使用穷举法对所有可能的属性进行分析，然后进行分类，最终形成一套解决方案。然而，现实往往是骨感的，Leader和客户通常不会给我们这个时间。因此，我们需要探讨一些更为实际的解决方案。
一、使用数据库DDL进行动态创建 优点：
操作简单，只需通过SQL管理即可实现。 缺点：
不同情况下的动态字段增加会导致表结构膨胀。 在已有数据的表中修改字段容易导致锁表，影响性能。 二、使用数据库预留字段 优点：
与数据库无关，对业务侵入性小。 缺点：
扩展性差，超出预留字段范围后如何处理新字段？ 可读性差，预留字段通常为attr1、attr2等，影响字段的可读性。 性能较低，为兼容多种数据类型，预留字段通常采用较长的文本数据类型存储，影响数据库性能。 三、使用数据库中的JSON数据类型 优点：
使用简单，绝大多数编程语言都支持JSON操作，方便快捷。 对于MySQL或PostgreSQL等数据库，已原生支持JSON字段，可基于JSON进行扩展查询。 JSON采用key:value形式存储数据，可避免字段可读性差的问题，通过规范命名提高可读性。 扩展性高，增加或删除字段实现简单，直接移除key即可，不影响表性能。 缺点：
JSON字段查询操作与普通字段稍有差异，有一定复杂度。 JSON字段的索引性能有待提高。 四、使用NoSQL数据库 优点：
采用MongoDB等JSON数据库，可以快速扩展。 专业数据存储，查询等性能可针对优化，性能高。 缺点：
需要一定的学习成本。 综上所述，第一种和第二种方案若非必要，不建议采用。第三种方案在中小项目中能应对绝大多数需求。如果存储的数据较多且性能要求较高，可以考虑采用第四种方案或第三、四种方案相结合。
支持动态列的数据库 MariaDB 通过创建BLOB列（最大64k？），可以使用mariadb-dynamic-columns实现动态列。
示例： CREATE TABLE items ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name varchar(100) NOT NULL, attributes BLOB ); 插入数据时使用特定函数（COLUMN_CREATE）指定动态列的数据结构，key/value形式： INSERT INTO items (name, attributes) VALUES ('MariaDB t-shirt', COLUMN_CREATE('colour','blue', 'size','XXL')), ('MariaDB t-shirt', COLUMN_CREATE('colour','blue', 'size','XL')), ('Samsung Galaxy S5', COLUMN_CREATE('colour','white', 'OS', 'Android', 'type', 'phone')), ('Samsung Galaxy Pro 3', COLUMN_CREATE('colour','white', 'size',8, 'OS', 'Android', 'resolution','1920x1200', 'type','tablet')); 查询时使用COLUMN_JSON函数，返回JSON格式的数据： SELECT name AS Item, COLUMN_JSON(attributes) AS 'Dynamic Columns' FROM items LIMIT 1; 使用COLUMN_LIST函数列举列中包含的属性，如colour、size： SELECT name AS Item, COLUMN_LIST(attributes) AS 'Attribute Names' FROM items; 查询动态列中具体的某个属性，如colour： SELECT name AS Item, COLUMN_GET(attributes, 'colour' AS CHAR) AS Colour FROM items; PostgreSQL 支持JSON数据类型，相比普通text文本字段类型，JSON数据类型强制要求列中每个存储的值都符合JSON格式规则。</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/db-dynamic-column/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/multi-tenant/ rel=bookmark>多租户</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-07-24T19:30:32+10:00>2023-07-24</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/web/ rel=category>Web</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">多租户架构概述与实现 多租户（Multi-tenancy） 是一种软件架构模式，允许多个客户（租户）共享同一个应用实例和底层资源，同时保障租户数据的隔离与安全。租户可以是企业、部门或个人用户。其目标是在优化资源利用效率的同时，满足租户对个性化、安全性和成本效益的需求。
多租户的背景与优势 背景 云计算的普及：随着云计算技术的发展，SaaS（软件即服务）模式迅速崛起，多租户架构成为共享资源和优化成本的关键技术。 资源利用效率需求：通过在同一物理或逻辑服务器上运行多个租户应用，提高资源利用率并降低运营成本。 个性化和隔离需求：满足租户定制化的同时，确保数据安全与隔离。 降低运维成本：多租户架构显著减少了软件升级与补丁管理的复杂性。 优势 低成本：通过共享资源，显著降低基础设施和维护费用。SaaS多租户软件通常以订阅形式提供，租户分担运营成本。 可伸缩性：租户可根据需求灵活扩展，只需调整订阅配置。 无代码定制化：无需复杂的开发，租户即可通过配置满足特定业务需求。 持续更新与维护：软件提供商统一管理更新与补丁，租户自动获得改进，无需额外操作。 提高生产率：租户可专注于核心业务，无需管理基础设施或软件。 多租户架构的实现方式 根据隔离程度和成本，不同场景下的多租户实现方式如下：
1. 共享数据库 + 共享架构 所有租户共享一个数据库实例与数据库架构，租户数据通过租户标识（如租户ID）区分。
优点： 成本低：资源利用率高，节约硬件与运维成本。 开发简单：实现复杂度较低。 适合中小规模租户：支持批量操作。 缺点： 安全性较低：需严格控制租户间的数据隔离。 扩展性有限：租户增长可能引发性能瓶颈。 适用场景：小型SaaS应用，租户间数据隔离需求较低。 2. 独立数据库 + 共享架构 每个租户拥有独立的数据库，但共享数据库架构。
优点： 数据隔离性好：提升安全性。 扩展性强：可独立扩展租户数据库。 缺点： 成本较高：需分配单独数据库实例。 运维复杂度提升：需管理多个数据库实例。 适用场景：中型SaaS应用，数据隔离需求高。 3. 独立数据库 + 独立架构 每个租户拥有独立的数据库与架构，支持更高的定制化。
优点： 高度隔离：数据、性能、定制化完全独立。 灵活性高：满足复杂业务需求。 缺点： 成本高：需为每个租户单独配置资源。 开发与运维复杂度高：架构需逐一维护。 适用场景：大型企业级应用，少量租户但数据敏感且需求复杂。 4. 容器化隔离 通过容器技术（如Docker），为每个租户提供独立的容器化服务。
优点： 部署灵活：每个容器的环境可独立配置。 高扩展性：便于弹性伸缩。 强隔离性：容器内外环境相互独立。 缺点： 运维复杂：需管理容器编排工具（如Kubernetes）。 成本：资源分配灵活性可能引发一定浪费。 适用场景：需要高度隔离和动态扩展的中大型应用。 特殊技术：命名空间与多租户 Linux命名空间 Linux命名空间是一种操作系统层面的资源隔离技术，可以将全局资源划分为命名空间范围内的资源。命名空间隔离涵盖主机名、用户权限、文件系统、网络、进程等，支撑了容器技术（如Docker）。
命名空间通过为每个租户创建独立的资源视图来实现隔离。与Cgroups（控制组）结合使用时，可以进一步限制每个租户对CPU、内存和I/O的使用，从而实现资源的公平分配。例如，网络命名空间可以为每个租户分配独立的虚拟网络接口和IP地址，进而避免资源争夺。
在多租户架构中，Linux命名空间的典型应用包括：</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/multi-tenant/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/ai-prompt-template/ rel=bookmark>Prompt 框架模版</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-07-09T21:30:32+10:00>2023-07-09</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/ai/ rel=category>AI</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">Crispe Matt Nigh 的 CRISPE Framework，比较适合用于编写 prompt 模板。CRISPE 分别代表以下含义：
CR: Capacity and Role（能力与角色）。你希望 ChatGPT 扮演怎样的角色。
I:Insight（洞察力），背景信息和上下文（坦率的说我觉得用Context 更好）。
S： Statement（指令），你希望 ChatGPT 做什么。
P：Personality（个性），你希望 ChatGPT 以什么风格或方式回答你。
E：Experiment（尝试），要求 ChatGPT 为你提供多个答案。
以下是这几个参数的例子：
Step Example Capacity and Role Act as an expert on software development on the topic of machine learning frameworks, and an expert blog writer. 把你想象成机器学习框架主题的软件开发专家，以及专业博客作者。 Insight The audience for this blog is technical professionals who are interested in learning about the latest advancements in machine learning.</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/ai-prompt-template/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/kafka-1/ rel=bookmark>Kafka 总结</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-01-27T20:56:50+10:00>2022-01-27</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/java/ rel=category>Java</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">consumer 是推还是拉？ https://kafka.apache.org/documentation/#design_pull kafka 生产者端生成消息推送（push）到 broker，消费者端从 broker 拉取（pull）消息。
统一采用 pull 的方式？ boker 从生产者 pull 消息。在生产者数量庞大的场景下，broker 需要管理维护很多的关系，简直是梦魇。所以采用的是生产者往 broker push 消息。
统一采用 push 的方式？ broker 往 consumer push 消息。在 consumer 多样化的场景下，如果生产者的生产速率远远大于消费者，broker 控制不好，push 会造成 consumer 不堪重负。反之，由 consumer 根据自身处理速率来决定何时从 broker 拉取消息，会更好。采用 pull 的弊端在于，如果 broker 没有消息，那么就会空转，这可以通过在调用 poll 接口时传入等待时间阻塞或者传入批次数据包大小来等待阻塞。
kafka 的 ack 机制 客户端连接到 leader broker 上，发送消息之后，等待或不等待 leader broker 的 ack（是否等待取决于参数request.required.acks 配置）。比如： 客户端设置 acks=0，客户端不作任何等待，即使消息没有写入 kafka 集群。 客户端设置 acks=1，客户端会等待 Leader 副本成功写入后返回的确认，但如果 Leader 副本在消息被同步到其他副本之前崩溃，消息可能会丢失。 客户端设置 acks=all 或 acks=-1参数，leader 在接收到客户端的消息之后，先写入日志文件，然后往同步副本（ISR）发送数据，等所有的 follower 都确认消息写入成功后，leader 再给客户端发送 ack 确认。</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/kafka-1/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/hugo_newbie/ rel=bookmark>博客搬新家了！！！</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-07-03T00:06:32+10:00>2021-07-03</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/diary/ rel=category>Diary</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">将博客生成器从原来的 Hexo 换成了 Hugo。
特别感谢闫博推荐 Hugo 这个静态网站生成器并提供 技术支持！</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/hugo_newbie/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/docker-base-use/ rel=bookmark>Docker 使用</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-07-07T22:15:32+10:00>2020-07-07</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/docker/ rel=category>Docker</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">通过 Docker 命令行工具与 Docker Daemon 进程通讯使用。
使用步骤 安装 Docker 到宿主机（物理机） 到仓库拉取镜像
https://hub.docker.com 运行镜像产生容器（实例，一个镜像可以运行多个） 镜像操作 搜索镜像 docker search imageName 拉取镜像 docker pull imageName:tag tag 版本号，如不指定默认是 latest 查看本地镜像 docker images 删除镜像 docker rmi imageID docker rmi [repositoryname]:[tag] 删除所有未加标签的镜像(untagged) docker rmi $(docker images | grep "^&lt;none>" | awk "{print $3}") 重命名镜像 docker tag imageId imageName:tag 通过本地 Dockerfile 文件编译镜像文件 docker build -t mop:latest - &lt; mopDockerfile 容器操作 进入容器 sudo docker exec -it ubuntu bash docker exec -it ardupilot bash 查看容器 docker ps -a -a：所有容器，包括停止的 -q：查看停止的容器，不加选项默认查看运行中的容器 保存容器 sudo docker save ubuntu > ubuntu_save.</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/docker-base-use/>阅读全文…</a></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/lombok/ rel=bookmark>Lombok</a></h2><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-04-30T19:10:32+01:00>2020-04-30</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/java/ rel=category>Java</a>, <a class=meta__link href=/categories/tech/ rel=category>Tech</a></span></div></div></header><div class="content list__excerpt post__content clearfix">介绍 Lombok 是提升 Java 编码效率常用的工具，借助它开发人员可以使用注解来自动生成一些模版代码。比如 getter、setter、equals、toString 等方法。
安装 在 maven 中添加依赖 &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>1.18.4&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> 在编辑器中添加插件 如：Intellij Idea，在 setting 的 plugin 里搜索lombok plugin，安装插件
使用 常用的几个注解
@Data ：注在类上，自动生成类的 get、set、equals、hashCode、canEqual、toString 方法
@AllArgsConstructor ：注在类上，自动生成类的全参构造方法
@NoArgsConstructor ：注在类上，自动生成类的无参构造
@Setter ：注在属性上，自动生成 set 方法
@Getter ：注在属性上，自动生成 get 方法
@EqualsAndHashCode ：注在类上，自动生成对应的 equals 和 hashCode 方法
@Log4j/@Slf4j ：注在类上，自动生成对应的 Logger 对象，变量名为 log
@Cleanup(&ldquo;close&rdquo;)：注在本地变量上，自动释放资源（如：关闭 InputStream）
@Synchronized：注在方法上，自动生成一个私有锁变量
@SneakyThrows：自动生成异常处理语句
注意继承关系中使用 Lombok @EqualsAndHashCode 与 @ToString 注解默认情况下忽略父类的成员变量。譬如打印时 toString 返回的结果中缺少父类的成员变量，解决办法是在注解中设置 callSuper 属性为 true， @ToString(callSuper = true) 、@EqualsAndHashCode(callsuper = true)。</div><div class="list__footer clearfix"><a class="list__footer-readmore btn" href=/lombok/>阅读全文…</a></div></article></main><div class=pagination><span class="pagination__item pagination__item--current">1/3</span>
<a class="pagination__item pagination__item--next btn" href=/categories/tech/page/2/>»</a></div></div><aside class="sidebar sidebar--left"><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=搜索... name=q aria-label=搜索...>
</label><input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://redscarf.me/></form></div><div class="widget-recent widget"><h4 class=widget__title>近期文章</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/ai-idea-deepseek/>IntelliJ IDEA 集成 DeepSeek 辅助编程</a></li><li class=widget__item><a class=widget__link href=/economy-fp-hsbc/>付鹏11月24日在HSBC内部演讲速记</a></li><li class=widget__item><a class=widget__link href=/d-route-alg/>应用层数据分布路由算法</a></li><li class=widget__item><a class=widget__link href=/ai-note/>AI 笔记</a></li><li class=widget__item><a class=widget__link href=/db-dynamic-column/>数据库的动态列</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>分类</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/ai/>AI</a></li><li class=widget__item><a class=widget__link href=/categories/algorithm/>Algorithm</a></li><li class=widget__item><a class=widget__link href=/categories/android/>Android</a></li><li class=widget__item><a class=widget__link href=/categories/c/>C</a></li><li class=widget__item><a class=widget__link href=/categories/db/>DB</a></li><li class=widget__item><a class=widget__link href=/categories/diary/>Diary</a></li><li class=widget__item><a class=widget__link href=/categories/docker/>Docker</a></li><li class=widget__item><a class=widget__link href=/categories/ios/>IOS</a></li><li class=widget__item><a class=widget__link href=/categories/java/>Java</a></li><li class=widget__item><a class=widget__link href=/categories/news/>News</a></li><li class=widget__item><a class=widget__link href=/categories/refactor/>Refactor</a></li><li class=widget__item><a class=widget__link href=/categories/tech/>Tech</a></li><li class=widget__item><a class=widget__link href=/categories/web/>Web</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BF%BB%E8%AF%91/>翻译</a></li><li class=widget__item><a class=widget__link href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>标签</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/ai/ title=AI>AI (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/algorithm/ title=Algorithm>Algorithm (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/android/ title=Android>Android (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/arc/ title=ARC>ARC (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/autolayout/ title=AutoLayout>AutoLayout (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/block/ title=Block>Block (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/bluetooth/ title=Bluetooth>Bluetooth (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/c/ title=C>C (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/chatgpt/ title=ChatGPT>ChatGPT (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/container/ title=Container>Container (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/db/ title=DB>DB (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/devops/ title=Devops>Devops (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/diary/ title=Diary>Diary (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/docker/ title=Docker>Docker (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/dynamic/ title=Dynamic>Dynamic (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/economy/ title=Economy>Economy (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/gcd/ title=GCD>GCD (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/gradle/ title=Gradle>Gradle (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/hook/ title=Hook>Hook (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/ios/ title=IOS>IOS (13)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/java/ title=Java>Java (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/javascript/ title=JavaScript>JavaScript (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/kafka/ title=Kafka>Kafka (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/management/ title=Management>Management (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/mariadb/ title=Mariadb>Mariadb (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/multi-tenant/ title=Multi-Tenant>Multi-Tenant (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/mysql/ title=MySQL>MySQL (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/nginx/ title=Nginx>Nginx (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/notification/ title=Notification>Notification (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/plugin/ title=Plugin>Plugin (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/privacy/ title=Privacy>Privacy (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/prompt/ title=Prompt>Prompt (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/python/ title=Python>Python (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/refactor/ title=Refactor>Refactor (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/saas/ title=SAAS>SAAS (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/security/ title=Security>Security (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/terminology/ title=Terminology>Terminology (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/token/ title=Token>Token (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/tool/ title=Tool>Tool (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/web/ title=Web>Web (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/webview/ title=WebView>WebView (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/ title=中间件>中间件 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/ title=源码剖析>源码剖析 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=读书笔记>读书笔记 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%BD%AC%E8%BD%BD/ title=转载>转载 (1)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">社交</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/iCocoa target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg>
<span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:whs543@sina.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg>
<span>whs543@sina.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 Haisheng Wu.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/pfadfinder-konstanz/hugo-dpsg/ rel="nofollow noopener" target=_blank>DPSG</a>主題</span>
<span><a href=/imprint>Imprint and Privacy</a></span></div><div class=footer__copyright>Donate!</div></div></footer><script async defer src=/js/menu.js></script><script src=/js/custom.js></script></body></html>