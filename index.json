[{"categories":null,"content":"职业 Java\u0026iOS developer 工作经历 2018.12 - 2021.7 软件开发工程师 深圳鹏城实验室 网络通信研究中心 ","date":"2021-07-03","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":["diary"],"content":"将博客生成器从原来的 Hexo 换成了 Hugo。 特别感谢闫博推荐 Hugo 这个静态网站生成器并提供 技术支持！ ","date":"2021-07-03","objectID":"/hugo_newbie/:0:0","tags":["diary"],"title":"博客搬新家了！！！","uri":"/hugo_newbie/"},{"categories":["Java"],"content":"介绍 Lombok 是提升 Java 编码效率常用的工具，借助它开发人员可以使用注解来自动生成一些模版代码。比如 getter、setter、equals、toString 等方法。 ","date":"2020-04-30","objectID":"/lombok/:1:0","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["Java"],"content":"安装 ","date":"2020-04-30","objectID":"/lombok/:2:0","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["Java"],"content":"在 maven 中添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.4\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e ","date":"2020-04-30","objectID":"/lombok/:2:1","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["Java"],"content":"在编辑器中添加插件 如：Intellij Idea，在 setting 的 plugin 里搜索lombok plugin，安装插件 ","date":"2020-04-30","objectID":"/lombok/:2:2","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["Java"],"content":"使用 常用的几个注解 @Data ：注在类上，自动生成类的 get、set、equals、hashCode、canEqual、toString 方法 @AllArgsConstructor ：注在类上，自动生成类的全参构造方法 @NoArgsConstructor ：注在类上，自动生成类的无参构造 @Setter ：注在属性上，自动生成 set 方法 @Getter ：注在属性上，自动生成 get 方法 @EqualsAndHashCode ：注在类上，自动生成对应的 equals 和 hashCode 方法 @Log4j/@Slf4j ：注在类上，自动生成对应的 Logger 对象，变量名为 log @Cleanup(“close”)：注在本地变量上，自动释放资源（如：关闭 InputStream） @Synchronized：注在方法上，自动生成一个私有锁变量 @SneakyThrows：自动生成异常处理语句 注意继承关系中使用 Lombok @EqualsAndHashCode 与 @ToString 注解默认情况下忽略父类的成员变量。譬如打印时 toString 返回的结果中缺少父类的成员变量，解决办法是在注解中设置 callSuper 属性为 true， @ToString(callSuper = true) 、@EqualsAndHashCode(callsuper = true)。 ","date":"2020-04-30","objectID":"/lombok/:3:0","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["Java"],"content":"实现原理 jdk 6 中提出并通过了 JSR-269 提案，该提案设计了一组被称为“插入式注解处理器”的标准 API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程（jdk 6 之前，注解只会在运行期发挥作用）。插入式注解处理器工作时，允许读取、修改、添加抽象语法树中的任意元素。如果在处理注解期间修改了语法树，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。Lombok 正是依赖插入式注解处理器来实现的，通过修改注解所在类的语法树来增加节点，引发编译器重新处理，完成修改。 ","date":"2020-04-30","objectID":"/lombok/:4:0","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["Java"],"content":"总结 通过使用 Lombok 可以让代码更简洁，减少了修改属性所需的维护工作量，提升了开发效率，但却降低了可读性和完整性。笔者觉得可以放心在项目使用 Lombok，因为当你后悔作出这个决策时，使用 delombok 这个工具可以帮你还原。 参考： lombok bealdumg introduction to lombok 《深入理解 Java 虚拟机》 ","date":"2020-04-30","objectID":"/lombok/:5:0","tags":["Java","Tool","Plugin"],"title":"Lombok","uri":"/lombok/"},{"categories":["iOS"],"content":"WebViewJavascriptBridge 是一个可以让 OC 与 JS 进行交互通信的第三方开源库。相比其他热门的第三方库，WebViewJavascriptBridge 代码量比较少，并且设计优雅巧妙，可以说是 “小而美”。 WebViewJavascriptBridge 库在 OC 端和 JS 端都有对等的逻辑实现，事先注册 handler，内部维护一个消息队列。透明的 iframe HTML 元素和 webview 的 stringByEvaluatingJavaScriptFromString 是通信的关键。OC 端发消息给 JS 端比较直观，调起 stringByEvaluatingJavaScriptFromString 执行脚本传入消息即可。JS 端发消息给 OC 端，需要事先把消息存到队列中，然后借助 iframe 发起一个伪请求，伪请求会被 webview 的代理方法拦截下来，OC 端因此得知 JS 端消息队列中有消息，最后调起 stringByEvaluatingJavaScriptFromString 方法解析 JS 方法拿到队列中的消息并处理。交互流程见下图： 整个库只有以下几个文件： WebViewJavascriptBridge.h WebViewJavascriptBridge.m WKWebViewJavascriptBridge.h WKWebViewJavascriptBridge.m WebViewJavascriptBridgeBase.h WebViewJavascriptBridgeBase.m WebViewJavascriptBridge_JS.h WebViewJavascriptBridge_JS.m 一般使用只需要关注 WebViewJavascriptBridge 类提供的接口，这个类的主要职责是用来做 Mac 和 iOS webview 的适配（包括 WKWebView，但是这部分代理出去给 WKWebViewJavaScriptBridge 类）并为客户端提供便利的使用接口。WebViewJavascriptBridgeBase 类负责有关数据加工、消息队列管理、消息派发及回调的处理工作。WebViewJavascriptBridge_JS 类包含 JS 端的实现代码，通过宏处理返回 JS 端实现代码的一个 OC 字符串，便于在适当时机将其注入到文档模型中完成 bridge 的初始化。 WebViewJavascriptBridge 类 下面这个方法用来注册 handler，以响应 JS 的调用。handler 会被缓存到 _base 的 map 中，以供后续调用。 - (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler; 下面这个方法用来调用 JS 对应的方法，responseCallback 会被缓存到 _base 的 map 中，以供后续调用。 - (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback; 对 iframe 所发出的伪请求的拦截在此代理方法中进行 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { if (webView != _webView) { return YES; } NSURL *url = [request URL]; __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate; if ([_base isWebViewJavascriptBridgeURL:url]) { if ([_base isBridgeLoadedURL:url]) { [_base injectJavascriptFile]; } else if ([_base isQueueMessageURL:url]) { NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]]; [_base flushMessageQueue:messageQueueString]; } else { [_base logUnkownMessage:url]; } return NO; } else if (strongDelegate \u0026\u0026 [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) { return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType]; } else { return YES; } } [_base isBridgeLoadedURL:url] 结果为 true 时表示正在加载 bridge，此时可以注入 JS 端实现代码到文档模型中，判断依据为 bridge_loaded 主机名。由 iframe 发起的伪请求 WVJBIframe.src = 'https://__bridge_loaded__'; 触发。 [_base isQueueMessageURL:url] 结果为 true 时表示 JS 消息队列中有消息需要处理，判断依据为 wvjb_queue_message 主机名。由 iframe 发起的伪请求 messagingIframe.src = 'https://__wvjb_queue_message__'; 触发。 从这里也可以看出，很多 api 的请求都转发给WebViewJavascriptBridgeBase 类型的实例变量 _base。 WebViewJavascriptBridgeBase 类 WebViewJavascriptBridgeBase 类中维护一个 handler map 和一个 callback map，用来响应 JS 的调用。内部有一些序列化以及反序列化的私有方法。 OC 端使用下面这个方法往 JS 端发消息。 - (void)_dispatchMessage:(WVJBMessage*)message { NSString *messageJSON = [self _serializeMessage:message pretty:NO]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\"\\\\\" withString:@\"\\\\\\\\\"]; ... NSString* javascriptCommand = [NSString stringWithFormat:@\"WebViewJavascriptBridge._handleMessageFromObjC('%@');\", messageJSON]; if ([[NSThread currentThread] isMainThread]) { [self _evaluateJavascript:javascriptCommand]; } else { dispatch_sync(dispatch_get_main_queue(), ^{ [self _evaluateJavascript:javascriptCommand]; }); } } 消息的结构为： { \"data\" : data, \"callbackId\" : objc_cb_xxx, //xxx 为数字，JS 端的 callbackId 会拼接上时间 \"handlerName\" : handlerName, \"responseId\" : objc_cb_xxx } 在拦截中获知正在加载 bridge 后，下面这个方法把 JS 代码注入到文档模型中，初始化 bridge。在网页没加载之前，也就是 bridge 没建立之前，可能 OC 端会发送消息，这些消息需要缓存在 startupMessageQueue 中，在建立 bridge 之后，这个 queue 就没用了。 - (void)injectJavascriptFile { NSString *js = WebViewJavascriptBridge_js(); [self _evaluateJavascript:js]; if (self.startupMessageQueue) { NSArray* queue = self.startupMessageQueue; self.startupMessageQueue = nil; for (id queuedMessage in queue) { [self _dispatchMessage:queuedMessage]; } ","date":"2018-12-20","objectID":"/ios-wvjb-sc-analyse/:0:0","tags":["iOS","源码剖析"],"title":"WebViewJavascriptBridge 源码剖析","uri":"/ios-wvjb-sc-analyse/"},{"categories":["iOS"],"content":"在 iOS 开发中，一般打发布包都是在本地打包，也就是工程师在自己开发电脑上使用 Xcode 编译并导出安装包来进行发布，为了提高效率可能会制作一些自动化打包脚本。本文聊的是远程打包的内容，通过资源拷贝及参数替换然后编译完成打包。 由于 HTML5 跨平台的特点，很多技术团队考虑到代码复用，在部分模块中会采用 h5 来描述界面。甚至有些不需要太复杂交互的 app，全部界面采用 h5 来编写，也就是一个 web 工程。对于大部分现有的 web 工程，能打包成 app 就已经满足了业务诉求。DCloud 团队开发的 HBuilder（IDE）工具中提供了云打包的功能，用起来很方便，简单的说，就是把 web 工程上传到云打包服务器，最后打包生成 app，点击下载即可安装使用。 虽然云打包服务很方便，但上传源码总感觉不太妥当，总有些秘密不想让别人看见，并且其他同事也有打包的需求，但不一定会使用 HBuilder。因此，搭建一个自己的打包服务很有必要。 按照 HBuilder 提供的云打包功能，先定一个初步的需求： 支持修改应用 id、版本号 、icon、启动图 支持导入签名文件 开工！！！ ","date":"2018-07-23","objectID":"/ios-remote-pack/:0:0","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"准备工作 首先，需要一台安装了 MacOS 的电脑（当做服务器使用）。 笔者手头上刚好有台闲置的电脑就拿来当服务器使用了，装了 WMWare，然后装了 MacOS 虚拟机（问题较多，不建议使用虚拟机）。 物理机 windows7，内存 4G；虚拟机 MacOS，内存 3G。 其次，在服务器上部署一个 web 服务，提供打包交互界面方便客户端上传资源文件及下载安装包。我们的界面只提供了一个 www zip 包的上传入口，所有应用资源及打包相关的配置文件都在里面。www 目录结构如下： ","date":"2018-07-23","objectID":"/ios-remote-pack/:1:0","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"appConfig.json 文件内容 { \"id\":\"com.domain.pack\", \"appName\":\"我的应用\", \"debug\":true, \"launchPath\": \"index.html\", \"version\": { \"name\": \"1.0.0\", \"code\": \"100\" }, ... } launchPath 对应 web 应用入口文件，iOS 工程使用这个文件路径作为 webview 的加载入口。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:1:1","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"secret.json 文件内容 { \"ios\" : { \"p12Password\" : \"123456\" }, \"android\" : { \"keyAlias\" : \"keyAlias\", \"keyPassword\" : \"123456\", \"storePassword\" : \"123456\", \"amapApiKey\" : \"\", \"jpushApiKey\" : \"\", ... } } 除了交互界面外，打包服务还需要提供调起 Python 脚本的功能。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:1:2","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"Python 打包脚本 基本所有的功能都使用脚本实现，使用 Python 编写打包脚本是因为 Python 用起来方便，刚开始打算用 Shell 来编写，执行效果可能好一些，但是对这个不熟，只好将就用 Python。我们的 web 服务采用 Java 编写，Java 是可以调用 Python 脚本的 ProcessBuilder pb = new ProcessBuilder(command.split(\" \")); 。打包脚本事先准备好，放在 web 服务站点根目录下，在解压完 www zip 包之后，把脚本拷贝到与 www 目录同级目录中，然后执行脚本打包。打包脚本主要做以下几件事情： 下载 iOS 工程代码到指定目录 将客户端上传的 www 文件资源拷贝到 iOS 工程目录，应用图标、启动图等 修改 iOS 工程配置 导入证书到系统钥匙串 导入 mobileprovision 文件 编译工程 导出 ipa 安装包 打包脚本和客户端上传的 www 文件夹需要放在同一目录下。 实现难度不是很大，但是细节很多，需要反复实践尝试。脚本全部内容见文章末尾。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:0","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"下载 iOS 工程代码到指定目录 svnChekoutCmd = 'svn co --username=%s --password=%s %s %s' %(SVN_USERNAME, SVN_PASSWORD, SVN_URL, checkoutPath()) p = subprocess.Popen(svnChekoutCmd, shell=True, stderr=subprocess.PIPE) p.wait() 从 svn 仓库拉取 iOS 工程代码，使用 svn checkout 命令把代码拷贝到指定目录，后面会使用这个目录下的工程进行编译。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:1","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"将客户端上传的 www 文件资源拷贝到 iOS 工程目录 sourceWWWDir = currentDir() + '/www' projectWWWDir = '/packProject/www' destinationWWWDir = checkoutPath() + projectWWWDir copyFiles(sourceWWWDir, destinationWWWDir) for file in os.listdir(destinationWWWDir): if file.startswith('secret.json') or file.endswith('.mobileprovision') or file.endswith('.p12'): os.remove(destinationWWWDir + '/' + file) 将客户端上传的 www 文件夹拷贝到 iOS 工程中的 www 目录下。 iconAssetDirectory = checkoutPath() + '/packProject/Assets.xcassets/AppIcon.appiconset' iconSrcDirectory = projectWWWDir + '/Icons/ios' items = os.listdir(iconSrcDirectory) for filename in items: copyFile(iconSrcDirectory + '/' + filename, iconAssetDirectory + '/' + filename) clearDir(iconSrcDirectory) 将 www/Icons/ios 文件夹中的各种尺寸的应用图标拷贝到 Assets.xcassets/AppIcon.appiconset 目录中。这个需要事先编写好 AppIcon.appiconset 中的 Contents.json 文件，为每种尺寸的 icon 指定文件名，这里的文件名与 Icons/ios 目录下的图片文件名一一对应，所以，Icons/ios 中的图片名称是固定不变的。Contents.json 文件部分内容： { \"images\" : [ { \"idiom\" : \"iphone\", \"size\" : \"20x20\", \"filename\" : \"40x40.png\", \"scale\" : \"2x\" }, { \"idiom\" : \"iphone\", \"size\" : \"20x20\", \"filename\" : \"60x60.png\", \"scale\" : \"3x\" }, { \"idiom\" : \"iphone\", \"size\" : \"29x29\", \"filename\" : \"58x58.png\", \"scale\" : \"2x\" }, { \"idiom\" : \"iphone\", \"size\" : \"29x29\", \"filename\" : \"87x87.png\", \"scale\" : \"3x\" }, { \"idiom\" : \"iphone\", \"size\" : \"40x40\", \"filename\" : \"80x80.png\", \"scale\" : \"2x\" }, } 启动图资源的拷贝跟应用图标的拷贝一样，需要事先编写好 Contents.json 文件，并且启动图的名称也是固定的。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:2","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"修改 iOS 工程配置 需要根据客户端上传的配置文件 appConfig.json 来修改工程配置。 首先，读取配置文件的内容，包括应用 id 、名称、版本号、编译号、应用入口等。Python 读取 json 文件字符串类型的值默认会转为 unicode 编码表示，需要进行处理，笔者专门写了一个 json_load_byteified 函数来处理这个问题。 其次，使用从配置文件中获取到的内容来修改 info.plist 文件。这里需要使用 MacOS 系统自带的工具 PlistBuddy 来辅助修改。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:3","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"导入证书到系统钥匙串 p12FilePath = findFileInDirectory('.p12', sourceWWWDir) unlockKeychainCmd = 'security unlock-keychain -p %s' %MacOS_ADMIN_PASSWORD p = subprocess.Popen(unlockKeychainCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) p.wait() if p.returncode != 0: print p.stderr.read() return importCertCmd = 'security import %s -P %s -T /usr/bin/codesign' % (p12FilePath, p12Password) p = subprocess.Popen(importCertCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) p.wait() if p.returncode != 0: print p.stderr.read() 使用系统 security 工具将 p12 文件导入到系统钥匙串中，先打开系统钥匙串并提供系统管理员密码，然后再导入。 证书和私钥需要客户端事先准备好，并导出为 p12 文件一并放入 www 文件夹中上传（如何导出 p12 文件请自行查看官方文档）。p12 文件的密码规定写在 secret.json 文件中。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:4","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"导入 mobileprovision 文件 provisionFileExtension = '.mobileprovision' provisionFilePath = findFileInDirectory(provisionFileExtension, sourceWWWDir) if not len(provisionFilePath) \u003e 0: print (\"[packageFailed]: Not found \\'%s\\' file in \\'www\\' directory.\") %(provisionFileExtension) return teamIdentifier = getMobileProvisionItem(provisionFilePath, 'TeamIdentifier') provisionUUID = getMobileProvisionItem(provisionFilePath, 'UUID') provisionName = getMobileProvisionItem(provisionFilePath, 'Name') # type – prints mobileprovision profile type (debug, ad-hoc, enterprise, appstore) provisionType = getMobileProvisionItem(provisionFilePath, 'type') teamName = getMobileProvisionItem(provisionFilePath, 'TeamName') desProvisionFilePath = PROVISONING_PROFILE_DIRECTORY + provisionUUID + provisionFileExtension copyFile(provisionFilePath, desProvisionFilePath) 读取 .mobileprovision 文件的信息，并将 uuid 作为它的文件名保存到 /Users/%s/Library/MobileDevice/Provisioning Profiles/ 目录，完成导入。如果先前已经导入过该类文件（一般双击文件导入），打开这个目录可以看到，文件名都是 uuid。这里，除了 uuid 之外，还可以读取团队 id、名称以及文件类型（debug, ad-hoc, enterprise, appstore）等信息。 为了方便读取 .mobileprovision 文件信息，这里使用一个第三方命令行小工具。安装命令如下： curl https://raw.githubusercontent.com/0xc010d/mobileprovision-read/master/main.m | clang -framework Foundation -framework Security -o /usr/local/bin/mobileprovision-read -x objective-c - 安装命令会使用 curl 工具下载源码，然后使用 clang 编译并将可执行文件输出到 /usr/local/bin/ 目录，命名为 mobileprovision-read，用法： mobileprovision-read -f fileName [-o option] 该工具实现比较简单，使用 security 库解析 mobileprovision 文件，然后根据命令行输入的 option 选择输出结果，因为笔者没有对源码进行修改，所以需要对输出结果中的控制字符 \\n 进行处理（removeControlChars 函数的作用）。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:5","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"编译工程 编译源码。以前在苹果线上开发者文档可以查看 xcodebuild 用法，不知道什么时候删掉了，现在只能使用 man xcodebuild 查看 xcodebuild 用法，这个不多说。需要注意的是，刚才只是导入了 .mobileprovision 文件，工程配置并没有修改，所以没有关联起来。在 project.pbxproj 文件中有以下几个字段需要进行替换，替换完之后才算完成整个工程编译变量的配置。 PRODUCT_BUNDLE_IDENTIFIER PROVISIONING_PROFILE_SPECIFIER PROVISIONING_PROFILE 可以在命令行传入这几个编译变量完成替换，命令行中传入的编译变量优先级最高。 project.pbxproj 不是常见的文件格式，在不知道 xcodebuild 可以注入编译变量之前，找了一圈发现没有方便的工具可以用来编辑。有人建议先转成 json 然后再使用 json 编辑工具进行修改。笔者没有采纳，笔者想到用 sed，但 sed 只对简单的文本内容有效，这种嵌套层级太多的内容貌似匹配不了，所以，无法进行修改。awk 应该可以，但这个我没有尝试。 ","date":"2018-07-23","objectID":"/ios-remote-pack/:2:6","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["iOS"],"content":"导出 ipa 安装包 创建 exportOptions.plist 文件并导出 .ipa 安装包。把生成的 .ipa 文件路径输出给 java 进程，java 进程将结果显示在界面上，方便客户端进行下载。 注意： Python 脚本没有执行权限，需要使用 Chmod 命令添加执行权限。 脚本全部内容如下（详见 github 源码）： #!/usr/bin/env python # _*_ coding:utf-8 _*_ import subprocess import os import json import re SVN_USERNAME = 'Hansen' SVN_PASSWORD = '123456' SVN_URL = 'https://Hansen@svn.domain.com/svn/****/trunk/iOS/packProject' CHECKOUT_FOLDER = 'ios_source_code' MacOS_ADMIN_USER = 'packrobot' MacOS_ADMIN_PASSWORD = '123456' EXPORT_MAIN_DIRECTORY = \"/Users/%s/Documents/ios_appArchive/\" % MacOS_ADMIN_USER PROVISONING_PROFILE_DIRECTORY = \"/Users/%s/Library/MobileDevice/Provisioning Profiles/\" % MacOS_ADMIN_USER def json_load_byteified(file_handle): return _byteify( json.load(file_handle, object_hook=_byteify), ignore_dicts=True ) def json_loads_byteified(json_text): return _byteify( json.loads(json_text, object_hook=_byteify), ignore_dicts=True ) def _byteify(data, ignore_dicts = False): # if this is a unicode string, return its string representation if isinstance(data, unicode): return data.encode('utf-8') # if this is a list of values, return list of byteified values if isinstance(data, list): return [ _byteify(item, ignore_dicts=True) for item in data ] # if this is a dictionary, return dictionary of byteified keys and values # but only if we haven't already byteified it if isinstance(data, dict) and not ignore_dicts: return { _byteify(key, ignore_dicts=True): _byteify(value, ignore_dicts=True) for key, value in data.iteritems() } # if it's anything else, return it in its original form return data def currentDir(): return os.path.split(os.path.realpath(__file__))[0] def checkoutPath(): return currentDir() + '/' + CHECKOUT_FOLDER def pullSvnSourceCode(): svnChekoutCmd = 'svn co --username=%s --password=%s %s %s' %(SVN_USERNAME, SVN_PASSWORD, SVN_URL, checkoutPath()) p = subprocess.Popen(svnChekoutCmd, shell=True, stderr=subprocess.PIPE) p.wait() if p.returncode != 0: print ('[packageFailed]: %s') %p.stderr.read() else: print ('Sucessfullly checkout source code at path: %s') %(checkoutPath()) def clearDir(Dir): cleanCmd = \"rm -r %s\" %(Dir) process = subprocess.Popen(cleanCmd, shell=True) (stdoutdata, stderrdata) = process.communicate() def getAppConfig(): projectWWWDir = 'packProject/www' destinationWWWDir = currentDir() + '/' + CHECKOUT_FOLDER + '/' + projectWWWDir; appConfigFilePath = destinationWWWDir + '/appConfig.json' if os.path.exists(appConfigFilePath): appConfigReader = open(appConfigFilePath, 'r') appConfig = json_load_byteified(appConfigReader) appConfigReader.close() return appConfig return None def copyFiles(sourceDir, destinationDir): if not os.path.exists(sourceDir): print ('[packageFailed]: Copy file -- sourceDir doesn\\'t exist ') pass clearDir(destinationDir) for file in os.listdir(sourceDir): sourceFile = os.path.join(sourceDir, file) destinationFile = os.path.join(destinationDir, file) if os.path.isfile(sourceFile): if not os.path.exists(destinationDir): os.makedirs(destinationDir) if not os.path.exists(destinationFile) or (os.path.exists(destinationFile) and (os.path.getsize(destinationFile) != os.path.getsize(sourceFile))): open(destinationFile, \"wb\").write(open(sourceFile, \"rb\").read()) if os.path.isdir(sourceFile): copyFiles(sourceFile, destinationFile) print ('Copy assets success!') def copyFile(srcFile, dstFile): srcReader = open(srcFile, \"rb\") desWriter = open(dstFile, \"wb\") desWriter.write(srcReader.read()) srcReader.close() desWriter.close() def cleanArchiveFile(archiveFile): cleanCmd = \"rm -r %s\" %(archiveFile) process = subprocess.Popen(cleanCmd, shell=True) (stdoutdata, stderrdata) = process.communicate() def buildExportDirectory(): dateCmd = 'date \"+%Y-%m-%d_%H-%M-%S\"' process = subprocess.Popen(dateCmd, stdout=subprocess.PIPE, shell=True) (stdoutdata, stderrdata) = process.communicate() exportDirectory = \"%s%s\" %(EXPORT_MAIN_DIRECTORY, stdoutdata.strip()) return exportDirectory def getMobileProvisionItem(filepath, key): cmd = 'mobileprovision","date":"2018-07-23","objectID":"/ios-remote-pack/:2:7","tags":["iOS","Python"],"title":"iOS 远程打包脚本制作","uri":"/ios-remote-pack/"},{"categories":["Android"],"content":"最近为了制作 Android 应用打包脚本，学习了一下 gradle。Gradle 构建系统语法简洁、功能强大、配置灵活，笔者只是把它当作一个构建工具来使用，基于它所提供的便利制作可以修改版本号、编译号、id 及导入证书的脚本。 对于一个项目或者一个工程，Gradle 可以定义多个构建任务，debug 和 release 是常见的两个构建任务，用户还可以根据需要自定义自己的构建任务，如测试构建任务和预发布构建任务，甚至是针对不同发布渠道的构建任务。这里只用到 debug 任务。 gradle 命令行支持传入自定义参数，并在编译过程注入这些参数。 ","date":"2018-06-09","objectID":"/android-gradle-build/:0:0","tags":["Gradle","Android"],"title":"Android Gradle 注入编译变量","uri":"/android-gradle-build/"},{"categories":["Android"],"content":"修改 appid 及 版本号 ","date":"2018-06-09","objectID":"/android-gradle-build/:1:0","tags":["Gradle","Android"],"title":"Android Gradle 注入编译变量","uri":"/android-gradle-build/"},{"categories":["Android"],"content":"修改 build.gradle 文件 android { compileSdkVersion 21 buildToolsVersion '26.0.2' defaultConfig { applicationId project.hasProperty('applicationId') ? applicationId : \"com.domain.myApp\" minSdkVersion 14 targetSdkVersion 21 versionCode project.hasProperty('versionCode') ? versionCode.toInteger() : 100 versionName project.hasProperty('versionName') ? versionName : \"1.0.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" } ","date":"2018-06-09","objectID":"/android-gradle-build/:1:1","tags":["Gradle","Android"],"title":"Android Gradle 注入编译变量","uri":"/android-gradle-build/"},{"categories":["Android"],"content":"命令行中传入对应 key 的参数 gradle assembleDebug -PversionCode=\"200\" -PversionName=\"2.0.0\" -PapplicationId=\"com.domain.myApp.debug\" 修改应用 id 的最好同时修改包名，不然会有包名冲突，修改包名需要修改 AndroidManifest.xml 文件，先在 build.gradle 文件中使用 manifestPlaceholders 属性定义一个键： // 获取应用 id def getApplicationId = { -\u003e def appId = project.hasProperty('applicationId') ? applicationId : \"com.domain.myApp\" return appId } manifestPlaceholders = [ PACKAGE_NAME: \"${getApplicationId()}\" ] 然后在 AndroidManifest.xml 文件中以 ${PACKAGE_NAME} 的方式引用，gradle 会在构建过程中把这个值给替换掉。应用名称的修改同理。 ","date":"2018-06-09","objectID":"/android-gradle-build/:1:2","tags":["Gradle","Android"],"title":"Android Gradle 注入编译变量","uri":"/android-gradle-build/"},{"categories":["Android"],"content":"导入 keystore 文件及密码 也可以使用类似上面的方式导入签名文件及密码： signingConfigs { debug { storeFile file('keystores/debug.keystore') } release { keyAlias project.hasProperty('keyAlias') ? keyAlias : 'mykey' keyPassword project.hasProperty('keyPassword') ? keyPassword : '123456' storeFile file(project.hasProperty('storeFilePath') ? storeFilePath : 'keystores/debug.keystore') storePassword project.hasProperty('storePassword') ? storePassword : '123456' } } buildTypes { debug { signingConfig signingConfigs.debug minifyEnabled false } release { signingConfig signingConfigs.release } } } 命令行输入： gradle assembleDebug -PkeyAlias=\"mykey\" -PkeyPassword=\"123456\" -PstoreFilePath=\"Users/hack/Documents/keys/mykey.keystore\" -PstorePassword=\"654321\" 导入 keystore 文件，还可以使用官方提供的其它属性： android.injected.signing.store.file android.injected.signing.store.password android.injected.signing.key.alias android.injected.signing.key.password 然后命令行输入： gradle assembleDebug -Pandroid.injected.signing.store.file=$KEYFILE -Pandroid.injected.signing.store.password=$STORE_PASSWORD -Pandroid.injected.signing.key.alias=$KEY_ALIAS -Pandroid.injected.signing.key.password=$KEY_PASSWORD 参考： Inject build variables into the manifest ","date":"2018-06-09","objectID":"/android-gradle-build/:2:0","tags":["Gradle","Android"],"title":"Android Gradle 注入编译变量","uri":"/android-gradle-build/"},{"categories":["翻译"],"content":"介绍 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:0:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"关于 Core Bluetooth Core Bluetooth 框架提供 iOS 应用和 Mac 应用与设备（配备了蓝牙低能耗无线技术的设备）通信的类。例如，应用可以发现、探测并与低能耗外围设备（比如心率监听器和数字恒温器）交互。从 macOS 10.9 和 iOS 6 开始，Mac 和 iOS 设备还可以当做蓝牙低能耗外设来使用，为其它设备提供数据，包括其他 Mac 和 iOS 设备。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:1:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"一览 蓝牙低能耗无线技术基于蓝牙 4.0 规范，规范中除了别的之外，定义了与低能耗设备通信的一套协议。Core Bluetooth 框架是蓝牙低能耗协议栈的一个抽象，也就是说，它为开发者隐藏了许多规范中的底层细节，让开发者更加容易开发应用（与蓝牙低能耗设备交互的应用）。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:2:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央和外围是 Core Bluetooth 的核心成员 在蓝牙低能耗通信中，有两个核心成员：中央（central）和外围（peripheral）。每个成员扮演不同的角色。外围通常拥有其他设备需要的数据，中央通常使用外围提供的信息来完成一些任务。例如，一个配备了蓝牙低能耗技术的数字恒温器可能为一个 iOS 应用提供房间的温度信息，然后该应用采用用户友好的方式来显示温度。 每个成员在扮演它的角色时都会执行一组不同的任务。外围通过在空中广播持有的数据来让自身的存在被感知，中央设备扫描附近的外围设备（可能包含中央设备感兴趣的数据）。当中央设备发现外围设备，中央设备就请求与外围设备连接并开始探测和交互外围设备的数据。外围设备负责以适当的方式来响应中央设备。 相关章节：Core Bluetooth Overview ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:2:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"Core Bluetooth 简化了一般的蓝牙任务 Core Bluetooth 框架抽离了蓝牙 4.0 规范中的底层细节。因此，应用中需要实现的一般蓝牙低能耗任务被简化了。如果开发实现中央角色的应用，Core Bluetooth 使得发现、连接外围设备和探测、交互外围数据变得简单。另外，Core Bluetooth 还让本地设备实现外围角色变得简单。 相关章节：Performing Commmon Central Role Tasks,Performing Common Peripheral Role Tasks ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:2:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"iOS 应用的状态影响蓝牙的表现 当应用处于后台或挂起状态时，蓝牙相关的特性会受到影响。在这两种状态下，默认是应用无法执行蓝牙低能耗任务。也就是说，如果应用需要在后台执行蓝牙低能耗任务，可以声明支持 Core Bluetooth 后台运行模式中的一个或两个（一个属于中央角色，另一个属于外围角色）。即使在你指定了一个后台运行模式或两个都指定，当应用处于后台时，某些蓝牙任务的执行依然会有所不同，设计应用时，需要考虑到这些差异。 即使应用支持后台处理，应用仍然可能在任意时刻被系统终止以清空内存给当前前台应用使用。在 iOS 7之后，Core Bluetooth 支持保存中央和外围管理者对象的状态信息并在应用启动的时候恢复该状态，可以使用这个特性来支持涉及蓝牙设备的长期活动（long-term actions）。 相关章节：Core Bluetooth Background Processing for iOS Apps ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:2:3","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"遵循最佳实践以增强用户体验 Core Bluetooth 框架使应用可以控制许多常见的蓝牙低能耗事务。遵循最佳实践，以负责任的方式利用这种级别的控制，增强用户体验。 例如，当实现中央和外围角色时所执行的许多任务会使用设备的机载无线电来在空中传播信号。因为设备的无线电与其它形式的无线通信是共享的，并且无线电的使用会给设备的电池寿命带来不利影响，所以，设计应用总当减少使用无线电。 相关章节：Best Practices for Interacting with a Remote Peripheral Device,Best Practices for Setting Up Your Local Device as a Peripheral ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:2:4","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"如何使用这个文档 如果从未用过 Core Bluetooth 框架，或者不熟悉基本的蓝牙低能耗概念，请通读这个文档。在 Core Bluetooth 概述中，你可以学到关键的术语和概念。 在理解了关键的概念之后，请阅读 执行常见中央角色任务 来学习如何开发应用以在本地设备实现中央角色。类似的，学习如何开发应用以在本地设备中实现外围角色，请看 执行常见外围角色任务。 为确保应用运行良好并遵循最佳实践，请阅读后面章节：Core Bluetooth Background Processing for iOS Apps、Best Practices for Interacting with a Remote Peripheral Device 和 Best Practices for Setting Up Your Local Device as a Peripheral ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:3:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"另请参阅 官方 Bluetooth Special Interest Group (SIG) website 提供有关蓝牙低能耗无线技术的权威信息，在那可以找到 蓝牙 4.0 规范。 如果正在设计使用蓝牙低能耗技术与苹果产品通信的硬件配件（包括 Mac、iPhone、iPad 和 iPod touch 模型），请看 Bluetooth Accessory Design Guidelines for Apple Products。如果你的蓝牙配件（使用蓝牙低能耗与 iOS 设备连接的配件）需要存取 iOS 设备产生的通知，请看 Apple Notification Center Service (ANCS) Specification。 Core Bluetooth 概述 Core Bluetooth 框架使得 iOS 和 Mac 的应用可以和蓝牙低能耗设备通信。例如，你的应用可以发现、探测并与低能耗外围设备进行交互，比如心率监听器、数字恒温器甚至是其它 iOS 设备。 该框架是蓝牙 4.0 规范的一个抽象，用于低能耗设备。也就是说，它对开发者隐藏了许多规范中的底层细节，使得开发与蓝牙低能耗设备交互的应用变得简单。因为该框架基于规范，所以一些来自规范的概念和术语被本文采纳。本章介绍了使用 Core Bluetooth 框架开发优秀应用需要知道的关键术语和概念。 重要：iOS 10.0 及之后的应用必须在 Info.plist 文件中包含需要存取的数据类型的使用描述键，否则会崩溃。存取蓝牙外围数据，必须包含 NSBluetoothPeripheralUsageDescription。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:4:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央和外围设备以及它们在蓝牙通信中的角色 在所有的蓝牙低能耗通信中，存在两个主要角色：中央设备和外围设备。基于有点类似传统的 客户端-服务器 结构，外围设备 通常拥有其他设备需要的数据。中央设备 通常使用外围设备提供的信息来完成一些特别的任务。如图 1-1 所示，一个心率监听器可能拥有 Mac 或 iOS 应用所需的有用信息（为了以用户友好的方式来显示用户心率）。 图 1-1 中央和外围设备 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:5:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央设备发现和连接正在广播的外围设备 外围设备以广播数据包的形式来广播数据。广播数据包 是一包相对小的数据，可能包含外围设备必须提供的有用信息，比如外围设备的名称和主要功能。例如，一个数字恒温器可能广播一个房间的当前温度。在蓝牙低能耗中，广播是外围设备让自身存在被感知的主要方式。 另一方面，中央设备可以扫描并监听任何正在广播它所感兴趣的信息的外围设备。如图 1-2 所示，中央设备可以请求连接到它所发现的任何外围设备。 图 1-2 广播和发现 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:5:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"外围设备的数据是如何组织的 连接外围设备的目的是探测和交互数据。然而，在这之前，需要理解外围设备的数据是如何组织的。 外围设备可能包含一个或者多个服务，或者提供有关它们连接信号强度的有用信息。服务（service） 是一批数据以及关联的行为用来实现设备的功能和特征（或者设备的一部分）。例如，心率监听器的一个服务可能是公开来自监听器心率传感器的心率数据。 服务本身由特性或者内部服务（也就是，引用其它服务）组成。特性（characteristic） 提供有关外围服务的更深层次的细节。例如，刚才所说的心率服务可能包含一个描述心率传感器的预期身体位置的特性以及其它传递心率测量数据的特性。图 1-3 演示了心率监听器的服务和特性的一个可能结构。 图 1-3 外围设备的服务和特性 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:5:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央设备探索并与外围设备数据进行交互 在中央设备与外围设备成功建立连接之后，它可以发现外围设备提供的全方位服务和特性（广播数据可能只包含可用服务的一部分）。 通过读或者写服务的特性的值，中央设备可以与外围设备服务交互。例如，应用可能从数字恒温器请求当前的房间温度，或者给恒温器提供一个值用来设置房间温度。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:5:3","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央设备和蓝牙设备的数据是如何表示的 在蓝牙低能耗通信中所涉及到的角色和数据都被以一种简单、直接的方式映射到 Core Bluetooth 框架中。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:6:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央侧的对象 当使用本地中央设备与远程外围设备进行交互时，是在执行蓝牙低能耗通信的中央侧上的活动。除了建立本地外围设备（并用它来响应中央设备的请求）之外，大部分的蓝牙事务都发生在中央侧。 有关如何在应用中实现中央角色的信息，请看 Performing Common Central Role Tasks 和 Best Practices for Interacting with a Remote Peripheral Device。 本地中央设备和远程外围设备 在中央设备侧，本地中央设备由 CBCentralManager 对象表示。这些对象用来管理已发现或者已连接的远程外围设备（由 CBPeripheral 对象表示），包括扫描、发现以及连接到广播外围设备。图 1-4 演示了在 Core Bluetooth 框架中本地中央设备和远程外围设备是如何表示的。 图 1-4 中央设备侧 Core Bluetooth 对象 远程外围设备数据由 CBService 和 CBCharacteristic 对象表示 当与远程外围设备进行数据交互时，是在处理它的服务和特性。在 Core Bluetooth 框架中，远程外围设备的服务由 CBService 对象表示。类似地，远程外围设备的服务的特性由 CBCharacteristic 对象表示。图 1-5 演示了远程外围设备的服务和特性的基本结构。 图 1-5 远程外围设备的服务特性树 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:6:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"外围侧的对象 在 macOS 10.9 和 iOS 6 之后，Mac 和 iOS 设备可以当做蓝牙低能耗外围设备来使用，为其它设备提供数据，包括其他 Mac、iPhone 和 iPad 设备。当设置你的设备以实现外围角色时，是在执行蓝牙低能耗通信外围设备侧的活动。 本地外围设备和远程中央设备 在外围设备侧，本地外围设备由 CBPeripheralManager 对象表示。这些对象用来管理本地外围设备服务和特性数据库内的已发布服务，并向远程中央设备（由 CBCentral 对象表示）广播这些服务。外围设备管理者对象也用来响应来自这些远程中央设备的读写请求。图 1-6 演示了在 Core Bluetooth 框架中如何表示本地外围设备和远程中央设备。 图 1-6 外围设备侧 Core Bluetooth 对象 本地外围设备数据由 CBMutableService 和 CBMutableCharacteristic 对象表示 当建立并与本地外围设备（由 CBPeripheralManager 对象表示）交互数据时，是在处理它的服务和特性的可变版本。在 Core Bluetooth 框架中，本地外围设备的服务由 CBMutableService 对象表示。类似地，本地外围设备的服务的特性由 CBMutableCharacteristic 对象表示。图 1-7 演示了本地外围设备的服务和特性的基本结构。 图 1-7 本地外围设备的服务特性树 有关如何设置本地设备以实现外围角色的信息，请看 Performing Common Peripheral Role Tasks 和 Best Practices for Setting Up Your Local Device as a Peripheral。 执行常见的中央角色任务 实现了蓝牙低能耗通信中央角色的设备执行一些常见的任务，例如，发现和连接可用的外围设备，探测并与外围设备数据进行交互。实现了外围角色的设备也执行一些常见但不同的任务，例如，发布和广播服务并响应来自已连接中央设备的读、写以及订阅请求。 在本章，你将学到如何使用 Core Bluetooth 框架来执行最常见的来自中央设备侧的蓝牙低能耗任务类型。下面的代码例子会帮助你开发应用以在本地设备上实现中央角色。特别地，你将学到如何： 开启一个中央管理者对象 发现并连接到正在广播的外围设备 连接外围设备之后，探索它的数据 给外围设备的服务的特性值发送读写请求 订阅特性值以在值被更新时收到通知 在下一章节，你将学到如何在本地设备开发应用以实现外围角色。 本章的代码例子简单并且抽象，需要适当的修改以合并到真实应用中使用。实现中央角色的更高级的专题（包括小窍门、技巧以及最佳实践），囊括在后面的章节中，Core Bluetooth Background Processing for iOS Apps 和 Best Practices for Interacting with a Remote Peripheral Device 。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:6:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"开启一个中央管理者 因为 CBCentralManager 对象是本地中央设备的 Core Bluetooth 面向对象的表示，在执行任何蓝牙低能耗事务之前需要分配并初始化中央管理者实例，通过调用它的 initWithDelegate:queue:options: 方法来初始化。 myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil]; 在这个例子中，self 被设置为代理以接受中央角色事件。通过指定派发队列为 nil ，中央管理者会使用主队列来派发中央角色事件。 当创建中央管理者时，中央管理者会调用它的代理对象的 centralManagerDidUpdateState: 方法。必须实现这个代理方法以确保中央设备支持蓝牙低能耗并且可用。有关如何实现这个代理方法的信息，请看 CBCentralManagerDelegate Protocol Reference。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:7:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"发现正在广播的外围设备 一旦初始化，中央管理者的第一任务就是发现外围设备。如 Central Discover and Connect to Peripherals That Are Advertising 中提到的，外围设备通过广播使得自身的存在被感知。应用通过调用中央管理者的 scanForPeripheralsWithServices:options: 方法来发现附近正在广播的外围设备。 [myCentralManager scanForPeripheralsWithServices:nil options:nil]; 注意 ：如果第一个参数指定为 nil，中央管理者会返回 所有 发现的外围设备，无视它们支持的服务。在真实的应用中，通常会指定一个包含 CBUUID 对象的数组，每一个都表示外围设备正在广播的服务的全局唯一标识符（UUID）。当指定一个包含服务 UUID 的数组时，中央管理者仅返回广播那些服务的外围设备，以便让你只扫描让你感兴趣的设备。 UUID 以及表示它们的 CBUUID 对象，在 Services and Characteristics Are Identified by UUIDs 中有详细的讨论。 每当中央管理者发现了外围设备，它会调用它的代理对象的 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 方法，最新发现的外围设备会被当成一个 CBPeripheral 对象返回。如果打算连接到已发现的外围设备，那么保留一个对它的强引用以防系统把它回收。下面的例子演示了使用类属性来维持引用已发现的外围设备的场景： - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI { NSLog(@\"Discovered %@\", peripheral.name); self.discoveredPeripheral = peripheral; ... 如果期望连接到多台设备，则使用 NSArray 来保留已发现外围设备。无论如何，一旦找到了感兴趣的所有外围设备，停止扫描其它设备以节省电量。 [myCentralManager stopScan]; ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:8:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"在发现外围设备之后连接它 在发现了正在广播让你感兴趣的服务的外围设备之后，通过调用中央管理者的 connectPeripheral:options: 方法来发起一个连接外围设备的请求，指明想要连接的外围设备： [myCentralManager connectPeripheral:peripheral options:nil]; 如果连接请求成功，中央管理者会调用它的代理对象的 centralManager:didConnectPeripheral: 方法。在开始与外围设备交互之前，设置它的代理以确保代理收到恰当的回调： - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@\"Peripheral connected\"); peripheral.delegate = self; ... ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:9:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"发现所连接的外围设备的服务 在建立了到外围设备的连接之后，可以探索它的数据。探索外围设备提供的数据的第一步是发现它的可用服务。因为外围设备广播的数据数量有大小限制，你也许会发现外围设备的服务比它所广播（在它的广播数据包中）的要多得多。通过调用外围设备的 discoverServices 方法来发现它所提供的服务，像这样： [peripheral discoverServices:nil]; 注意：在一个真实的应用中，通常不会传入 nil 作为参数，因为这么做会返回外围设备上 所有 可用的服务。因为外围设备可能包含很多服务（多于你所感兴趣的服务），发现所有的服务会浪费电量并且浪费时间。相反，你通常指定你所感兴趣的服务的 UUID，如 [Explore a Peripheral’s Data Wisely](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/BestPracticesForInteractingWithARemotePeripheralDevice/BestPracticesForInteractingWithARemotePeripheralDevice.html#//apple_ref/doc/uid/TP40013257-CH6-SW6）中所示。 当指定的服务被找到，外围设备（你所连接的 CBPeripheral 对象）会调用它的代理对象的 peripheral:didDiscoverServices: 方法。Core Bluetooth 创建一个包含 CBService 对象的数组，每一个与外围设备上发现的服务对应。如下所示，你可以实现这个代理方法以访问已发现服务数组： - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { for (CBService *service in peripheral.services) { NSLog(@\"Discovered service %@\", service); ... } ... ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:10:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"发现服务的特性 当找到感兴趣的服务，下一步就是探索外围设备提供的所有服务特性。发现服务所有特性的方法很简单，就是调用外围设备的 discoverCharacteristics:forService: 方法，指定合适的服务，像这样： NSLog(@\"Discovering characteristics for service %@\", interestingService); [peripheral discoverCharacteristics:nil forService:interestingService]; 注意：在一个真实的应用中，通常不会传入 nil 作为参数，因为这么做会返回外围设备服务的所有特性。因为外围设备可能包含更多比你感兴趣的特性，发现所有的特性浪费电量并且浪费时间。相反，通常指定感兴趣的特性的 UUID。 当指定的服务的特性被发现时，外围设备会调用它的代理对象的 peripheral:didDiscoverCharacteristicsForService:error: 方法。Core Bluetooth 会创建一个包含 CBCharacteristic 对象的数组，每一个都与已发现的特性对应。下面的例子演示了如何实现这个代理方法： - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error { for (CBCharacteristic *characteristic in service.characteristics) { NSLog(@\"Discovered characteristic %@\", characteristic); ... } ... ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:11:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"取回特性的值 特性包含一个单一值，用来表示有关外围设备服务的信息。例如，一个健康体温计的温度测量特性可能有一个值表示温度（以摄氏度来表示）。可以通过直接读取或订阅的方式来取回特性的值。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:12:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"读取特性的值 在找到感兴趣的服务的特性之后，通过调用外围设备的 readValueForCharacteristic: 方法可以读取特性的值，指定合适的特性，像这样： NSLog(@\"Reading value for characteristic %@\", interestingCharacteristic); [peripheral readValueForCharacteristic:interestingCharacteristic]; 当试图读取特性的值的时候，外围设备会调用它的代理对象的 peripheral:didUpdateValueForCharacteristic:error: 方法取回数值，如果成功取回，就可以通过特性的 value 属性来访问，像这样： - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { NSData *data = characteristic.value; // parse the data as needed ... 注意：不是所有的特性都是可读的。可以通过检查它的 properties 属性是否包含 CBCharacteristicPropertyRead 常量来判断特性是否可读。如果尝试读取一个不可读的特性，peripheral:didUpdateValueForCharacteristic:error: 代理方法会返回相配的错误。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:12:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"订阅特性值 对静态值来说，通过使用 readValueForCharacteristic: 方法来读取特性的值可能很高效，但对于动态值来说这种方式可能不是最高效的。通过订阅来获取随时间而改变的特性值，例如，心率。当订阅了特性值，在值改变之后会收到来自外围设备的通知。 通过调用 setNotifyValue:forCharacteristic: 方法来订阅感兴趣的特性值，指定第一个参数为 YES，像这样： [peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 当订阅或取消订阅特性值，外围对象会调用它的代理对象的 peripheral:didUpdateNotificationStateForCharacteristic:error: 方法。如果有任何原因导致订阅请求失败，你可以实现这个代理方法来访问引发错误的原因，如下所示： - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@\"Error changing notification state: %@\", [error localizedDescription]); } ... 注意：并非所有的特性都提供订阅。可以通过检查它的 properties 属性是否包含 CBCharacteristicPropertyNotify 或者 CBCharacteristicPropertyIndicate 常量来判断特性是否支持订阅。 在成功订阅特性值之后，外围设备会在值发生改变时通知应用。每一次值变化，外围对象会调用它的代理对象的 peripheral:didUpdateValueForCharacteristic:error: 方法。为了获取已更新的值，可以按照上面 Reading the Value of a Characteristic 所说的同样的方式来实现这个方法。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:12:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"写特性值 有时写特性值很有意义。例如，如果应用与蓝牙低能耗数字恒温器进行交互，你可能想要给恒温器提供一个值，用来设置房间的温度。如果一个特性值是可写的，可以通过调用外围设备的 writeValue:forCharacteristic:type: 方法使用一个 NSData 对象来写入值，像这样： NSLog(@\"Writing value for characteristic %@\", interestingCharacteristic); [peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic type:CBCharacteristicWriteWithResponse]; 当写特性值时，指定要执行的写类型。在上面的例子中，写类型为 CBCharacteristicWriteWithResponse，指示外围设备通过调用它的代理对象 peripheral:didWriteValueForCharacteristic:error: 方法来让应用知道是否写成功。实现这个代理方法来处理错误条件，如下所示： - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@\"Error writing characteristic value: %@\", [error localizedDescription]); } ... 相反，如果指定写类型为 CBCharacteristicWriteWithoutResponse，写请求会以 尽力而为 的方式来执行，并且传递没有保证也没有反馈，外围设备不会调用任何代理方法。有关 Core Bluetooth 框架中支持的写类型信息，请看 CBPeripheral Class Reference 中的枚举 CBCharacteristicWriteType。 注意：特性可能仅支持某些写类型或者根本不支持。通过检查 properties 属性是否包含 CBCharacteristicPropertyWriteWithoutResponse 或 CBCharacteristicPropertyWrite 常量来判断特性所支持的写类型。 执行常见的外围角色任务 在上一章节中，学习了如何在中央设备侧执行最常见的蓝牙低能耗任务。在本章中，你将学习到如何使用 Core Bluetooth 框架来在外围设备侧执行最常见的蓝牙低能耗任务。下面的代码示例会帮助你开发应用来在本地设备实现外围角色。特别地，你会学到： 开启外围管理者对象 在本地外围设备上建立服务和特性 发布服务和特性到设备本地数据库 广播服务 响应已连接的中央设备的读写请求 发送更新特性值到已订阅的中央设备 本章的代码例子简单并且抽象，需要适当的修改以合并到真实应用中使用。在本地设备上实现外围角色的更高级的专题（包括小窍门、技巧以及最佳实践），囊括在后面的章节中，Core Bluetooth Background Processing for iOS Apps 和 Best Practices for Setting Up Your Local Device as a Peripheral。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:13:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"开启外围管理者 在本地设备上实现外围角色的第一步是分配并初始化一个外围管理者实例（由 CBPeripheralManager 对象表示）。通过调用 CBPeripheralManager 类的 initWithDelegate:queue:options: 方法来开启外围管理者，像这样： myPeripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil]; 在这个例子中，self 被设置成代理以接收任何与外围角色相关的事件。当指定派发队列为 nil 时，外围管理者会使用主队列来派发外围角色事件。 当创建外围管理者时，外围管理者会调用它代理对象的 peripheralManagerDidUpdateState: 方法。你必须实现这个代理方法来确保本地外围设备支持蓝牙低能耗并且可用。有关如何实现这个代理方法的信息，请看 CBPeripheralManagerDelegate Protocol Reference。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:14:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"建立服务和特性 如图 1-7 所示，本地外围设备的服务和特性数据库按照树枝状的方式来组织。必须以树枝状的方式来组织以在本地外围设备上建立服务和特性。执行这些任务的第一步是理解服务和特性是如何被识别的。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:15:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"服务和特性由 UUID 识别 外围设备的服务和特性由 128 bit 的蓝牙特有 UUID 识别，在 Core Bluetooth 框架中由 CBUUID 对象表示。并非所有的 UUID 都由蓝牙技术联盟（SIG）事先定义，蓝牙技术联盟定义并公布了一组常用的 UUID，并且，为了方便缩短到 16 bit。例如，蓝牙技术联盟预定义了标识心率服务的 16 bit 的 UUID “180D”。这个 UUID 缩短自它的等价 128 bit UUID “0000180D-0000-1000-8000-00805F9B34FB”，这是基于蓝牙 4.0 规范中定义的蓝牙基础 UUID，卷 3 ，F 部分，3.2.1 节。 CBUUID 类提供工厂方法使得开发应用时更容易处理过长的 UUID。例如，不是在代码中传递心率服务的 128 bit UUID 字符串表示，而是简单地使用 UUIDWithString 方法来用服务事先定义的 16 bit UUID 创建 CBUUID 对象，像这样： CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString: @\"180D\"]; 当用事先定义的 16 bit UUID 创建 CBUUID 对象时，Core Bluetooth 使用蓝牙基础 UUID 预填充 128 bit UUID 剩下的位。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:15:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"为自定义服务和特性创建 UUID 可能会有预定义蓝牙 UUID 无法识别的服务和特性，如果这样，需要生成自己的 128 bit UUID 来识别它。 使用命令行工具 uuidgen 来轻松地生成 128 bit 的 UUID。打开终端窗口，然后为需要使用 UUID 识别的每个服务和特性，在命令行中输入 uuidgen 以接收唯一的 128 bit 值（以 ASCII 字符串的形式，使用 - 号连接），如下所示： $ uuidgen 71DA3FD1-7E10-41C1-B16F-4430B506CDE7 然后就可以使用这个 UUID 来创建一个 CBUUID 对象，使用 UUIDWithString 方法，像这样： CBUUID *myCustomServiceUUID = [CBUUID UUIDWithString:@\"71DA3FD1-7E10-41C1-B16F-4430B506CDE7\"]; ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:15:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"构建服务特性树 在拿到服务和特性的 UUID 后，就可以创建可变的服务和特性并按照上面说的树枝状的形式来组织它们。例如，如果拿到了一个特性的 UUID，可以通过调用 CBMutableCharacteristic 类的 initWithType:properties:value:permissions: 方法来创建一个可变的特性。 myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead value:myValue permissions:CBAttributePermissionsReadable]; 当创建可变特性时，设置它的属性、值以及权限。设置的属性和权限决定了特性的值是否可读写以及一个已连接的中央设备是否可以订阅。这个例子中，特性的值设置为中央设备可读。有关可变特性的属性和权限支持的范围，请看 CBMutableCharacteristic Class Reference。 注意：如果为特性指定一个值，该值会被缓存并且它的属性和权限被设置为可读的。因此，如果想让特性的值可写，或者期望在特性所属的已发布服务的生命期内改变特性值，那么必须该值为 nil。遵循这个方式确保该值被动态地对待，并且外围管理者会在收到已连接中央设备的读写请求时请求该值。 由于已经创建了可变特性，接下来就可以创建一个可变服务与之关联。调用 CBMutableService 类的 initWithType:primary: 方法，就像这样： myService = [[CBMutableService alloc] initWithType:myServiceUUID primary:YES]; 在这个例子中，第二个参数设置为 YES，表明服务是主要的（与次要相对）。主服务 描述设备的主要功能并且可以被其他服务包含（引用）。次服务 描述仅仅在引用它的服务的上下文中有意义的服务。例如，一个心率主服务可能要公开来自监听器的心率传感器的心率数据，而次服务可能要公开传感器的电池数据。 在创建服务之后，可以为它关联特性，通过设置服务的特性数组，像这样： myService.characteristics = @[myCharacteristic]; ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:15:3","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"发布服务和特性 在构建了服务特性树之后，下一步就是把它们发布到设备的服务和特性数据库。使用 Core Bluetooth 框架，执行这个任务很简单。调用 CBPeripheralManager 类的 addService: 方法，像这样： [myPeripheralManager addService:myService]; 当调用这个方法来发布服务时，外围管理者会调用它的代理对象的 peripheralManager:didAddService:error: 方法。如果错误发生导致服务发布失败，实现这个代理方法来访问导致错误发生的原因，如下所示： - (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error { if (error) { NSLog(@\"Error publishing service: %@\", [error localizedDescription]); } ... 注意：在发布服务以及与之关联的特性到外围设备的数据库之后，服务会被缓存而且再也不能修改它。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:16:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"广播服务 当已发布服务和特性到设备的服务特性数据库时，就准备向中央设备（可能正在监听）开始广播它们中的一部分。如下所示，通过调用 CBPeripheralManager 类的 startAdvertising: 方法来广播服务，传入一个包含广播数据的 NSDictionary 实例： [myPeripheralManager startAdvertising:@{ CBAdvertisementDataServiceUUIDsKey : @[myFirstService.UUID, mySecondService.UUID] }]; 在这个例子中，字典中的仅有的键 CBAdvertisementDataServiceUUIDsKey，期望的值为一个数组( NSArray 的一个实例)，这个数组包含想要广播的服务的 UUID（CBUUID 对象）。广播数据的字典中可能指定的键详见 CBCentralManagerDelegate Protocol Reference 中的 Advertisement Data Retrieval Keys 所描述的常量。也就是说，外围管理者对象仅支持两个键 CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey。 当开始广播本地外围设备的数据时，外围管理者会调用它的代理对象的 peripheralManagerDidStartAdvertising:error: 方法。如果错误发生导致广播服务失败，实现这个代理方法来访问导致错误发生的原因，像这样： - (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error { if (error) { NSLog(@\"Error advertising: %@\", [error localizedDescription]); } ... 注意：数据广播是按照 “尽力而为” 的基本原则来做的，因为空间受限并且可能有多个应用同时在广播。更多信息，请看 CBPeripheralManager Class Reference 中的 startAdvertising: 方法的讨论。 当应用处于后台时，广播的行为也会受到影响。这个专题会在下一章 Core Bluetooth Background Processing for iOS Apps 讨论。 一旦开始广播数据，远程中央设备就可以发现并发起连接了。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:17:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"响应来自中央设备的读写请求 在连接远程中央设备之后，开始处理来自它们的读写请求。当处理请求时，确保以恰当的方式来响应这些请求。下面的例子描述了如何处理这样的请求。 当已连接的中央设备请求读取特性值时，外围管理者会调用它的代理对象的 peripheralManager:didReceiveReadReques: 方法，这个代理方法会以 CBATTRequest 对象（包含一组可以用来完成请求的属性）的形式传递请求。 例如，当接收到一个简单的读取特性值的请求时，从代理方法中接收到的 CBATTRequest 对象的属性可以用来确保设备数据库中的特性与远程中央设备在原始读请求中所指定的那个相匹配。实现这个代理方法，像这样： - (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request { if ([request.characteristic.UUID isEqual:myCharacteristic.UUID]) { ... 如果该特性的 UUID 匹配，下一步就是确保该读请求没有要求读取超出特性值范围的索引位置。如下所示，可以使用 CBATTRequest 对象的 offset 属性来确保读请求没有试图读取超出范围的值： if (request.offset \u003e myCharacteristic.value.length) { [myPeripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset]; return; } 假设请求的偏移量已经验证过，现在设置该请求的特性属性的值（默认值为 nil），设置为本地外围设备创建的特性的值，考虑读请求的偏移量： request.value = [myCharacteristic.value subdataWithRange:NSMakeRange(request.offset, myCharacteristic.value.length - request.offset)]; 在设置了值之后，响应远程中央设备以表明请求成功地完成了。调用 CBPeripheralManager 类的 respondToRequest:withResult: 方法，回传请求（值已经被更新）和请求的结果，像这样： [myPeripheralManager respondToRequest:request withResult:CBATTErrorSuccess]; 每一次 peripheralManager:didReceiveReadRequest: 方法被调用的时候正好调用一次 respondToRequest:withResult: 方法。 注意：如果特性的 UUID 不匹配，或者由于任何其他原因导致读取不能完成，你不用尝试完成该请求。相反，应该立即调用 respondToRequest:withResult: 方法并提供一个表明失败原因的结果。可能指定的结果的清单，请看 Core Bluetooth Constants Reference 中的 CBATTError Constants 枚举。 处理来自中央设备的写请求也很简单。当中央设备发送特性的写请求时，外围管理者会调用它的代理对象的 peripheralManager:didReceiveWriteRequests: 方法。这回，这个代理方法以数组（包含一个或多个 CBATTRequest 对象，每一个代表一个写请求）的形式传递请求。在确定写请求可以满足时，写入特性的值，像这样： myCharacteristic.value = request.value; 虽然上面的来例子没有给出，但是当写入特性值时，要保证考虑到请求的偏移量属性。 就像响应读请求一样，每次 peripheralManager:didReceiveWriteRequests: 代理方法被调用时都正好调用一次 respondToRequest:withResult: 方法。也就是说， respondToRequest:withResult: 方法的第一个参数期望是一个 CBATTRequest 对象，即使从 peripheralManager:didReceiveWriteRequests: 代理方法中接收到一个包含一个或多个请求对象的数组。应该传入数组中的第一个请求，像这样： [myPeripheralManager respondToRequest:[requests objectAtIndex:0] withResult:CBATTErrorSuccess]; 注意：像对待单个请求那样对待多个请求，如果有任何个别请求不能满足，就不该满足任何一个请求。相反，应该立即调用 respondToRequest:withResult: 方法并提供一个表明失败原因的结果。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:18:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"发送更新特性值到已订阅的中央设备 通常，中央设备会订阅特性值中的一个或多个，如 Subscribing to a Characteristic’s Value 中所描述。在它们订阅的特性值发生改变之后，你有责任通知它们。下面的例子会介绍怎么做。 当中央设备订阅特性值时，外围管理者会调用它的代理对象的 peripheralManager:central:didSubscribeToCharacteristic: 方法。 - (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic { NSLog(@\"Central subscribed to characteristic %@\", characteristic); ... 使用上面的代理方法作为线索来开始给中央设备发送更新后的值。 紧接着，获取更新后的特性值并调用 CBPeripheralManager 类的 updateValue:forCharacteristic:onSubscribedCentrals: 方法发送给中央设备。 NSData *updatedValue = // fetch the characteristic's new value BOOL didSendValue = [myPeripheralManager updateValue:updatedValue forCharacteristic:characteristic onSubscribedCentrals:nil]; 当调用这个方法给已订阅的中央设备发送更新后的特性值时，可以给最后一个参数指定想要更新的中央设备。如上面的例子，如果指定为 nil，所有已连接、已订阅的中央设备都会被更新（所有已连接但未订阅的中央设备会被忽略）。 updateValue:forCharacteristic:onSubscribedCentrals: 方法返回一个布尔值表明更新是否成功。如果用来传输更新值的底层队列已满，该方法会返回 NO。当传输队列有可用的空间时，外围管理者会调用它的代理对象的 peripheralManagerIsReadyToUpdateSubscribers: 方法。然后可以实现这个代理方法重发该值，再次使用 updateValue:forCharacteristic:onSubscribedCentrals: 方法。 注意：使用通知发送单一数据包到已订阅中央设备，也就是说，当你更新中央设备时，应该在一个单独的通知中发送全部的更新值，通过调用一次 updateValue:forCharacteristic:onSubscribedCentrals: 方法。 取决于特性值的尺寸，并非所有的数据都通过通知传输。如果发生，这类情形应该在中央设备侧处理，通过调用 CBPeripheral 类的 readValueForCharacteristic: 方法可以取回全部值。 iOS 应用的 Core Bluetooth 后台处理 对 iOS 应用来说，知道应用是运行在前台还是后台是很重要的。因为 iOS 设备上的系统资源更有限，所以应用处于后台时肯定会表现得跟处于前台时不一样。对于 iOS 上的后台操作的讨论，请看 App Programming Guide for iOS 中的 Background Execution。 默认情况下，如果应用处于后台或者挂起状态，许多常见的 Core Bluetooth 任务都不可用（中央设备侧和外围设备侧）。也就是说，可以声明应用支持 Core Bluetooth 后台执行模式以允许应用被唤醒去处理某些蓝牙相关的事件。即使应用不需要全范围的后台处理支持，仍然可以要求系统在重要事件发生时给出警告。 即使应用支持一个 Core Bluetooth 后台执行模式或两个都支持，它也不能一直运行。例如，在某一时刻，系统需要终止应用以释放内存给当前处于前台的应用使用，这会导致连接（活跃或者未完成的连接）丢失。在 iOS 7 之后，Core Bluetooth 支持保存中央和外围管理者对象的状态信息并在应用启动的时候恢复状态。可以使用这个特性来支持蓝牙设备的长期活动。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:19:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"仅前台运行的应用 正如大部分的 iOS 应用，除非你请求执行特定后台任务的权限，否则应用在进入后台很快就转变到挂起状态。当处于挂起状态，应用就不能执行蓝牙相关的任务，也觉察不到蓝牙相关的事件，直到重新开始进入前台。 在中央设备侧，仅前台运行的应用（没有声明支持 Core Bluetooth 后台执行模式的应用）在处于后台或者挂起状态时不能扫描和发现广播外围设备。在外围设备侧，广播被禁用，尝试访问应用已发布服务的动态特性值的中央设备会收到错误。 取决于使用场景，这个默认行为会以许多方式影响你的应用。例如，想象你正在与外围设备交互数据，然后进入到挂起状态（比如，因为用户切换到其他应用）。如果当应用被挂起时到外围设备的连接丢失，你不会觉察到连接断开直到应用再次进入前台。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:20:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"利用外围设备连接选项 当仅支持前台运行的应用处于挂起状态时，所有出现的蓝牙相关的事件都会被系统排列起来并在应用重新进入前台时传递过去。也就是说，当某些中央角色事件发生时，Core Bluetooth 提供一种警告用户的方式。用户可以使用这些警告来决定特定的事件是否需要把应用带回到前台。 当调用 CBCentralManager 类的 connectPeripheral:options 方法连接到远程外围设备时，通过包含以下外围连接选项中的一个，可以利用这些警告： CBConnectPeripheralOptionNotifyOnConnectionKey——如果想让系统在连接成功而应用处于挂起状态时显示警告（对于给定外围设备），包含这个键。 CBConnectPeripheralOptionNotifyOnDisconnectionKey——如果想让系统在连接断开而应用处于挂起状态时显示警告（对于给定外围设备），包含这个键。 CBConnectPeripheralOptionNotifyOnNotificationKey——如果想让系统在收到通知（来自给定外围设备）而应用处于挂起状态时显示警告，包含这个键。 有关蓝牙连接选项的更多信息，详见 CBCentralManager Class Reference 中的 Peripheral Connection Options 常量。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:20:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"Core Bluetooth 后台执行模式 如果应用需要在后台执行某些蓝牙相关的任务，必须在信息属性列表 (Info.plist) 文件中声明支持蓝牙后台执行模式。当声明了这个时，系统会唤醒处于挂起状态的应用并允许它处理蓝牙相关的事件。这个支持对于那些与以规律的时间间隔传递数据的蓝牙低能耗设备进行交互的应用很重要，例如心率监听器。 应用有两个可以声明的 Core Bluetooth 后台执行模式，一个用来实现中央角色，另一个用来实现外围角色。如果应用要实现两个角色，可能会声明支持两种后台执行模式。通过在 Info.plist 文件中添加 UIBackgroundModes 键来声明，然后设置该键的值为一个数组，数组包含以下两个字符串： bluetooth-central——应用使用 Core Bluetooth 框架来与蓝牙低能耗外围设备通信 bluetooth-peripheral——应用使用 Core Bluetooth 框架来共享数据 注意：Xcode 中的属性列表编辑器默认显示人工可读的字符串而不是实际的键名称。要在 Info.plist 文件出现的时候显示实际的键名称，右击编辑器窗口，然后在弹出的对话窗口中选择启用 Show Raw Keys/Values 条目。 关于如何配置 Info.plist 文件的内容，请看 Xcode Help。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:21:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"中央蓝牙后台执行模式 当实现中央角色的应用在 Info.plist 文件中加入 UIBackgroundModes 键（键的值为 bluetooth-central）时，Core Bluetooth 框架允许应用在后台执行某些蓝牙相关的任务。当应用在后台时仍然发现和连接外围设备并且探测和交互数据。另外，当 CBCentralManagerDelegate 或 CBPeripheralDelegate 的代理方法被调用时系统会唤醒应用，允许应用处理重要的中央角色事件（例如，当连接建立和拆除时、当外围设备发送更新特性值时以及当中央管理者状态改变时）。 虽然应用处于后台时可以执行许多蓝牙相关的任务，请记住在应用处于后台时执行扫描外围设备的操作是不同于前台的。特别是当应用处于后台时扫描设备： CBCentralManagerScanOptionAllowDuplicatesKey 扫描选项键被忽略，一个广播外围设备的多次发现会被合并到一个单一的发现事件中 如果所有扫描外围设备的应用都在后台，那么中央设备扫描广播包的时间间隔会增加。结果是，需要花更长的时间来发现广播外围设备。 这些改变帮助减少无线电的使用，提高 iOS 设备的电池寿命。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:21:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"外围蓝牙后台执行模式 要在后台执行某些外围角色任务，必须在应用的 Info.plist 文件中包含 UIBackgroundModes 键，值为 bluetooth-peripheral。当应用的 Info.plist 文件中包含这个键值对，系统会唤醒应用去处理读、写和订阅事件。 当应用处于后台状态时，除了允许应用被唤醒以处理来中央设备的读、写以及订阅请求之外，Core Bluetooth 框架还允许应用发广播。也就是说，你应该意识到在应用处于后台时发广播的操作是不同于前台的。特别是当应用处于后台时发广播： CBAdvertisementDataLocalNameKey 广播键会被忽略，并且外围设备的本地名称不会被广播出去。 CBAdvertisementDataServiceUUIDsKey 广播键的值中包含的所有服务 UUID 会被放入特殊的“溢出”区域，它们只能被显式地扫描它们的 iOS 设备所发现 如果所有发广播的应用都在后台，那么外围设备发送广播包的频率可能会减少。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:21:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"明智地使用后台执行模式 尽管声明应用支持一个或两个 Core Bluetooth 后台执行模式可能很有必要以满足特定的使用场景，但是你应当负责任地执行后台处理。因为执行许多蓝牙相关的任务需要积极的使用 iOS 设备的机载无线电，同时，无线电的使用反过来对 iOS 设备的电池寿命有不利影响。尝试着去减少后台执行的任务数量。被唤醒以处理蓝牙相关的事件的应用应该尽可能快地处理并结束，以便应用可以再次被挂起。 声明支持 Core Bluetooth 后台执行模式的应用必须遵循几个基本原则： 应用应当基于会话并提供界面让用户决定何时开启和关闭蓝牙相关事件的传递 在唤醒到来之际，应用有大约 10 秒钟的时间完成任务。最理想的情况是，应用应该尽可能快地完成任务以使自身再次被挂起。花太多时间在后台执行任务的应用会被系统拦下或者杀掉。 应用不该把唤醒当成执行无关任务（与应用被系统唤醒的原因不相关的）的机会 有关应用在后台应该如何运转的更普遍的信息，请看 App Programming Guide for iOS 中的 Being a Responsible Background App。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:22:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"在后台执行长期活动 有些应用可能需要使用 Core Bluetooth 在后台执行长期活动。例如，设想一下你正在为 iOS 设备开发一款家庭安全应用，设备与门锁（配备蓝牙低能耗技术的门锁）通信，应用通过与锁的交互来自动地锁门（当用户离开家时）和开门（当用户回到家时），所有的操作都是应用处于后台时完成。当用户离开家时，iOS 设备最终可能会超出锁的范围，导致与锁的连接丢失，这时，应用可以通过调用 CBCentralManager 类的 connectionPeripheral:options: 方法，因为连接请求不超时，所以在用户回到家时 iOS 设备会重新进行连接。 现在设想一下用户离家几天，如果应用在离开家时被系统终止掉，应用将不能在用户回到家时重新连接到门锁，然后用户可能无法打开房门。像这样的应用，能够继续使用 Core Bluetooth 来执行长期活动是很重要的，例如监听活跃的和未完成的连接。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:23:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"状态保存和恢复 因为状态保存和恢复内置于 Core Bluetooth，所以应用可以选择加入这个特性来要求系统保存应用的中央和外围管理者的状态并且为应用继续执行某些蓝牙相关的任务，甚至是应用不再运行。当这些任务中的某个已完成，系统会重启应用到后台中并让应用有机会去恢复它的状态并恰当地处理事件。至于上面所说的家庭安全应用，系统会监听连接请求，并再次重启应用来处理 centralManager:didConnectPeripheral: 代理回调（当用户回家并且连接请求已完成）。 Core Bluetooth 为实现了中央角色或外围角色（或者两个都实现）的应用提供状态保存和恢复的支持。当应用实现了中央角色并添加状态保存和恢复的支持，系统会在它要终止应用以释放内存时保存中央管理者的状态（如果应用有多个中央管理者，你可以选择一个让系统进行记录）。特别地，对于一个给定的 CBCentralManager 对象，系统会记录： 中央管理者正在扫描的服务（以及当扫描开始时的扫描选项） 中央管理者试图连接或者已连接的外围设备 中央管理者订阅的特性 实现了外围角色的应用同样可以利用状态保存和恢复。对于 CBPeripheralManager 对象，系统会记录： 外围管理者正在广播的数据 外围管理者发布到设备数据库的服务和特性 订阅了特性值的中央设备 当应用被系统重启进入到后台（比如，发现了应用要扫描的外围设备），你可以重新实例化应用的中央管理者和外围管理者并恢复它们的状态。下面的部分详细描述了如何在应用中利用状态保存和恢复。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:23:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"支持状态保存和恢复 Core Bluetooth 中的状态保存和恢复是一个可以选择加入的特性并且需要应用的帮助才能工作。在应用中为这个特性加入支持，遵循以下流程： （必须的）当分配和初始化中央管理者和外围管理者对象时加入状态保存和恢复。这一步在选择加入状态保存和恢复中有提到。 （必须的）在应用被系统重启后重新实例化中央和外围管理者对象。这一步在 Reinstantiate Your Central and Peripheral Managers 中有提到。 （必须的）实现适当的恢复代理方法。这一步在 Implement the Appropriate Restoration Delegate Method 中有提到。 （可选的）修正中央和外围管理者的初始化流程。这一步在 Update Your Initialization Process 中有提到。 选择加入状态保存和恢复 要加入状态保存和恢复特性，仅需要在分配和初始化中央和外围管理者时提供一个唯一恢复标识符。恢复标识符 是应用和 Core Bluetooth 用来识别中央或者外围管理者的一个字符串。字符串的值只对你的代码有意义，但该字符串的出现告诉 Core Bluetooth 被标记的对象需要保存状态。Core Bluetooth 仅保存包含恢复标识符的对象的状态。 例如，如果要为仅使用一个 CBCentralManager 对象来实现中央角色的应用加入状态保存和恢复，那么，当你分配和初始化中央管理者的时候，就指定 CBCentralManagerOptionRestoreIdentifierKey 初始化选项并为中央管理者提供恢复标识符。 myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:@{ CBCentralManagerOptionRestoreIdentifierKey: @\"myCentralManagerIdentifier\" }]; 虽然上面的例子没有演示这个，但可以用类似的方式来为使用外围管理者的应用加入状态保存和恢复：指定 CBPeripheralManagerOptionRestoreIdentifierKey 初始化选项并在分配和初始化管理者对象时提供恢复标识符。 注意：因为应用可能有多个 CBCentralManager 和 CBPeripheralManager 对象的实例，所以要确保每个恢复标识符都是唯一的，以便系统区分不同的外围或者中央管理者对象。 重新实例化中央和外围管理者 当应用被系统重启进入后台，你需要做的第一件事就是使用相同的标识符（第一次创建时所用的恢复标识符）重新实例化适当的中央和外围管理者。如果应用仅有一个中央或外围管理者，并且该管理者在应用的生命期内一直存在，那么这一步你没有别的要做了。 如果应用包含一个以上的中央或者外围管理者（或者使用一个管理者，该管理者并非在应用生命期内一直存在），那么应用需要知道该实例化哪个管理者（当应用被系统重启时）。当实现应用的 application:didFinishLaunchingWithOptions: 代理方法时，通过使用恰当的启动选项键 UIApplicationLaunchOptionsBluetoothCentralsKey 或 UIApplicationLaunchOptionsBluetoothPeripheralsKey， 你可以访问管理者对象的恢复标识符列表（系统在应用终止时保存下来的）。 例如，当应用被系统重启，你可以获取系统为应用保存的所有中央管理者对象的恢复标识符，像这样： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { NSArray *centralManagerIdentifiers = launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey]; ... 在拿到恢复标识符列表后，仅仅需要遍历并重新实例化合适的中央管理者对象。 注意：当应用被重启，系统仅仅为执行蓝牙相关任务的中央和外围管理者提供恢复标识符（当应用不再运行）。这些启动选项键在 UIApplicationDelegate Protocol Reference 中有更多的描述。 实现适当的恢复代理方法 在重新实例化中央和外围管理者后，通过与蓝牙系统进行状态同步来恢复。要把应用带回到系统替它保存的状态（当应用不运行时），必须实现恰当的恢复代理方法。对于中央管理者，实现 centralManager:willRestoreState: 代理方法，对于外围管理者，实现 peripheralManager:willRestoreState: 代理方法。 重要：对于加入 Core Bluetooth 状态保存和恢复特性的应用，当应用被重启进入到后台以完成蓝牙相关的任务时，这两个（ centralManager:willRestoreState: 和 peripheralManager:willRestoreState: ）是首先被调用的方法。对于没有加入状态恢复和保存特性的应用（或者在启动时没有需要恢复的东西），那么首先调用的两个方法是 centralManagerDidUpdateState: 和 peripheralManagerDidUpdateState:。 在上面的两个代理方法中，最后一个参数（是一个字典）包含应用终止时保存下来的管理者信息。可用的字典键清单，请看 CBCentralManagerDelegate Protocol Reference 中的 中央管理者状态恢复选项 常量和 CBPeripheralManagerDelegate Protocol Reference 中的 外围管理者状态恢复选项 常量。 要恢复 CBCentralManager 对象的状态，使用 centralManager:willRestoreState: 代理方法中提供的字典的键。例如，当应用终止时，如果中央管理者对象还有活跃的或者未完成的连接，那么系统会继续为应用监听连接。如下所示，可以使用 CBCentralManagerRestoredStatePeripheralsKey 字典键来获取中央管理者已连接或正在尝试连接的所有外围设备（由 CBPeripheral 对象表示）的列表。 - (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary *)state { NSArray *peripherals = state[CBCentralManagerRestoredStatePeripheralsKey]; ... 在上面的例子中，如何处理恢复的外围设备列表取决于使用场景。例如，如果应用要保存中央管理者发现的外围设备的一个列表，那么可能会把恢复的外围设备加入到该列表中以便引用它们。如 Connecting to a Peripheral Device After You’ve Discovered It 所描述，确保设置外围管理者的代理以保证收到适当的回调。 通过使用 peripheralManager:willRestoreState: 代理方法中字典的键，你可以以类似的方式来恢复 CBPeripheralManager 对象的状态。 修正初始化流程 在完成了前面的三个必须步骤之后，你可能想看看如何修正中央和外围管理者的初始化流程。尽管这是一个可选的步骤，但是也很重要，因为可以确保应用运行平滑。例如，当应用在探索外围设备的数据的中途被终止。当应用恢复了外围的状态，它并不知道当它被终止时它在发现外围设备的过程中走了多远。你会想要确保开始的点正是在发现过程中离开的那个点。 例如，当在 centralManagerDidUpdateState: 代理方法中初始化应用，你可以查明是否成功地从恢复的外围设备发现了特定的服务（在应用被终止前），像这样： NSUInteger serviceUUIDIndex = [peripheral.services indexOfObjectPassingTest:^BOOL(CBService *obj, NSUInteger index, BOOL *stop) { return [obj.UUID isEqual:myServiceUUIDString]; }]; if (serviceUUIDIndex == NSNotFound) { [peripheral discoverServices:@[myServiceUUIDString]]; ... 如上例所示，如果系统在应用完成发现服务之前终止了应用，那么在那时通过调用 discoverServices: 来开始探索恢复的外围设备的数据。如果应用成功地发现服务，那么你紧接着就可以检查看看特性是否已被发现（还有你是否已经订阅了特性）。通过以这样的方式修正初始化流程，可以确保在正确的时间调用了正确的方法。 与远程外围设备交互的最佳实践 Core Bluetooth 框架使得许多中央设备侧的事务对应用透明。也就是，应用能够支配、有责任实现中央角色的大多数方面，例如发现和连接设备以及特索并与远程外","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:23:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"留心无线电的使用和电量消耗 当开发与蓝牙低能耗设备交互的应用时，请记得蓝牙低能耗技术通信共享设备的无线电以在空中传递信号。其他形式的无线电通信可能也需要使用设备的无线电，例如 Wi-Fi，传统蓝牙，甚至是其它使用蓝牙低能耗的应用，因此，开发应用应该减少使用无线电。 当为 iOS 设备开发应用时，减少无线电的使用尤其重要，因为无线电的使用对设备电池的寿命有不良影响。下面的指导会帮助你成为设备无线电的良好公民。结果是，应用会表现更好而电池寿命会更长。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:24:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"需要时再去扫描设备 当调用 CBCentralManager 类的 scanForPeripheralsWithServices:options: 方法去发现远程外围设备（正在广播服务）时，中央设备会使用它的无线电去监听广播设备直到显式地让它停下。 除非需要发现更多的设备，否则在找到想要连接的设备后应该停止扫描其它设备。 使用 CBCentralManager 类的 stopScan 方法去停止扫描其它设备，如 Connecting to a Peripheral Device After You’ve Discovered It 所说。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:24:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"只在必要的时候指定 CBCentralManagerScanOptionAllowDuplicateKey 选项 远程外围设备每秒可能发出很多个广播数据包来向正在监听的中央设备表明它的存在。当使用 scanForPeripheralsWithServices:options: 方法来扫描设备时，方法的默认行为是合并广播设备的多个发现到一个单一发现事件中，也就是，中央管理者会为每一个它发现的新外围设备调用它的代理对象的 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 方法，不管它收到多少广播数据包。当已发现的外围设备的广播数据发生改变时，中央管理者也会调用这个代理方法。 如果想要改变默认的行为，当调用 scanForPeripheralsWithServices:options: 方法时可以指定 CBCentralManagerScanOptionAllowDuplicatesKey 常量作为扫描选项。这样的话，每一次中央设备收到来自外围设备的数据时都会生成一个发现事件。关闭默认行为在某些使用场景下可能很有用，例如基于外围设备的邻近度来初始化一条到外围设备的连接（使用外围设备接受信号强度指示器（RSSI）的值）。即便如此，请记住指定这个扫描选项对电池寿命以及应用的性能有不良影响。因此，只在必要的时候再去指定这个扫描选项以满足特定的使用场景。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:24:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"明智地探索外围设备的数据 外围设备的服务和特性数量可能比你感兴趣的要多得多。发现外围设备的所有服务及特性对电池的寿命和应用的性能有不良应用。因此，应该只寻找应用需要的服务以及与之关联的特性。 例如，设想你正在连接到一台有许多可用服务的外围设备，但应用只需要服务中的两个。你可以只寻找这两个服务，通过在 CBPeripheral 类的 discoverServices: 方法传入一个服务 UUID（由 CBUUID 对象表示） 数组，像这样： [peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]]; 在找到这两个感兴趣的服务之后，可以以类似的方式寻找这些服务中你感兴趣的特性。如前，只在 CBPeripheral 类的 discoverCharacteristics:forService: 方法中为每个服务传入一个 UUID（用来识别你所感兴趣的特性） 数组。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:24:3","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"订阅频繁改变的特性值 如 Retrieving the Value of a Characteristic 所说，有两种方式可以取回特性的值： 每一次需要值的时候，可以通过调用 readValueForCharacteristic: 方法显式地拉取特性值 通过调用一次 setNotifyValue:forCharacteristic: 方法来订阅特性值，以便在值发生改变时接收到来自外围设备的通知 可能的话，最好是订阅特性的值，尤其是那些经常改变的特性值。如何订阅特性值的例子，请看 Subscribing to a Characteristic’s Value。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:24:4","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"拿到所有所需数据后断开连接 当连接不再需要时，通过断开到外围设备的连接可以帮助减少应用的无线电的使用。在以下的两个场景中你应该断开到外围设备的连接： 所有订阅的特性值已经停止发送通知。（可以通过访问特性的 isNotifying 属性来判断特性的值是否在发送通知） 拿到了所有所需数据 在这两种情况下，取消所有订阅然后断开到外围设备的连接。通过调用 setNotifyValue:forCharacteristic: 方法并设置第一个参数值为 NO 来取消特性值的订阅。通过调用 CBCentralManager 类的 cancelPeripheralConnection: 方法可以取消到外围设备的连接，像这样： [myCentralManager cancelPeripheralConnection:peripheral]; 注意：cancelPeripheralConnection: 方法是非阻塞的，任何仍然挂在你正在尝试断开的外围设备的 CBPeripheral 命令可能会或不会完成执行。因为其他应用可能仍然连着外围设备，所以取消一个本地连接并不能保证底层的物理连接马上断开。不管怎么说，从你应用的角度来看，外围设备被认为是断开的，然后中央管理者对象会调用它的代理对象的 centralManager:didDisconnectPeripheral:error: 方法。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:24:5","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"重新连接到外围设备 使用 Core Bluetooth 框架，有三种可以重连外围设备的方式： 使用 retrievePeripheralsWithIdentifiers: 方法取回已知外围设备（以往发现过的或者连接过的外围设备）的列表。如果正在寻找的外围设备在列表中，尝试去连接它。这个重连选项在 Retrieving a List of Known Peripherals 中有讲到。 使用 retrieveConnectedPeripheralsWithServices: 方法取回当前正连接到系统的外围设备的列表。如果正在寻找的外围设备在列表中，将它本地连接到应用。这个重连选项在 Retrieving a List of Connected Peripherals 中有讲到。 使用 scanForPeripheralWithServices:options: 方法来扫描和发现外围设备。如果找到，就进行连接。这些步骤在 Discovering Peripheral Devices That Are Advertising 和 Connecting to a Peripheral Device After You’ve Discovered It 中有描述。 取决于使用场景，你可能不想每次要重连的时候都去扫描并发现同样的外围设备，相反，你可能想要优先使用其它的选项去试着重连。如图 5-1 所示，一个可能的重连工作流可能是按照上面列出的顺序来尝试每一个选项。 图 5-1 重连工作流示例 注意：决定要尝试的重连选项数量以及这么做的顺序，可能随着应用试图要满足的使用场景变化。例如，你可能决定不使用第一个连接选项，或者并行使用头两个选项。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:25:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"取回已知的外围设备的列表 第一次发现外围设备时，系统会生成一个标识符（一个 UUID，由 NSUUID 对象表示）来识别外围设备。然后你可以保存这个标识符（例如，使用 NSUserDefaults），之后可以用它来连接到外围设备（使用 CBCentralManager 类的 retrievePeripheralsWithIdentifiers: 方法）。下面讲述了使用这个方法来重连先前已经连接过的外围设备的一种方式。 当应用启动时，调用 retrievePeripheralsWithIdentifiers: 方法并传入一个标识符数组（包含先前发现过并连接过的外围设备的标识符），像这样： knownPeripherals = [myCentralManager retrievePeripheralsWithIdentifiers:savedIdentifiers]; 中央管理者试着把你提供的标识符与先前找到过的外围设备的标识符相比对，并且返回一个包含 CBPeripheral 对象的数组。如果比对发现没有，会返回一个空数组然后你应该尝试另外两个重连选项。如果数组不为空，提供 UI 让用户选择重连哪个外围设备。 当用户选择了一个外围设备，试着通过调用 CBCentralManager 类的 connectPeripheral:options: 方法来连接该设备。如果设备可以连接上，中央管理者回调用它的代理对象的 centralManager:didConnectPeripheral: 方法，然后外围设备就成功地重连上了。 注意：一个外围设备可能由于某些原因不能连接上，例如，设备可能不在中央设备的附近。另外，某些蓝牙低能耗设备使用随机的设备地址（周期性地改变）。因此，即使设备就在附近，从上次被系统发现到现在，设备的地址可能已经改变，在这种情况下，试图连接的 CBPeripheral 对象与实际的外围设备不相符。如果因为地址变化而不能连接到外围设备，那么必须通过使用 scanForPeripheralsWithServices:options: 方法来发现它。 有关随机设备地址的更多信息，请看蓝牙 4.0 规范，卷 3，C 部分，10.8 节以及 Bluetooth Accessory Design Guidelines for Apple Products。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:25:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"取回已连接的外围设备的列表 另外一种连接到外围设备的方式是：通过检查正在寻找的外围设备是否已经与系统相连（例如，被其它应用连接了）。通过调用 CBCentralManager 类的 retrieveConnectedPeripheralsWithServices: 方法可以这么做，这会返回一个包含 CBPeripheral 对象（表示当前正在与系统相连的外围设备）的数组。 因为可能存在多个正在与系统相连的外围设备，你可以传入一个包含 CBUUID （表示服务的 UUID） 的数组，以取回当前正在与系统相连的并且包含指定 UUID 所标识的服务的外围设备。如果当前没有设备与系统相连，数组会为空，然后你应该尝试其它两个重连选项。如果数组不为空，提供 UI 让用户选择重连哪个外围设备。 假设用户找到并选择了期望的外围设备，通过调用 CBCentralManager 类的 connectPeripheral:options: 方法，将它本地连接到应用（即使设备已经连接到系统，你仍然必须将它本地连接到应用以开始探索并与之交互）。当本地连接建立后，中央管理者会调用它的代理对象的 centralManager:didConnectPeripheral: 方法，然后外围设备就成功地重连上了。 把本地设备当作外围设备来使用的最佳实践 正如许多中央设备侧的事务，Core Bluetooth 框架给你控制实现外围角色的大多数方面。这个章节提供以负责任的方式去利用这种层级的控制的指导和最佳实践。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:25:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"广播方面的考虑 广播外围设备数据是建立本地设备以实现外围角色的一个重要部分。下面的章节帮助你以合适的方式实现外围角色。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:26:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"考虑广播数据的限制 通过往 CBPeripheralManager 类的 startAdvertising: 方法传入一个广播数据的字典来广播外围设备数据，就像 Advertising Your Services 所讲。当创建广播字典时，请记住广播的内容及数量都有限制。 虽然广播数据包通常可以保存各种各样关于外围设备的信息，然而你可能仅仅广播设备的本地名称以及服务的 UUID。因此，当创建广播字典时，或许会只指定以下两个键： CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey。如果指定了其它键会收到错误。 当广播数据时，能够使用的空间大小也有限制。当应用在前台，任何两种支持的广播数据键的组合的最初的广播数据包中，能够使用多达 28 个字节的空间。如果这个空间被用完了，在扫描响应中还有额外的 10 个字节的空间大小（仅供本地名称使用）。任何与分配空间不适合的服务 UUID，会被添加到特别的 “溢出” 区域，它们只能被显式扫描它们的 iOS 设备发现。当应用处于后台，本地名称不会被广播并且所有的服务 UUID 会被放入溢出区域。 注意：这些尺寸不包括 2 个字节的头部信息（新数据类型需要的头部信息）。确切的广播和响应数据格式在蓝牙 4.0 规范中有定义，卷 3，C 部分，11 小节。 为不超出空间限制，限制向那些标识你的主要服务的用户广播服务 UUID。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:26:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"仅在需要时广播数据 由于广播外围设备的数据使用本地设备的无线电（使用设备的电池），因此，仅在你想让其它设备连接时再去广播。一旦连接上，这些设备就可以直接探索并交互外围设备的数据，不需要任何的广播数据包。因此，为了减少无线电的使用，并提高应用的性能以及保存设备的电量，当没有必要再去利用蓝牙低能耗事务时，停止广播。要在本地外围设备上停止广播，只需要调用 CBPeripheralManager 类的 stopAdvertising 方法，像这样： [myPeripheralManager stopAdvertising]; 让用户决定何时广播 要知道，何时广播通常只有用户知道。例如，当知道周围没有蓝牙低能耗设备时，还让应用发广播是没有意义的。因为应用通常不知道周围有其它的什么设备，所以请在应用中提供图形界面（UI）的方式来让用户决定何时发广播。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:26:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"配置特性 当创建可变特性时，设置它的属性、值以及权限。这些设置决定了中央设备如何访问特性值以及如何与特性值交互。虽然你可能根据应用的需要决定有区别地配置特性的属性和权限，但下面的章节还是提供了一些指导，当你想要执行以下两个任务时： 允许已连接的中央设备订阅你的特性 保护敏感特性值以免被未配对的中央设备访问 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:27:0","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"配置特性以支持通知 如 Subscribe to Characteristic Values That Change Often 中所讲，推荐中央设备订阅频繁改变的特性值（一个远程外围设备的服务的特性值）。如果可能，鼓励这种做法（通过允许已连接的中央设备订阅你的特性值）。 当创建可变特性时，通过给特性的属性设置 CBCharacteristicPropertyNotify 常量来支持订阅，像这样： myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable]; 在这个例子中，特性的值是可读的，并且可以被已连接的中央设备订阅。 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:27:1","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"需要配对连接以访问敏感数据 取决于使用场景，你可能想要发布服务，该服务有一个或者多个特性值需要确保安全。例如，设想你要发布一个社交媒体资料服务。这个服务的有些特性的值代表会员的资料信息，例如姓名、邮箱地址。很有可能，你只想让受信任的设备取回会员的邮件地址。 通过设置适当的特性属性和权限可以确保只有受信任的设备才能访问敏感特性值。继续上面的例子，为了让只有受信任的设备才能取回会员的邮件地址，像这样设置特性的属性和权限： emailCharacteristic = [[CBMutableCharacteristic alloc] initWithType:emailCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotifyEncryptionRequired value:nil permissions:CBAttributePermissionsReadEncryptionRequired]; 这个例子中，特性被配置以让只有受信任的设备读取或订阅它的值。当一个已连接的远程中央设备试图去读取或订阅这个特性的值，Core Bluetooth 会尝试着把本地的外围设备与中央设备进行配对，以建立一条安全连接。 例如，如果中央设备和外围设备都是 iOS 设备，那么两个设备都会收到一个弹框警告表明有其它设备想要配对。在中央设备上的弹框包含一个密码，你必须在外围设备上的文本框中输入这个密码才能完成配对过程。 在配对过程完成之后，外围设备把配对的中央设备当作信任设备，并允许该中央设备访问它的加密特性值。 修订历史 这个表格叙述了 Core Bluetooth Programming Guide 的修改。 日期 备注 2013-09-18 为 iOS 7 和 OS X v10.9 更新有关在后台执行长期活动以及获取外围设备的新方法的信息 2013-08-08 新文档，讲述如何使用 Core Bluetooth 框架来开发与蓝牙低能耗技术交互的应用 ","date":"2018-03-26","objectID":"/ios-core-bluetooth-programming-guide/:27:2","tags":["iOS","Bluetooth"],"title":"Core Bluetooth Programming Guide 译文","uri":"/ios-core-bluetooth-programming-guide/"},{"categories":["翻译"],"content":"verification, validation, authentication, authorization 这几个术语很常用，也经常被误用，这里做一次对比总结。 identity A security principal (you or a computer, typically) wants to access a system. Because the system doesn’t know you yet, you need to make a declaration of who you are. Your answer to the question “Who are you” is the first thing you present to a system when you want to use it. Some common examples of identity are user IDs, digital certificates (which include public keys), and ATM cards. A notable characteristic of identity is that it is public, and it has to be this way: identity is your claim about yourself, and you make that claim using something that’s publicly available. 身份 指的是具有公共属性的身份，表示安全主体是谁。 authentication This is the answer to the question “OK, how can you prove it?” When you present your identity to a system, the system wants you to prove that it is indeed you and not someone else. The system will challenge you, and you must respond in some way. Common authenticators include passwords, private keys, and PINs. Whereas identity is public, authentication is private: it’s a secret known (presumably) only by you. In some cases, like passwords, the system also knows the secret. In other cases, like PKI, the system doesn’t need to possess the secret, but can validate its authenticity (this is one of many reasons why PKI is superior). Your possession of this secret is what proves that you are who you claim to be. 认证 指的是如何证明你就是某人，强调的是证明的过程、手段、机密性证据。 authorization Once you’ve successfully authenticated yourself to a system, the system controls which resources you’re allowed to access. Typically this is through the use of a token or ticket mechanism. The token or ticket constrains your ability to roam freely throughout the system. By “caching” your authenticated identity for subsequent access control decisions, it allows you to access only that which the administrators have determined is necessary, thus enforcing the principle of least privilege. 授权 指的是授予某主体执行某些操作或获取某些资源的权利。 validation To check data or filter data that requires no external references; usually meaning to check the format of the data matching a particular pattern. For example, check if something is filled in or not or the pattern of an email address matches. More specifically, validation is doing as little work as possible to check the very basic assumptions of the data. 验证 确保数据的真实性、有效性，在理论及逻辑层面上进行。例如：确保电话号码是否有效真实。 verification Occurs after Validation in that it is more complex and you would always use validation first and not allow verification if the validation did not pass. Verification has to do with checking against a current set of data that takes more resources to discover than Validation. For example, checking if an email has already been registered or not requires a lookup of existing registered users or another example would be checking if a zip code entered is actually a real zipcode by looking through a database of registered zipcodes. 校验、核对、核实 往往是两个以上个体之间进行对比。例如：手机验证码用来确保是机主本人。 参考： It’s Me, and Here’s My Proof: Why Identity and Authentication Must Remain Distinct Difference between “validation” and “verification” ","date":"2017-12-12","objectID":"/terminology-confusion/:0:0","tags":["翻译","Terminology"],"title":"Difference between authentication, authorization,verification, validation","uri":"/terminology-confusion/"},{"categories":["iOS","翻译"],"content":"原文地址：本地和远程通知编程指南 应用中的通知 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:0:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"本地和远程通知概览 重要 这篇文档包含开发中有关 API 或技术的初步信息，这些信息可能会改变，并且根据这篇文档来实现的软件应当在最终的操作系统软件中进行测试。 本地通知和远程通知是在应用有新数据可用时通知用户的两种方式，即使此时应用不在前台运行。例如，短信应用可能会让用户知道有新的短信来了，日历应用可能会通知用户即将到来的约会。本地通知和远程通知的区别很简单： 对于本地通知，应用在本地配置通知的细节并把这些细节传给系统，然后由系统来处理通知的传递（当应用不在前台时）。iOS、tvOS、watchOS 都支持本地通知。 对于远程通知，使用公司服务器中的一个通过苹果推送通知服务把数据推送到用户的设备。iOS、tvOS、watchOS、macOS 都支持远程通知。 本地通知和远程通知都需要添加代码来支持应用中的通知的调度和处理。对于远程通知，必须提供一个服务器环境，该环境能够接收来自用户设备的数据和发送通知相关的数据到 苹果推送消息服务 (简称 APNs，由苹果提供的用来处理远程通知传递的服务)。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:1:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"User Notifications 和 User Notifications UI 框架 从 iOS 10、watchOS 3、tvOS 10 开始，User Notifications 框架提供一致的方式来和处理本地通知。除了管理本地通知，该框架也支持远程通知的处理，然而远程通知的配置仍然需要一些平台特有的 API。因为这是一个独立的框架，所以可以在应用中或者扩展中使用，比如 WatchKit 扩展。 注意 macOS 上远程通知的配置和处理需要使用平台特有的方法（在 AppKit 框架中找） User Notifications 框架也支持创建 通知服务应用扩展 (notification service app extension)，它可以让你在远程通知传递之前修改通知的内容。如果在应用中包含通知服务应用扩展，系统会把收到的通知在传递给用户之前先传递给扩展。可以使用这类扩展来给应用的通知实现端到端的加密、在通知传递前修改其内容，又或者下载与通知相关的额外的图片或媒体文件。 User Notifications UI 框架是 User Notifications 的配套，它可以让你自定义系统的通知界面的外观。使用User Notifications UI 框架来定义 通知内容应用扩展(notification content app extension)，它的任务就是提供一个包含自定义内容的视图控制器来显示在通知界面中。系统会显示自定义视图控制器而不是默认的系统界面。可以使用这种扩展在通知界面中加入多媒体或动态内容。 更多有关 User Notifications 框架的类的信息，请看 User Notifications Framework Reference。关于创建通知内容应用扩展的类的信息，请看 User Notifications UI Framework Reference。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:1:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"什么时候使用本地通知和远程通知 因为 iOS、tvOS 和 watchOS 上的应用并非一直处于运行状态，所以当应用有新的信息需要呈现出来时，本地通知提供一种方式来提醒用户。比如，一个在后台从服务器拉取数据的应用可以在收到一些有趣的信息时调度一个本地通知。本地通知也很适合类似日历和待办事项清单的应用，这些应用需要在一个特定的时间或者抵达特定的地点时提醒用户。 当应用的部分或全部数据都由公司服务器来管理时，远程通知很合适。使用远程，由你决定何时推送通知给用户设备。例如，一个短信应用可能会使用远程通知让用户知道何时有新的短信到来。因为通知从你的服务器发出，所以你可以在任意时刻发送远程通知，包括应用不在运行状态的时候。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:1:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"在用户看来，本地通知和远程通知是一样的 对用户来说，在设备上呈现的远程通知和本地通知是没有区别的。两者都有着由系统提供的同样的默认外观。某些情况下，你可以自定义外观，但大部分情况下你只是选择你想要的通知用户的方式。具体地说，你可以从以下选项中选出一种来传递通知： 屏幕上弹框或横幅 应用图标角标 伴随弹框，横幅或者角标一起的声音 当配置本地和远程通知时，为要传递的通知选择一种最合适的交互类型。比如，一个代办事项清单应用可能有很多条目，其中每一条目都有完成的时间和优先级。对于高优先级的事项，当经过完成时间点时，也许需要弹框提醒用户立刻处理这一事项。对于低优先级的事项，也许采用更微妙的方式来提醒用户完成该事项，一个应用角标或者播放一段声音。 弹框把消息直接显示给用户，但角标和提示音的含义由取决于应用。可以使用不同的提示音来传达特定类型的事件，比如消息来了或者任务完成了。角标包含一个数值，该数值通常用来表明等候用户注意的事项的数目。图 1-1 显示了 iOS 应用图标上的角标位置。 图 1-1 一个包含角标数字的应用图标 为了避免惹恼用户，常常明智而审慎地使用本地和远程通知。系统允许用户根据每个应用来启用和禁用弹框、声音以及角标的呈现。虽然通知依然会传递到应用，但是系统仅仅会根据当前的启用选项来通知用户。如果用户完全禁用通知，APNs 不会往用户的设备传递应用的通知并且本地通知的调度总会失败。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:1:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"管理应用的通知支持 应用必须在启动的时候进行配置以支持本地和远程通知。具体地说，必须提前进行配置，如果需要做以下事情： 通知到来时显示弹框、播放声音、显示角标 随着通知到来显示自定义动作按钮 通常，应当在应用程序完成启动之前完成所有配置。在 iOS 和 tvOS 中，这意味着通知的支持配置不能晚于 UIApplication 的代理方法 application:didFinishLaunchingWithOptions:。在 watchOS 中，配置支持不能晚于 WKExtension 的代理方法 applicationDidFinishLaunching。你或许会在这之后进行配置，但必须要避免在配置完成之前调度任何指向应用的本地或远程通知。 支持远程通知的应用需要额外的配置，详见 Configuring Remote Notification Support。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:2:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"请求用户授权 在 iOS、tvOS、watchOS 中，应用必须得到授权才能在收到通知时显示弹框、播放声音或显示角标。请求授权把这些交互的控制权交到用户手里，用户可以同意或者拒绝请求，稍后用户也可以在系统设置里面修改应用的授权设置。 调用 UNUserNotificationCenter 共享对象的 requestAuthorizationWithOptions:completionHandler: 方法请求授权。如果所有请求的交互类型都得到授权，系统调用完成处理块并传入 granted 参数，值为 YES。如果有一个及以上的交互类型被拒绝，该参数的值为 NO。清单 2-1 演示了如何请求播放声音和显示弹框授权。根据交互类型是否得到授权，使用完成处理块来更新应用的行为。 清单 2-1 请求用户交互授权 OBJECTIVE-C UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter]; [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert + UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) { // Enable or disable features based on authorization. }]; SWIFT let center = UNUserNotificationCenter.current() center.requestAuthorization(options: [.alert, .sound]) { (granted, error) in // Enable or disable features based on authorization. } 应用首次启动并调用 requestAuthorizationWithOptions:completionHandler: 方法时，系统会提示用户选择同意或拒绝请求的交互。因为系统会保存用户的选择，所以应用之后启动时再调用这个方法不会再次提醒用户。 注意 用户可以随时在系统设置中修改应用的授权的交互类型。为了精确判定可以使用的交互类型，可以调用 UNUserNotificationCenter 的 getNotificationSettingsWithCompletionHandler: 方法。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:2:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"配置分类和可操作通知 可操作通知给用户提供一种快速、简单的方式来执行相关任务以回应通知。可操作通知的界面会显示用户可以点击的自定义动作按钮，而不是强制用户启动应用。每一个按钮被点击后都会隐藏通知界面并把选中的动作转发给应用立即处理，这可以免去用户打开应用并进一步操作的麻烦，因此更省时。 应用必须显式地为可操作通知添加支持。在应用启动时，必须注册一个或多个分类（分类定义了应用发送的通知的类型）。每个分类都关联了该类通知传递时用户可以执行的操作。每个分类可以有多达 4 个关联动作，然而显示的动作数量通常取决于通知显示的方式和位置。例如，横幅显示的动作不超过两个。 注意 可操作通知仅支持 iOS 和 watchOS。 为应用注册通知分类 分类定义了应用支持的通知类型并向系统传达想要的通知呈现方式。使用分类给通知关联自定义动作并指定该类通知的处理方式选项。例如，使用分类选项来指定通知是否可以被显示在 CarPlay 环境中。 在应用启动时，使用 UNUserNotificationCenter 对象的 setNotificationCategories: 的方法立即注册应用的所有分类。在调用该方法前，创建一个或多个 UNNotificationCategory 类的实例并指定在该类型的通知显示时使用的分类名和选项。分类名只在应用内部，用户永远看不到。在调度通知时，把分类名放到通知负载里面，系统会利用分类名来取出选项和显示通知。 清单 2-2 演示了如何创建一个简单的 UNNotificationCategory 对象并向系统注册。这个分类名为 “GENERAL” 并配置了一个自定义关闭动作选项，这使得系统会在用户关闭通知界面时通知应用。 清单 2-2 创建和注册通知分类 OBJECTIVE-C UNNotificationCategory* generalCategory = [UNNotificationCategory categoryWithIdentifier:@\"GENERAL\" actions:@[] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; // Register the notification categories. UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter]; [center setNotificationCategories:[NSSet setWithObjects:generalCategory, nil]]; SWIFT let generalCategory = UNNotificationCategory(identifier: \"GENERAL\", actions: [], intentIdentifiers: [], options: .customDismissAction) // Register the category. let center = UNUserNotificationCenter.current() center.setNotificationCategories([generalCategory]) 不要求为所有调度的通知指定一个分类，但是，不包含分类的通知在显示时没有任何自定义动作或配置选项。 给分类添加自定义动作 每个注册的分类可能包含多达 4 个自定义动作。当分类包含自定义动作时，系统会在通知界面添加按钮，每个按钮上都带有自定义动作的标题。如果用户点击自定义动作，系统会发送相应的动作标识符到应用，并根据需要启动应用。 通过创建一个 UNNotificationAction 对象并把它加到分类对象中来定义一个自定义动作。每个动作都包含相应按钮的标题以及如何显示按钮和处理关联任务的选项。当用户选中一个动作，系统会为应用提供动作的标识符字符串（这字符串可以用来识别要执行的任务）。清单 2-3 在清单 2-2 例子的基础上添加了一个包含 2 个自定义动作的新分类。 清单 2-3 为分类定义自定义动作 OBJECTIVE-C UNNotificationCategory* generalCategory = [UNNotificationCategory categoryWithIdentifier:@\"GENERAL\" actions:@[] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; // Create the custom actions for expired timer notifications. UNNotificationAction* snoozeAction = [UNNotificationAction actionWithIdentifier:@\"SNOOZE_ACTION\" title:@\"Snooze\" options:UNNotificationActionOptionNone]; UNNotificationAction* stopAction = [UNNotificationAction actionWithIdentifier:@\"STOP_ACTION\" title:@\"Stop\" options:UNNotificationActionOptionForeground]; // Create the category with the custom actions. UNNotificationCategory* expiredCategory = [UNNotificationCategory categoryWithIdentifier:@\"TIMER_EXPIRED\" actions:@[snoozeAction, stopAction] intentIdentifiers:@[] options:UNNotificationCategoryOptionNone]; // Register the notification categories. UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter]; [center setNotificationCategories:[NSSet setWithObjects:generalCategory, expiredCategory, nil]]; SWIFT let generalCategory = UNNotificationCategory(identifier: \"GENERAL\", actions: [], intentIdentifiers: [], options: .customDismissAction) // Create the custom actions for the TIMER_EXPIRED category. let snoozeAction = UNNotificationAction(identifier: \"SNOOZE_ACTION\", title: \"Snooze\", options: UNNotificationActionOptions(rawValue: 0)) let stopAction = UNNotificationAction(identifier: \"STOP_ACTION\", title: \"Stop\", options: .foreground) let expiredCategory = UNNotificationCategory(identifier: \"TIMER_EXPIRED\", actions: [snoozeAction, stopAction], intentIdentifiers: [], options: UNNotificationCategoryOptions(rawValue: 0)) // Register the notification categories. let center = UNUserNotificationCenter.current() center.setNotificationCategories([generalCategory, expiredCategory]) 虽然可以给每个分类指定多达 4 个自定义动作，但系统在某些情况下可能只显示前面 2 个。例如，当在横幅中显示通知时仅显示两个动作。当初始化 UNNotificaitonCategory 对象时，常常设置动作数组以便最相关的动作就是数组的首个元素。 如果使用 UNTextInputNotificationAction 类来设置动作，系统会提供一种方式来让用户输入文本（作为通知响应的一部分）。在向用户收集自由格式的文本时，文本输入动作很有用。例如，一个短信应用可能允许用户为短信提供自定义回复。当文本输入动作传递到应用中处理时，系统会把用户的回复打包到一个 UNTextInputNotificationResponse 对象中。 有关如何处理自定义动作被选中的信息，请看 Responding to the Selection of a Custom ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:2:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"准备自定义提示音 本地和远程通知可以指定在通知传递时播放的自定义提示音。可以把音频数据打包到一个 aiff、wav 或 caf 文件中。因为音频文件由系统声音设备播放，所以自定义的的音频必须是以下音频数据格式中的一种： Linear PCM MA4 (IMA/ADPCM) µLaw aLaw 把自定义的音频文件放到应用包中或应用容器目录的 Library/Sounds 文件夹中。自定义的音频播放时长必须在 30s 以内，如果超过 30s，改为播放默认的系统声音。 可以使用 afconvert 工具来转换音频。例如，要把 16 bit 的 PCM 系统音频 Submarine.aiff 转换为 IMA4 音频保存到一个 CAF 文件中，可以在终端使用以下命令： afconvert /System/Library/Sounds/Submarine.aiff ~/Desktop/sub.caf -d ima4 -f caff -v 如何关联音频文件到通知的信息，请看 Adding a Sound to the Notification Content。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:2:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"管理应用的通知设置 因为用户可以随时修改应用的通知设置，所以你可以随时使用 UNUserNotificationCenter 共享对象的 getNotificationSettingsWithCompletionHandler: 方法来获取应用的授权状态。该方法返回一个 UNNotificationSettings 对象，它的内容反映应用当前的授权状态和当前的通知环境。 使用 UNNotificationSettings 对象中的信息来调整应用中与通知相关的代码。把应用的弹框、角标、声音的授权设置传达给 提供者，以便它调整远程通知负载中包含的选项。(提供者即由开发者部署、管理并配置以和 APNs 一起工作的服务器，有关提供者的更多信息，请看 APNs Overview)。开发者可以使用其他设置来调整通知的调度和配置，有关更多可用的设置的信息，请看 UNNotificationSettings Class Reference 。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:2:4","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"管理通知传递 当本地和远程通知不直接由应用或用户处理时，它们会被显示在通知中心中以便稍后查看。使用 UNUserNotificationCenter 共享对象的 getDeliveredNotificationsWithCompletionHandler: 方法去获取仍显示在通知中心中的通知的列表。如果发现有任何已过期的、不该再显示给用户看的通知，可以使用 removeDeliveredNotificationsWithIdentifiers: 方法移除。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:2:5","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"调度和处理本地通知 当应用不在运行状态时，本地通知为此提供一种方式来提醒用户。本地通知在某一时刻（应用在前台或后台时）调度。在调度之后，系统负责在合适的时间把通知传递给用户。在系统传递通知时应用不需要处于运行状态。 如果应用不在运行状态（或者处于后台），系统直接把本地通知显示给用户。系统可以通过提示框或横幅、使用声音或者显示应用角标等来提醒用户。如果应用提供了通知内容应用扩展，系统甚至可以使用自定义界面来提醒用户。如果通知到来时应用处于前台，系统会给机会应用在内部处理通知。 注意 本地通知只支持 iOS、watchOS 和 tvOS，在 macOS 上，当应用处于后台时不需要本地通知来显示角标、播放声音或显示弹框，这些特性在 AppKit 框架中已经有支持。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:3:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"配置本地通知 配置一个本地通知有以下步骤： 使用通知的细节来创建配置一个 UNMutableNotificationContent 对象； 创建 UNCalendarNotificationTrigger、UNTimeIntervalNotificationTrigger 或者 UNLocationNotificationTrigger 对象来描述通知传递的触发条件； 使用内容和触发器信息来创建一个 UNNotificationRequest 对象； 调用 addNotificationRequest:withCompletionHandler: 方法来调度通知，请看 Scheduling Local Notifications for Delivery。 当为通知创建内容时，填充 UNMutableNotificationContent 对象的属性（反映了期望的用户交互类型）。例如，当想要显示一个提示框时填充 title 和 body 属性。系统根据你提供的属性来决定如何与用户交互。你也可以在处理传递到应用中的本地通知时使用这个对象中的数据。 创建完通知内容之后，创建一个触发器对象来规定何时传递通知。User Notificaiton 框架提供基于时间和基于位置两种触发器。使用自己需要的条件来配置触发器，然后用它和内容来创建 UNNotificationRequest 对象。 清单 3-1 演示了如何创建和配置与闹铃相关的本地通知。使用 UNCalendarNotificationTrigger 促使通知在指定的日期或时间传递，例子中是下次时钟经过早上 7:00 时。 清单 3-1 创建和配置一个本地通知 OBJECTIVE-C UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init]; content.title = [NSString localizedUserNotificationStringForKey:@\"Wake up!\" arguments:nil]; content.body = [NSString localizedUserNotificationStringForKey:@\"Rise and shine! It's morning time!\" arguments:nil]; // Configure the trigger for a 7am wakeup. NSDateComponents* date = [[NSDateComponents alloc] init]; date.hour = 7; date.minute = 0; UNCalendarNotificationTrigger* trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:date repeats:NO]; // Create the request object. UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@\"MorningAlarm\" content:content trigger:trigger]; SWIFT let content = UNMutableNotificationContent() content.title = NSString.localizedUserNotificationString(forKey: \"Wake up!\", arguments: nil) content.body = NSString.localizedUserNotificationString(forKey: \"Rise and shine! It's morning time!\", arguments: nil) // Configure the trigger for a 7am wakeup. var dateInfo = DateComponents() dateInfo.hour = 7 dateInfo.minute = 0 let trigger = UNCalendarNotificationTrigger(dateMatching: dateInfo, repeats: false) // Create the request object. let request = UNNotificationRequest(identifier: \"MorningAlarm\", content: content, trigger: trigger) 给 UNNotificationRequest 对象提供一个标识符可以在通知调度之后用来识别通知。稍后可以使用标识符来查找未完成的请求或者在传递之前把它取消掉。更多关于调度和取消请求的信息，请看 Scheduling Local Notifications for Delivery 。 给本地通知指定自定义动作 为了在界面上给本地通知显示自定义动作，需要在配置 UNMutableNotificationContent 对象时为 categoryIdentifier 属性赋值一个已注册的分类的标识符。系统根据分类的信息来判定该显示哪个动作按钮，如果有，就把它显示在通知界面上。必须在调度通知请求前给这个属性赋值。 清单 3-2 演示了如何给本地通知指定分类标识符。在这个例子中，字符串 “TIMER_EXPIRED” 代表一个在启动时定义并且包含 2 个自定义动作的分类。注册这个分类的代码在清单 2-3 给出。 清单 3-2 给本地通知定义一个分类 OBJECTIVE-C UNNotificationContent *content = [[UNNotificationContent alloc] init]; // Configure the content. . . // Assign the category (and the associated actions). content.categoryIdentifier = @\"TIMER_EXPIRED\"; // Create the request and schedule the notification. SWIFT let content = UNMutableNotificationContent() // Configure the content. . . // Assign the category (and the associated actions). content.categoryIdentifier = \"TIMER_EXPIRED\" // Create the request and schedule the notification. 关于如何使用分类注册自定义动作的信息，请看 Configuring Categories and Actionable Notifications 。 添加声音到通知内容中 如果需要在本地通知传递时播放一段音频，那么就给 UNMutableNotificationContent 对象的 sound 属性赋值。使用 UNNotificationSound 对象指定音频，该对象可以让你播放一段自定义音频或默认通知音频。自定义音频必须在播放前放置在本地。在应用主包中保存音频文件或者下载之后保存到应用的容器目录中的 Library/Sounds 子目录中。 要播放默认音频，需要创建音频文件并赋值给通知内容。例如： OBJECTIVE-C content.sound = [UNNotificationSound defaultSound]; SWIFT content.sound = UNNotificationSound.default() 当指定自定义音频时，仅指定你想要播放的音频文件名。如果系统找到了与提供的文件名匹配的音频文件，就会在通知传递时播放该音频。如果系统没有找到合适的音频文件，就会播放默认的音频。 OBJECTIVE-C content.sound = [UNNotificationSound soundNamed:@\"MySound.aiff\"]; SWIFT content.sound = UNNotificationSound(named: \"MySound.aiff\") 有关支持的音频文件格式的信息，请看 UNNotificationSound Class Reference。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:3:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"调度本地通知 要调度本地通知，需要创建 UNNotificationRequest 对象并调用 UNUserNotificationCenter 的 addNotificationRequest:withCompletionHandler: 方法。系统异步地调度本地通知，当调度完成或者有错误发生系统会调用完成处理块。清单 3-3 演示了如何调度本地通知。这个例子中的代码完善了在清单 3-1 中创建的通知调度例子。 清单 3-3 调度本地通知 OBJECTIVE-C // Create the request object. UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@\"MorningAlarm\" content:content trigger:trigger]; UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter]; [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) { if (error != nil) { NSLog(@\"%@\", error.localizedDescription); } }]; SWIFT // Create the request object. let request = UNNotificationRequest(identifier: \"MorningAlarm\", content: content, trigger: trigger) // Schedule the request. let center = UNUserNotificationCenter.current() center.add(request) { (error : Error?) in if let theError = error { print(theError.localizedDescription) } } 已调度的本地通知会保持活跃直到被系统清理调度或者被显式取消。通知在传递后系统会自动清理调度，除非通知的触发器配置为重复的。为了在一个独立的通知被传递前取消它，或者取消一个重复发生的通知，可以调用 UNUserNotificationCenter 的 removePendingNotificationRequestsWithIdentifiers: 方法。被取消通知的 UNNotificationRequest 对象的 identifier 属性必须有赋值。要取消所有未完成的本地通知(不管有没有请求标识符)，请调用 removeAllPendingNotificationRequests 方法。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:3:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"响应通知的传递 当应用不在运行状态或者处于后台，系统会按照指定的交互方式自动地传递本地和远程通知。如果用户选中一个动作或者标准交互中的一个，系统就会把用户的选择通知应用，代码可以据此来执行额外的任务。如果应用正在前台运行，通知会直接传递到应用，然后你可以决定是安静地处理通知还是提醒用户。 为了响应通知的传递，必须实现 UNUserNotificationCenter 共享对象的代理方法。代理对象必须遵守 UNUserNotificationCenterDelegate 协议（通知中心用代理方法来传递通知信息到应用中）。如果通知包含自定义动作，代理是必须的。 重要 必须在应用（或应用扩展）启动完之前给 UNUserNotificationCenter 对象的代理赋值，否则会妨碍应用正确地处理通知。 关于实现代理对象的额外信息，请看 UNUserNotificationCenterDelegate Protocol Reference 。 当应用在前台时处理通知 如果通知在应用处于前台时到来，可以压制（silence）通知或者告知系统继续显示通知界面。系统在默认情况下会为前台应用压制通知，并把通知数据直接传递给应用，可以使用这些数据来直接更新应用界面。例如，如果新的运动比分数据到来，你只需要在你的界面中更新这些信息。 如果希望系统继续显示通知界面，需要给 UNUserNotificationCenter 提供代理对象并实现 userNotificationCenter:willPresentNotification:withCompletionHandler: 方法，实现中依然处理通知数据。处理完之后执行提供的完成处理块并传入想让系统使用的传递选项（如果有的话）。如果没有指定任何选项，系统会压制通知。清单 3-4 给出了一个实现的例子，例子让系统播放一段音频，通知的负载会标识出要播放的音频。 清单 3-4 应用处于前台时播放音频 OBJECTIVE-C - (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler { // Update the app interface directly. // Play a sound. completionHandler(UNNotificationPresentationOptionSound); } SWIFT func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -\u003e Void) { // Update the app interface directly. // Play a sound. completionHandler(UNNotificationPresentationOptions.sound) } 应用处于后台或者不在运行状态时，系统不会调用 userNotificationCenter:willPresentNotification:withCompletionHandler: 方法。在那些情况下，系统会根据通知中的信息来提示用户。你仍然可以使用 UNUserNotificationCenter 对象的 getDeliveredNotificationsWithCompletionHandler: 方法来判定通知是否处于传递状态。 响应自定义动作的选中 当用户在通知界面选中自定义动作，系统会把用户的选择结果通知应用。自定义按钮的响应会被打包到一个 UNNotificationResponse 对象中并传递给应用的 UNUserNotificationCenter 共享对象的代理。为了接收到响应，代理对象必须实现 userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: 方法。方法的实现必须能够处理应用（或应用扩展）支持的所有自定义动作。 如果收到响应时应用（或应用扩展）不在运行状态，系统会在后台启动应用（或应用扩展）来处理响应。利用系统提供的后台时间来更新数据结构和应用界面，以此来反映用户的选择。不要用这部分时间来执行与自定义动作处理无关的任务。 清单 3-5 演示了一个计时应用（包含多个分类和自定义动作）响应处理方法的实现。实现利用动作和 categoryIdentifier 属性来判定合适的路线。 清单 3-5 处理自定义的通知动作 OBJECTIVE-C - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler { if ([response.notification.request.content.categoryIdentifier isEqualToString:@\"TIMER_EXPIRED\"]) { // Handle the actions for the expired timer. if ([response.actionIdentifier isEqualToString:@\"SNOOZE_ACTION\"]) { // Invalidate the old timer and create a new one. . . } else if ([response.actionIdentifier isEqualToString:@\"STOP_ACTION\"]) { // Invalidate the timer. . . } } // Else handle actions for other notification types. . . } SWIFT func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -\u003e Void) { if response.notification.request.content.categoryIdentifier == \"TIMER_EXPIRED\" { // Handle the actions for the expired timer. if response.actionIdentifier == \"SNOOZE_ACTION\" { // Invalidate the old timer and create a new one. . . } else if response.actionIdentifier == \"STOP_ACTION\" { // Invalidate the timer. . . } } // Else handle actions for other notification types. . . } 处理标准系统动作 在系统通知界面中，用户可以显式关闭通知界面或者启动应用而不是选中一个自定义动作。关闭界面涉及点击一个可用的按钮或者直接关闭界面，忽视通知或者轻轻弹开横幅通知不代表显式关闭。当系统动作被触发，用户通知中心把它们反馈到它的代理方法 userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:。传递到方法中的响应对象包含以下动作标识符中的一个： UNNotificationDismissActionIdentifier 让你知道用户没有选中自定义动作，而是显式关闭通知界面。 UNNotificationDefaultActionIdentifier 让你知道用户没有选中自定义动作，而是启动应用。 以与处理其他动作同样的方式同样的方式来处理标准系统动作。清单 3-6 给出了检查这些特殊动作的 userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: 方法的一个模版。 清单 3-6 处理标准系统动作 OBJECTIVE-C - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationRespo","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:3:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"配置远程通知支持 支持远程通知可以让你把最新的信息提供给应用，即使此时应用不处于运行状态。为了能够接收和处理远程通知，应用必须： 启用远程通知 向苹果推送通知服务（APNs）注册并接收应用特有的设备令牌（device token） 把设备令牌发送到通知提供者服务器 支持处理到来的远程通知 这一章节讲解了这些步骤，在应用中实现每一个步骤。关于提供者（开发者部署和管理的用来创建和发送通知请求到 APNs 的服务器），请看 APNs Overview。 注意 应用至少启动过一次，APNs 才能给未处于运行状态的应用传递远程通知。 在 iOS 设备上，如果用户在多任务管理界面中强行退出了应用，那么应用不会再收到远程通知直到用户再次重启应用。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:4:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"开启推送通知的能力 应用要处理远程通知，必须有正确的权限来与 APNs 对话。按照 Xcode 帮助描述Enable push notifications 使用 Xcode 工程的能力面板来给应用添加这个权限。 没有预期权限的应用在应用商店的审核流程中会被拒绝，在测试过程中，试图在没有正确授权的应用中向 APNs 注册会返回错误。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:4:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"注册接收远程通知 每次应用启动必须向 APNs 注册，不同的平台使用的方法会有区别，但工作的流程都一样： 应用请求向 APNs 注册 成功注册后，APNs 将应用特有的设备令牌发送到设备 系统通过调用应用的代理方法把设备令牌（原文中是 device，但按照上下文来理解，应该是 device token）传递到应用中 应用把设备令牌发往与应用关联的提供者服务器 演示这些步骤的代码片段，请看 Obtaining a Device Token in iOS and tvOS 和 Obtaining a Device Token in macOS。 应用特有的设备令牌是全局唯一的并且标识一个应用和设备的组合。当在应用中收到来自 APNs 的设备令牌，需要打开一条到提供者的网络连接并把设备令牌连同其它任何相关的数据发送给提供者。提供者在向 APNs 发送远程通知请求时，必须附上设备令牌以及通知负载。更多相关内容，请看 APNs Overview。 永远不要在应用中缓存设备令牌，而是在需要的时再从系统获取。APNs 会在发生某些事件时签发新的设备令牌，这个设备令牌肯定不一样，例如，当用户从备份中恢复设备时，当在新设备上安装应用时，当用户重装系统时。重新获取令牌而不是依赖于缓存，确保当前的设备令牌正是提供者需要用来与 APNs 通信的那个。当试图获取设备令牌时，如果设备令牌没有变，获取方法会马上返回。 重要 当设备令牌改变了，用户必须启动应用一次，APNs 才能再次把远程通知发送到设备 在 watchOS 上运行的应用不会显式注册远程通知，而是依赖配对的 iPhone 转发远程通知以显示在 watch 上，通知的转发会发生在（iPhone 处于锁定状态或者屏幕休眠并且 APPle Watch 在用户手腕上且已解锁）。 关于远程通知的数据格式和如何发送数据到 APNs 的信息，请看 Communicating with APNs。 在 iOS 和 tvOS 上获取设备令牌 在 iOS 和 tvOS 上，通过调用 UIApplication 的 registerForRemoteNotifications 方法来发起 APNs 注册。在启动时调用这个方法并把它当作正常启动流程的一部分。当应用首次调用这个方法时，应用对象会代你联系 APNs 并请求一个应用特有的设备令牌。然后系统会根据成功或失败异步调用以下代理方法： 设备令牌成功签发，系统调用 application:didRegisterForRemoteNotificationsWithDeviceToken: 方法，实现这个方法来接收令牌并转发给提供者。 签发失败，系统调用 application:didFailToRegisterForRemoteNotificationsWithError: 方法，实现这个方法来响应 APNs 注册错误。 重要 APNs 设备令牌长度是可变的，不要硬编码。 成功向 APNs 注册之后，应用对象只会在设备令牌发生改变时与 APNs 联系，除此之外，调用 registerForRemoteNotifications 方法会调用 application:didRegisterForRemoteNotificationsWithDeviceToken: 方法并立马返回现有令牌。 注意 如果在应用运行的时候设备令牌发生改变，应用对象会再次调用 application:didRegisterForRemoteNotificationsWithDeviceToken: 代理方法通知你。 清单 4-1 演示了在 iOS 或者 tvOS 应用中如何获取设备令牌。应用代理把调用 registerForRemoteNotifications 方法当作常规启动时准备工作的一部分。在收到设备令牌时，application:didRegisterForRemoteNotificationsWithDeviceToken: 方法使用自定义的方法把设备令牌发送到关联的提供者，如果在注册过程中发生错误，应用会临时禁用任何与远程通知相关的功能，这些功能会在收到有效的设备令牌时重新启用。 清单 4-1 在 iOS 中注册远程通知 OBJECTIVE-C - (void)applicationDidFinishLaunching:(UIApplication *)app { // Configure the user interactions first. [self configureUserInteractions]; // Register for remote notifications. [[UIApplication sharedApplication] registerForRemoteNotifications]; } // Handle remote notification registration. - (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)devToken { // Forward the token to your provider, using a custom method. [self enableRemoteNotificationFeatures]; [self forwardTokenToServer:devTokenBytes]; } - (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err { // The token is not currently available. NSLog(@\"Remote notification support is unavailable due to error: %@\", err); [self disableRemoteNotificationFeatures]; } SWIFT func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -\u003e Bool { // Configure the user interactions first. self.configureUserInteractions() // Register with APNs UIApplication.shared.registerForRemoteNotifications() } // Handle remote notification registration. func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data){ // Forward the token to your provider, using a custom method. self.enableRemoteNotificationFeatures() self.forwardTokenToServer(token: deviceToken) } func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { // The token is not currently available. print(\"Remote notification support is unavailable due to error: \\(error.localizedDescription)\") self.disableRemoteNotificationFeatures() } 如果网络（蜂窝或 Wi-Fi）不可用，application:didRegisterForRemoteNotificationsWithDeviceToken: 和 application:didFailToRegisterForRemoteNotificationsWithError: 方法都不会被调用。对于 Wi-Fi 连接来说，如果设备不能通过配置的端口连接到 APNs 就会出现这种情况，如果发生这种情况，用户可以移步到其它不阻塞期望端口的 Wi-Fi 网络。对于使用蜂窝通信的设备，用户可以一直等到蜂窝数据服务可用。 在 application:didFailToRegisterForRemoteNotificationsWithError: 方法的实现中，使用错误对象来禁用任何与远程通知相关的功能。因为无论如何通知不可能到来，所以最好优雅地降级并避免任何对促进远程通知有帮助的本地工作。之后如果远程通知可用，应用对象会通过调用 application:didRegisterForRemoteNotificationsWithDeviceToken: 代理方法来通知你。 在 macOS 上","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:4:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"处理远程通知 User Notifications 框架为 iOS、watchOS 和 tvOS 的应用提供了统一的 API 并支持大多数与本地和远程通知相关的任务。下面是一些可以用这个框架来执行的任务的例子： 如果应用在前台，可以直接接收通知并压制它 如果应用在后台或不在运行状态 可以在用户选中了与通知关联的自定义动作时作出响应 可以在用户关闭通知或者启动应用时作出响应 应用通过应用代理来接收远程通知的负载，当远程通知到来时，如果应用在后台，系统会按正常的用户交互方式来处理。在 iOS 和 tvOS 上，系统会把通知负载传递给应用代理的 application:didReceiveRemoteNotification:fetchCompletionHandler: 方法。在 macOS 上，系统会把负载传递给应用代理的 application:didReceiveRemoteNotification: 方法。可以使用这些方法检查负载和执行相关的任务。例如，当收到后台更新的远程通知时，你可能会为应用下载新内容。 有关如何使用 User Notifications 框架的方法来处理通知的信息，请看 Responding to the Delivery of Notifications。有关如何在应用代理中处理通知的信息，请看 UIApplicationDelegate Protocol Reference 或者 NSApplicationDelegate Protocol Reference。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:4:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"修改和展示通知 可以使用应用扩展来修改通知的内容和展示。要在远程通知传递之前修改它的内容，使用 通知服务应用扩展。要修改通知在屏幕上的显示方式，使用 通知内容应用扩展。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:5:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"修改远程通知的负载 在远程通知传递给用户前，使用通知服务应用扩展来修改负载。远程通知来自服务器，服务器掌控通知的配置和内容。服务扩展可以让应用在数据呈现给用户前修改服务器提供的负载数据。使用服务扩展可以实现以下功能： 解密经过加密的数据 下载图片以及其它的媒体文件并把它当作附件加入到通知中 修改通知的主体或标题文本 给通知增加线程标识符或者修改通知的 userInfo 字典的内容 添加通知服务应用扩展到应用中 在 Xcode 选择 New \u003e Target 添加一个 target 到工程中 在 iOS \u003e Application Extension 选项中，选择 Notification Service Extension target 点击 Next 指定应用扩展名和其它的详细内容 点击 Finish Xcode 会添加一个预先配置好的 target 到工程中。 由 Xcode 提供的默认通知服务扩展 target 包含一个可以修改的 UNNotificationServiceExtension 子类。使用 didReceiveNotificationRequest:withContentHandler: 方法创建和配置一个新的 UNMutableNotificationContent 对象，可根据需要修改这个新内容对象，替换一些或所有初始内容值。在完成修改之后，调用完成处理块并传入这个新内容对象。系统会把新内容整合到通知中并传递给用户。 系统仅提供有限的时间来修改和调用完成处理块，所以你应该快速完成所有任务。如果在 didReceiveNotificationRequest:withContentHandler: 方法中花费了太多时间导致没有调用完成处理块，系统会调用 serviceExtensionTimeWillExpire 方法给你一个最后的机会来完成修改。如果没有及时调用完成处理块，系统会显示原来的通知内容。 由服务器发送的远程通知应该精心处理，以便支持通知服务应用扩展去修改。没有处理过的通知会直接传递给用户。当创建远程通知的负载时，服务器应该做以下事情： 包含名为 ‘mutable-content’，值为 1 的键值对 包含 alert 字典（字典中有 title 和 body 两个子键） 更多有关实现通知服务应用扩展的方法的信息，请看 UNNotificationServiceExtension Class Reference。有关配置远程通知负载的信息，请看 Creating the Remote Notification Payload。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:5:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"在 iOS 上使用自定义界面展示通知 使用 通知内容应用扩展 来为通知显示自定义的用户界面。使用这类扩展来嵌入自定义内容或者使用与默认界面不同的布局。例如，你可能会使用这类扩展来在通知中显示图片或媒体文件。 通知内容应用扩展支持显示与指定分类关联的本地和远程通知。使用 UNNotificationContent 对象的 categoryIdentifier 属性给本地通知指定分类。对于远程通知，服务器会给负载的 aps 字典中的名为 category 键一个合适的值。当该分类的通知到来时，系统会从扩展中加载视图控制器并在系统界面中嵌入你的内容。在视图控制器显示到屏幕之前，使用通知内容来配置它。 给 iOS 应用添加通知内容应用扩展 在 Xcode 中选择 New \u003e Target 来添加一个新 target 到工程中 在 iOS \u003e Application Extension 选项中，选择 Notification Content Extension target 点击 Next 指定扩展名和其它详细内容 点击 Finish Xcode 会添加一个预先配置好的 target 到工程中。 新建的通知内容应用扩展 target 是为了显示与单一分类关联的通知而配置的。必须修改 target 来指定每个扩展想要支持的分类。使用 target 的 Info.plist 文件中 UNNotificationExtensionCategory 键来指定分类。把这个值设置成在应用启动时注册的 UNNotificationCategory 对象的 identifier 属性的值。 在应用扩展中支持多个通知分类 选中通知内容扩展工程的 Info.plist 文件 展开 NSExtension 字典查看与扩展相关的键 展开 NSExtensionAttributes 字典 把 UNNotificationExtensionCategory 键的值的类型修改为 Array 为扩展处理的通知分类添加一个条目 在 iOS 的应用包中可能包含多个通知内容应用扩展。系统希望一个给定的分类仅由一个扩展来支持，所以必须给每个扩展的 UNNotificationExtensionCategory 键配置不同的一组值。 更多有关实现通知内容应用扩展的信息，请看 UNNotificationContentExtension Protocol Reference。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:5:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"在 watchOS 上使用自定义界面展示通知 WatchKit 框架支持使用自定义界面展示通知。当通知抵达应用时，一个 WatchKit 扩展可能包含一个或更多的通知界面控制器来显示通知。可以使用这些界面控制器来展示通知的内容。有关如何实现通知界面控制器的信息，请看 App Programming Guide for watchOS。 苹果推送通知服务 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:5:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"苹果推送通知服务概览 Apple Push Notification service(苹果推送通知服务，简称 APNs)是远程通知功能的中枢。这是一个健壮的、安全的、高效的服务，用来帮助开发者传送信息到 iOS（间接传给 watchOS）、tvOS 和 macOS 设备。 当应用在用户的设备上初次启动时，系统会自动为应用建立一条到 APNs 的可信任的、加密的 IP 长连接。这条连接允许应用执行准备工作来让它能够接收通知，正如 Configuring Remote Notification Support 描述的那样。 发送通知的连接的另一半是提供者服务器与 APNs 之间安全的长连接通道。这需要在线上 开发者账户 中配置和使用苹果提供的密码证书。提供者是开发者部署和管理的服务器，经过配置之后用来和 APNs 一起工作。图 6-1 展示了一个远程通知的传递路径。 图 6-1 从提供者传递一条远程通知到应用 在提供者上和应用中做好推送通知的准备工作后，提供者可以向 APNs 发出通知请求，APNs 再把相应的通知负载转达给每一台目标设备。当系统收到通知时，系统会把负载传递给设备中合适的应用并管理与用户的交互。 如果通知到来时设备已开机但应用没有在运行状态，系统仍然可以显示通知。如果 APNs 发送通知时设备已关机，APNs 会保留通知并在稍后重发（详细内容，请看 Quality of Service, Store-and-Forward, and Coalesced Notifications）。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:6:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"提供者的职责 为了参与 APNs，提供者有以下职责： 通过 APNs 接收全局唯一的、应用特有的设备令牌，接收来自应用实例的其它相关数据。这使得提供者清楚每一个运行的应用实例。 根据通知系统的设计来判定何时需要往设备发送通知。 创建并发送通知请求（每一个请求都包含通知负载和传递的信息）到 APNs，然后 APNs 代你把相应的通知传递给预期设备。 提供者发送的每一个远程通知请求必须： 构造一个包含通知负载的 JSON 字典，如 Creating the Remote Notification Payload 所描述。 把负载、全局唯一设备令牌和其它递送信息添加到一个 HTTP/2 请求中。有关设备令牌的信息，请看 APNs-to-Device Connection Trust and Device Tokens。有关 HTTP/2 请求的格式的信息和来自 APNs 的可能响应和错误，请看 Communicating with APNs。 通过一条安全的长连接通道发送 HTTP/2 请求到 APNs，请求包含令牌形式的密码凭证或者证书。建立安全通道在 Security Architecture 有讲解。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:6:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"使用多个提供者 图 6-2 描述了 APNs 为应用运行启用的虚拟网络的分类。为了处理加载的通知，通常会部署多个提供者（每一个都有一条到 APNs 的安全长连接）。然后，提供者就可以发送请求到目标设备（提供者拥有的有效设备令牌对应的设备）。 图 6-2 从多个提供者推送远程通知到多个设备 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:6:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"服务的质量、保存和转发、合并通知 苹果推送通知服务包含一个服务质量（Qulity of Service 简称 QoS）组件，该组件有保存和转发的功能。如果 APNs 试图发通知而此时目标设备处于离线状态，APNs 会保存通知一段有限时间并在设备上线时传递出去。这组件仅为一台设备的一个应用保留最近的通知。如果设备不在线，那么往这台设备发送通知请求会导致先前的请求被丢弃。如果设备长时间不在线，那么所有在 APNs 中保存的通知都会被丢弃。 要想允许合并类似的通知，你可以在通知的请求中包含 collapse 标识符。通常，当设备在线时，往 APNs 发送的通知请求都会传递到设备上。然而，当 apns-collapse-id 键出现在 HTTP/2 请求头中时，APNs 会合并该键的值相同的请求。例如，一个新闻服务发送了两次同样的头条，可以给这两个请求使用同样的合并标识符。然后，APNs 会把这两个请求合并到一个通知中发送给设备。关于 apns-collapse-id 键的细节，请看 表 8-2。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:6:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"安全体系结构 APNs 使用信任的 2 个层级(connection trust 连接信任和 device token trust 设备令牌信任)来加强端到端的密码验证和认证。 Connection trust 在提供者和 APNs 之间、APNs 和设备之间工作。 提供者到 APNs 的连接信任 建立确定性（提供者和 APNs 之间的连接只可能为授权的提供者打开，授权的提供者由与苹果签订有推送通知传递协议的公司拥有）。必须确保在提供者服务器与 APNs 之间存在连接信任，如本章节所描述。 APNs 到设备的连接信任 确保只有授权的设备才能连接到 APNs。APNs 自动加强与每台设备的连接信任以确保设备的合法性。 与 APNs 通信的提供者，必须采用有效的认证秘钥证书（基于令牌的连接信任）或 SSL 证书（基于证书的连接信任）。可在线上 开发者账户 获得这两个证书，正如 Xcode 帮助中心 Configure push notifications 所描述的那样。在两个证书类型中选择哪一个，请看 Provider-to-APNs Connection Trust。无论选择哪种证书，提供者连接信任是提供者发送推送通知请求到 APNs 的先决条件。 Device token trust 在每条远程通知的端到端工作。它确保通知从正确的起点(提供者)路由到正确的终点（设备）。 设备令牌是一个不透明的 NSData 实例，它包含一个苹果为特定设备上的特定应用指定的唯一标识符。只有 APNs 可以解码和读取设备令牌的内容。每个应用在向 APNs 注册时会收到唯一的设备令牌，然后必须把令牌转发给提供者，如 Configuring Remote Notification Support 所描述。提供者必须在每条指向关联设备的推送通知请求中包含设备令牌，APNs 使用设备令牌来确保通知只传递给预期的 应用-设备 唯一组合。 APNs 可能会发布新的设备令牌，由于以下原因： 用户在新设备上安装应用 用户从备份中还原设备 用户重装系统 其它系统定义事件 因此，应用必须在启动时请求设备令牌，如 APNs-to-Device Connection Trust and Device Tokens 所描述的那样。代码示例请看 Registering to Receive Remote Notifications。 重要 为了保护用户的隐私，不要使用设备令牌来识别用户设备。 提供者到 APNs 的连接信任 提供者和 APNs 之间协商连接信任的方案有两种： 基于令牌的连接信任：使用基于 HTTP／2 的 API 的提供者可以使用 JSON web tokens(JWT) 来为与 APNs 的连接提供验证凭证。在这个方案中，公钥提供给苹果保管，私钥由自己保管。然后，提供者使用私钥来生成和签名 JWT 提供者授权令牌。每一个推送消息请求必须包含提供者授权令牌。 可以使用一个单独的基于令牌的连接（在提供者和 APNs 之间）来给所有应用（线上开发者账户 中罗列的 bundle ID 对应的应用）发推送通知请求。 提供者发出的每一个推送通知请求都会收到一个来自 APNs 的 HTTP／2 响应（成功或失败的细节）。 基于证书的提供者连接信任：提供者可以选择采用唯一的提供者证书(provider certificate)和私有密钥(private cryptographic key)。提供者证书由苹果提供（当你在线上 开发者账户 创建推送服务时），它标识一个主题，也是你应用的 bundle ID。 可以在提供者和 APNs 之间使用基于证书的连接来发送通知请求到应用（在线上 开发者账户 配置证书的时候指定的应用）。 重要 想要与 APNs 建立基于 HTTP／2 的 TLS 会话，必须确保提供者上已经安装好 GeoTrust Global CA 根证书。如果提供者运行在 macOS 上，这个根证书默认放在钥匙串中，其它操作系统可能需要显式安装。可以从 GeoTrust Root Certificates website 下载证书，这是传送门 direct link to the certificate。 然而，如果还使用遗留的二进制接口，必须确保每个提供者都有一个 Entrust Certification Authority (2048) 根证书，可向 Entrust SSL Certificates website 购买。 基于令牌的提供者到 APNs 的信任 基于令牌的提供者信任采用 “Apple Push Notification Authentication Key (Sandbox \u0026 Production)” 这类证书。按照 Xcode 帮助文档 “Generate a universal provider token signing key” 使用线上 开发者账户 配置和获得证书。这类证书有以下特点： 证书是有效的，可用来为与账户关联的每个应用发送推送通知请求，也可以为应用建立到 Appple Watch Complications(不好翻译 wikipedia complication 的连接和获取 voice-over-Internet Protocol（VoIP）状态的通知。即使这些应用处于后台，APNs 依然会传递通知。详细请看 APNs Provider Certificates，还有 Energy Efficiency Guide for iOS Apps 中的 Voice Over IP (VoIP) Best Practices。 当通过 JWT 基于令牌的 APNs 连接发送推送通知请求时，必须包含提供者认证令牌 APNs 认证秘钥证书永不过期，但可以使用线上 开发者账户 永久废弃它，一旦废弃，就不能再使用了。 图 6-3 阐述使用基于 HTTP/2 的提供者 API 来建立信任和使用 JWT 提供者认证令牌发送通知。 图 6-3 建立和使用基于令牌的提供者连接信任 如图 6-3 所示，基于令牌的提供者信任工作流程如下： 提供者使用 TLS 请求与 APNs 建立安全连接，如图中注 “TLS initiation” 的箭头所示 APNs 返回 APNs 证书（提供者稍后对其进行校验）给提供者，如图中第二个标注 “APNs certificate” 的箭头所示。此时，连接信任已经建立，提供者可以发送基于令牌的远程通知请求到 APNs。 每一个提供者发送的通知请求必须随 JWT 授权令牌一起发送，如图中标注 “Notification push” 的箭头所示 APNs 回应每一条通知，如图中标注 “HTTP/2 response” 的箭头所示。在这一步中提供者可能收到的响应的相关细节，请看 HTTP/2 Response from APNs。 基于证书的提供者到 APNs 的信任 基于证书的提供者连接是有效的，可用来传递通知到指定应用（由提供者证书中的主题指定，主题为应用的 bundle ID）。提供者证书必须事先创建好，如 Xcode help 中 Generate a universal APNs client SSL certificate 描述。取决于你如何配置和供应证书，受信任的连接可用来传递通知到其它与应用关联的事物，包括 Apple Watch complications 和 VoIP 状态通知。APNs 甚至会在它们处于后台时传递通知。详见 Communicating with APNs，还有 Energy Efficiency Guide for iOS Apps 中的 Voice Over IP (VoIP) Best Practices。 对于基于证书的信任，APNs 会维护一张证书废弃清单，如果提供者的证书在废弃清单上，APNs 可以撤回提供者信任，也就是说，APNs 会拒绝 TLS 初始化连接。 图 6-4 阐述使用苹果签发的 SSL 证书来建立提供者和 APNs 之间的连接。不像 图 6-3，这张图没有展示通知推送部分，而是停在 TLS 连接建立这一步。在基于证书的信任方案中，通知请求没有经过认证但会使用随通知一同发出的设备令牌来验证。 图 6-4 建立基于证书的提供者连接信任 如图 6-4 所示，基于证书的提供者到 APNs 的信任工作流程如下： 提供者使用 TLS 请求与 APNs 建立安全连接，如图中标注为 “TLS initiation” 的箭头所示 APNs 把 APNs 的证书（提供者稍后会进行验证）发给提供者，如图中标注为 “APNs certificate” 的箭头所示 提供者必须把苹果提供的证书发给 APNs。这个证书已事先通过线上 开发者账户 获得，如 Xcode Help Generate a universal APNs client SSL certificate 中描述。如图中标注为 “Provider certificate” 的箭头所示 紧接着 APNs 会验证提供者的证书，从而确认连接请求来自合法的提供者，然后建立 TLS 连接。此时，连接信任已经建立，提供者可以发送基于证书的远程通知请求到 APNs。 APNs 到设备的连接信任和设备令牌 APNs 和每台设备间的信任是自动建立的，不需要应用的参与。 每台设备都有一个密码证书和一个私钥，在设备首次激活的时候由操作系统提供并存放在设备的钥匙串中。在激活的过程中，APNs 基于证书和秘钥认证和验证到设备的连接，如图 6-5 所示。 图 6-5 建立设","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:6:4","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"配置程序 iOS 应用商店、tvOS 应用商店和 macOS 应用商店上的应用都可以使用 APNs，包括企业应用。为了使用 APNs，应用必须进行配置和代码签名。如果你只是团队中的一员，这些配置步骤的大部分只能由团队代理人或者管理员来执行。 关于如何在 Xcode 和线上 开发者账户 中配置推送通知的支持，请看 Xcode Help Configure push notifications。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:6:5","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"创建远程通知负载 每一条提供者发往 APNs 的通知都包含一个负载。负载包含想要发给应用的自定义数据和系统通知用户的方式。把负载做成一个 JSON 字典并把它作为 HTTP/2 消息的主体内容发送出去。负载最大尺寸取决于所发送的通知： 常规的远程通知，最大尺寸是 4KB（4096 字节） VoIP 通知，最大尺寸是 5KB（5120 字节） 注意 如果你使用遗留的 APNs 二进制接口来发送通知，而不是 HTTP/2 请求，那么负载的最大尺寸是 2KB（2048 字节） APNs 会拒绝超过最大允许尺寸的通知负载。 因为通知的传递并没有保障，所以永远不要在负载中加入敏感数据以及可以通过其它方式获取的数据。相反，应该使用通知来提醒用户有新的信息或把它当作信号（应用有数据等着它）。例如，一个邮件应用使用远程通知来显示应用角标或弹框提醒用户指定的账户有新邮件，而不是直接在通知中发送邮件的内容。当收到通知时，应用应当连接到邮件服务器拉取邮件消息。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:7:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"创建 JSON 字典 下面的例子说明了 JSON 字典的结构以及可以在通知负载中使用的键。该负载中最重要的部分是 aps 字典，其中包含苹果定义的键（用来限定系统在收到通知时如何提醒用户）。例子中还包含名为 “acme” 的键，代表虚构应用的自定义数据。例子中包含空格和换行是为了可读性，但是在实践中应该删除空格和换行符以减小负载的尺寸。 例 1. 下面的负载包含一个 aps 字典，字典中有一个简单的提示消息。acme 键包含一个应用特有的数据的数组。 { \"aps\" : { \"alert\" : \"Message received from Bob\" }, \"acme2\" : [ \"bang\", \"whiz\" ] } 例 2. 下面的负载要求系统在显示消息时展示一个关闭按钮和一个动作按钮。title 和 body 键提供消息的内容，“PLAY” 字符串用来从应用的 Localizable.strings 文件中获取本地化字符串，获取到的字符串结果用来当作消息的动作按钮标题。这个负载还要求系统在应用图标上显示角标，数字为 5。 { \"aps\" : { \"alert\" : { \"title\" : \"Game Request\", \"body\" : \"Bob wants to play poker\", \"action-loc-key\" : \"PLAY\" }, \"badge\" : 5 }, \"acme1\" : \"bar\", \"acme2\" : [ \"bang\", \"whiz\" ] } 例 3. 下面的负载规定设备应该显示一个弹框消息，播放声音和显示应用角标 { \"aps\" : { \"alert\" : \"You got your emails.\", \"badge\" : 9, \"sound\" : \"bingbong.aiff\" }, \"acme1\" : \"bar\", \"acme2\" : 42 } 例 4. 下面的负载使用 loc-key 来指定应用的 Localizable.strings 文件中的一个本地化字符串，该字符串被当作弹框的消息来显示，loc-args 包含的值可以在该字符串显示之前组合到该字符中。负载也指定了一个要随消息播放的自定义声音。 { \"aps\" : { \"alert\" : { \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\", \"loc-args\" : [ \"Jenna\", \"Frank\"] }, \"sound\" : \"chime.aiff\" }, \"acme\" : \"foo\" } 完整的苹果指定键（通知负载中可以包含的键）清单，请看 Payload Key Reference。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:7:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"配置后台更新通知 后台更新通知通过这样的方式（周期性的唤醒应用以便在后台刷新数据）来提升用户体验。应用长时间不运行，应用的数据可能已经过时，当用户再次启动应用，过时的数据必须要换掉（这会导致应用的使用被延迟）。后台更新通知可以提醒用户或者安静地出现。 重要 后台更新通知并非一种让应用长期在后台处于唤醒状态的方式（仅限于快速刷新的操作），也不是高优先级的更新。APNs 把它当作一种低优先级的通知，并且如果发送的数量过多可能会被节流。实际的上限是动态的并且根据情况会有所变化，但是不要试图在一小时内发送过多的通知。 需要支持后台更新通知，请确保负载的 aps 字典中包含值为 1 的 content-available 键。如果后台更新中有用户可见的更新，可以在 aps 字典中适当地使用 alert、 sound 和 badge 等键。 当后台更新通知传递到用户设备，iOS 会在后台唤醒应用并给予多达 30s 的时间来运行。在 iOS 中，系统通过调用应用代理方法 application:didReceiveRemoteNotification:fetchCompletionHandler: 来传递后台更新通知。使用该方法来初始化需要的操作以拉取新数据。在后台处理远程通知需要在应用中添加合适的后台模式(background modes)。 配置应用来处理后台更新通知 在工程导航器中选择工程 在编辑器中选择 iOS 应用 target 选中 Capabilities 选项 启用 Background Modes capability 启用 Remote notification background mode 清单 7-1 给出了后台更新通知的 JSON 负载的一个例子 清单 7-1 配置后台更新通知 { \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\", \"acme2\" : 42 } 关于如何处理远程通知的信息，请看 Handling Remote Notifications。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:7:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"给远程通知指定自定义动作 要在远程通知中显示自定义动作，请在通知负载的 aps 字典中包含 category 键。在启动的时候，应用可以注册包含自定义动作的分类。如果通知包含 category 键，系统在横幅或弹框界面中会把分类的动作显示成按钮。当用户选中按钮，系统会通知应用以便执行关联的任务。配置了分类的通知必须也要配置显示弹框。 清单 7-2 演示了显示弹框和包括自定义动作的分类的通知负载。 “NEW_MESSAGE_CATEGORY” 字符串与应用的已注册分类名对应。在这种情况下，分类包含自定义动作以响应消息。 清单 7-2 在负载中包含分类 { \"aps\" : { \"category\" : \"NEW_MESSAGE_CATEGORY\" \"alert\" : { \"body\" : \"Acme message received from Johnny Appleseed\", }, \"badge\" : 3, \"sound\" : “chime.aiff\" }, \"acme-account\" : \"jane.appleseed@apple.com\", \"acme-message\" : \"message123456\" } 关于如何注册应用支持的分类和自定义动作的信息，请看 Configuring Categories and Actionable Notifications。关于处理应用中自定义动作的选择，请看 Responding to the Selection of a Custom Action。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:7:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"本地化远程通知的内容 有两种本地化远程通知内容的方式： 从提供者服务器提供本地化内容 在应用包中储存本地化消息字符串 两种本地化方式都有各自的优点和缺点，应该选择最适合自己需求的技术。从服务器提供本地化内容可以让你指定你想要的任何文本，但这需要你动态地发现和追踪用户的当前语言偏好设置以及潜在地翻译内容。在应用包中储存本地化字符串的方式相对简单些，但需要事先定义好所有的通知消息并放入应用的 Localizable.strings 资源文件中。 为服务器提供用户语言偏好 如果由服务器来处理通知消息的本地化，应用应该向服务器传达用户的语言偏好设置。用户在设备上设置语言偏好，应用可以使用 NSLocale 类的 preferredLanguage 属性来获取这些偏好设置。 清单 7-3 说明了获取当前选中的语言并传送给提供者服务器的技术。这例子获取用户的第一偏好语言并编码为 UTF8 字符串，然后使用自定义方法把字符串发给提供者。你可能会考虑发送从 preferredLanguage 属性获取的少数第一语言以免用户的第一语言不是你支持的那种。如果不支持用户的偏好语言，可以考虑把像英语或者西班牙语这类广泛使用的语言当作备选方案。 清单 7-3 获取当前支持的语言并发送给提供者 NSString *preferredLang = [[NSLocale preferredLanguages] objectAtIndex:0]; const char *langStr = [preferredLang UTF8String]; [self sendProviderCurrentLanguage:langStr]; // custom method } 因为用户可能会修改偏好语言设置，所以应用应当观察 NSCurrentLocaleDidChangeNotification 通知。使用该通知来发送语言相关的变化到服务器。 在应用包中储存本地化内容 如果通知使用一组一致的消息，你可以在应用包中保存消息文本的本地化版本并使用负载中的 loc-key 和 loc-args 键来指定要显示的消息。loc-key 和 loc-args 键定义通知的消息内容。当通知呈现，本地系统会在 Localizable.strings 文件中查找与 loc-key 键的值相匹配键字符串，然后使用来自字符串文件的相应值作为消息文本的基点，并使用 loc-args 键指定的字符串替换占位值（也可以使用 title-loc-key 和 title-loc-args 键来为通知指定标题）。 为了说明如何使用这些键，细想一个游戏应用的例子，该应用在用户受邀时发送通知。因为邀请的文本不会改变，所以文本被包含在应用的 Localizable.strings 文件中，使用以下条目： \"GAME_PLAY_REQUEST_FORMAT\" = \"%@ and %@ have invited you to play Monopoly\"; 当提供者服务器想要发送一个有关游戏的通知请求时，它会使用 loc-key 和 loc-args 键来创建负载。它把 loc-key 的值设置为 GAME_PLAY_REQUEST_FORMAT 字符串，把 loc-args 值设置为参与者的名字，以此来初始化一个玩游戏的请求。例如，初始化两个用户名为 “Jenna” 和 “Frank” 的请求，提供者服务器会发送包含以下内容的负载： { \"aps\" : { \"alert\" : { \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\", \"loc-args\" : [ \"Jenna\", \"Frank\"] } } } 当收到包含以上负载的通知时，设备会从合适的应用 Localizable.strings 文件中拉取 GAME_PLAY_REQUEST_FORMAT 字符串，然后合入提供的玩家名称。对于一个偏好语言为英语的用户，消息字符串的结果会变成 “Jenna and Frank have invited you to play Monopoly.”。对于其他语言，该字符串会变成消息的其它翻译版本（合并提供的玩家名称）。 当为 Localizable.strings 制作消息字符串时，可以使用的格式说明符与用在本地内容的相同。例如，可以使用 %n$@ 形式的位置说明符来允许重排参数，可以使用 %% 说明符来创建一个百分号字母。 有关在通知负载中可以包含的键的额外信息，请看 Payload Key Reference。更多有关国际化和为应用提供本地化内容的信息，请看 Internationalization and Localization Guide。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:7:4","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"与 APNs 通信 APNs 提供者 API 让你可以发送远程通知请求到 APNs，然后 APNs 把通知传达给 iOS、tvOS、macOS 设备上的应用以及 Apple Watch（通过 iOS）。 提供者 API 基于 HTTP/2 网络协议，每一个交互都以发自提供者的 POST 请求开始，该请求包含一个 JSON 负载和一个设备令牌。APNs 把通知负载转发给指定应用设备上的应用（由请求中包含的设备令牌来识别）。 提供者是服务器，由你部署、管理并配置以和 APNs 一起工作的服务器。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:8:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"提供者认证令牌 为了安全地连接到 APNs，可以使用提供者认证令牌或提供者证书。这节讲述使用令牌的连接。 提供者 API 支持 JSON Web Token（JWT）规范，可以连同每条推送通知一起传递表达式和元数据（声明）到 APNs。详细请参考规范 https://tools.ietf.org/html/rfc7519。关于 JWT 的额外信息，连同生成签名 JWTs 的可用库的清单，请看 https://jwt.io。 提供者认证令牌是你构造的 JSON 对象，它的头部必须包括： 用来加密令牌的加密算法 （alg） 一个 10 个字母的秘钥标识（kid）键，从 你的开发者账户 获取 令牌的声明负载必须包括： 注册声明键 issuer (iss)，值为 10 个字母的团队 ID，从 你的开发者账户 获取 注册声明键 issued at (iat)，值表示令牌生成的时间，按照从 Epoch （1970-01-01 00:00:00）开始到现在经过的秒数， UTC 格式。 创建令牌之后，必须使用私钥签名。然后使用 P-256 曲线的椭圆曲线数字签名算法（ECDSA）和 SHA-256 哈希算法加密令牌。在算法头部键（alg）中指定值 ES256 。关于如何配置令牌的信息，请看 Xcode Help Configure push notifications。 一个已解密的 JWT 提供者认证令牌有以下格式： { \"alg\": \"ES256\", \"kid\": \"ABC123DEFG\" } { \"iss\": \"DEF123GHIJ\", \"iat\": 1437179036 } 注意 APNs 仅支持使用 ES256 算法签名的提供者认证令牌。不安全的或者使用其它算法签名的 JWTs 会被拒绝，提供者会收到 InvalidProviderToken(403) 响应。 为了确保安全性，APNs 要求定期地生成新的令牌。新的令牌拥有新的 issued at 声明键，它的值表明令牌生成的时间。如果令牌发布的时间戳不在此前一小时以内，APNs 会拒绝后续的推送消息，返回一个 ExpiredProviderToken(403) 错误。 如果怀疑提供者的令牌签名秘钥被泄漏，可以从 你的开发者账户 废弃它。可以发行一个新的秘钥对然后使用新的私钥来生成新的令牌。为了最高安全性，关闭所有到 APNs 的连接（使用当前已废弃秘钥签名的令牌的连接），在用新的秘钥签名令牌之后才去重连。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:8:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"APNs 提供者证书 提供者证书（按照 Xcode Help 中 Configure push notifications 的讲解去获取），能够连接到 APNs 生产和开发环境中。 可使用 APNs 证书发送通知到主应用（由它的 bundle ID 识别），也可以发送到与应用关联的任何 Apple Watch complications 或者后台 VoIP 服务。使用证书中的 ( 1.2.840.113635.100.6.3.6 ) 扩展来为推送通知识别主题。例如，如果你提供一个 bundle ID 为 com.yourcompany.yourexampleapp 的应用，你可以在证书中指定以下的主题： Extension ( 1.2.840.113635.100.6.3.6 ) Critical NO Data com.yourcompany.yourexampleapp Data app Data com.yourcompany.yourexampleapp.voip Data voip Data com.yourcompany.yourexampleapp.complication Data complication ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:8:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"APNs 连接 发送远程通知的第一步，建立一条到适当的 APNs 服务器的连接： 开发服务器：api.development.push.apple.com:443 生产服务器：api.push.apple.com:443 注意 当与 APNs 通信时，可以选择使用 2197 端口。你也许会用到这个端口，例如，为了允许 APNs 流量通过防火墙但阻止其它 HTTPS 流量。 当连接到 APNs 时，提供者必须支持 TLS 1.2 或更高版本。可以使用提供者客户端证书（从 你的开发者账户 获取的），就像 Creating a Universal Push Notification Client SSL Certificate 描述的那样。 为了不使用 APNs 提供者证书进行连接，你必须创建提供者认证令牌（通过 你的开发者账户 发布的秘钥签名的令牌，请看 Xcode Help 中的 “Configure push notifications”）。在拿到这个令牌之后，就可以开始发送推送消息了。之后你必须定期地更新令牌，每一个 APNs 提供者认证令牌都有为期一小时的有效期。 APNs 允许每条连接有多个并发流。流的具体数目根据使用的提供者证书或认证令牌有所不同，根据不同的服务器负载也会有所不同。不要假定流的具体数目。 当使用令牌而不是证书来建立到 APNs 的连接时，连接上只允许一个流直到使用有效的提供者认证令牌发送推送消息。APNs 忽略 HTTP/2 PRIORITY 帧，所以不要在流上发送这些帧。 管理连接的最佳实践 在多个通知中保持到 APNs 的连接为打开状态，不要反复地打开和关闭连接。APNs 把快速的打开和断开连接当成拒绝服务攻击。应该让连接保持打开状态除非你知道它在接下来的一段时间内会空转。例如，如果一天仅给用户发送一次通知，那么每天使用一个新的连接是可以接受的。 不要为每条发送的推送请求生成新的提供者认证令牌。在获得令牌之后，在令牌的有效期内（整整一小时）继续用在所有推送请求上。 可以建立多条到 APNs 服务器的连接来提升性能。当发送大量的远程通知时，通过连接把它们分发到多个服务器终端上。与使用单条连接相比，这可以提升性能（通过让你更快地发送远程通知和让 APNs 更快的分发通知）。 如果提供者证书被废弃了，或者正在使用的用来签名提供者令牌的秘钥被废弃了，那么关闭所有到 APNs 的现有连接然后打开新连接。 可以使用 HTTP/2 PING 帧来检测连接的健康状况。 终止 APNs 连接 如果 APNs 决定终止一条 HTTP/2 连接，它会发送 GOAWAY 帧。GOAWAY 帧的负载的 JSON 数据中包含一个 reason 键，该键的值表明连接终止的原因。reason 键可能的取值请看 表 8-6。 正常的请求失败不会导致连接的终止。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:8:3","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"APNs 通知 API APNs 提供者 API 由使用 HTTP/2 POST 命令配置和发送的请求和响应组成。使用请求来发送推送通知到 APNs 服务器并使用响应来判定该请求的结果。 到 APNs 的 HTTP/2 请求 使用请求来发送通知到指定用户设备。 表 8-1 HTTP/2 请求域 Name Value :method POST :path /3/device/ 参数，为目标设备指定十六进制字节的设备令牌。 APNs 需要使用 HPACK（HTTP/2 头部压缩），它可以避免重复的头部键和值。APNs 为 HPACK 维护一张小动态表。为了避免塞满 APNs HPACK 表和迫使表数据的丢弃，按照以下方式来编码头部（尤其是在发送大量流时）： :path 应该编码成没有索引的字面量头部域 auhorization 请求头，如果有，应该编码成没有索引的字面量头部域 适合 apns-id、apns-expiration、apns-collapse-id 请求头采用的编码会有所区别，取决于它是初次还是后续 POST 请求操作的一部分。如下： 首次发送这些头部时，使用增量索引的方式编码以允许头部名称加到动态表中 后续发送这些头部时，编码成没有索引的字面量头部域 把其它头部编码成没有索引的字面量头部域。关于头部编码的细节，请看 tools.ietf.org/html/rfc7541#section-6.2.1 和 tools.ietf.org/html/rfc7541#section-6.2.2。 APNs 会忽略除了表 8-2 中列出的请求头之外的请求头。 表 8-2 APNs 请求头 头部 描述 authorization 授权 APNs 为特定主题发送推送通知的提供者令牌。令牌是 Base64URL-encoded JWT 格式，指定成 bearer \u003cprovider token\u003e。当使用提供者证书来建立连接，这个请求头被忽略 apns-id 用来识别通知的标准的 UUID，如果发送通知出现错误，APNs 使用这个值来向服务器指出该通知。标准形式是 32 个小写字母 16 进制数字，使用连字符分 5 组以 “8-4-4-4-12” 的形式显示。一个 UUID 的例子：123e4567-e89b-12d3-a456-42665544000。如果省略这个头部，APNs 会创建一个新的 UUID 并在响应中返回 apns-expiration 一个以秒来表示的 UNIX Epoch 日期（UTC）。这个头部表示通知失效并可以被丢弃的日期。如果值不为 0，APNs 会保存通知并至少尝试去传送一次通知，如果首次传送失败它会根据需要重复尝试。如果值为 0，通知会被 APNs 视为马上过期并且不会再保存通知或者尝试传送 apns-priority 通知的优先级。指定以下值中的一个： * 10-马上发送推送消息。这种优先级的通知必须出发一个弹框、声音或者目标设备的角标。在包含 content-available 键的推送通知中使用这个优先级是错误的用法。 * 5-推送消息的发送时间会考虑设备的电量。这种优先级的通知可能会被合并然后一起发射出去，它们会被节流，在某些情况下不会传送。如果省略这个头部，APNs 服务器会把优先级设置为 10。 apns-topic 远程通知的主题，通常是应用的 bundle ID。在开发者账户中创建的证书必须为这个主题包含能力（capability）。如果证书包含多个主题，必须给这个头部指定一个值。如果省略这个请求头部并且 APNs 证书中没有指定多个主题，APNs 服务器会把证书的主题当作默认主题如果使用的是提供者令牌而不是证书，必须给这个请求头部指定一个值。你提供的主题应该满足开发者账户中的团队名的需要。 apns-collapse-id 拥有相同合并标识符的多个通知会被当做一条单一通知显示给用户。这个键的值必须不能超过 64 字节，更多信息，请看 Quality of Service, Store-and-Forward, and Coalesced Notifications。 消息的主体内容是通知负载的 JSON 字典对象。主体数据必须压缩并且最大尺寸为 4KB（4096 字节）。对于 VoIP 通知，主体数据最大的尺寸是 5KB（5120 字节）。关于主体内容中的键与值的信息，请看 Payload Key Reference。 来自 APNs 的 HTTP／2 响应 表 8-3 列举了请求的响应格式 表 8-3 APNs 响应头部 头部名 值 apns-id 来自请求的 apns-id 值，如果请求中没有包含该值，服务器会创建一个新的 UUID 并在这个头部中返回 :status HTTP 状态码，状态码的清单请看 表 8-4 表 8-4 列举了一个请求的可能状态码。这些值会包含在响应的 :status 头部中。 表 8-4 APNs 响应的状态码 状态码 描述 200 成功 400 错误请求 403 证书或者提供者认证令牌有错误 405 请求使用错误的 :method 值。仅支持 POST 请求 410 设备令牌对该主题来说不再有效 413 通知负载过大 429 服务器收到太多同一设备令牌的请求 500 服务器内部错误 503 服务器关闭并且不可用 请求成功，响应的主体为空。请求失败，响应的主体会包含一个 JSON 字典（其中包含表 8-5 中列出的键）。当连接终止时，这个 JSON 数据可能会出现在 GOAWAY 帧中。 表 8-5 APNs JSON 数据键 键 描述 reason 失败的原因。错误码被声明为一个字符串。可能的取值清单，请看表 8-6 timestamp 如果 :status 头部的值为 410，那么这个键的值为 APNs 上一次确认设备令牌对该主题失效的时间。停止推送通知直到设备向提供者注册一个更迟时间戳的令牌。 表 8-6 列举了响应的 JSON 负载中 reason 键可能包含的错误码。 表 8-6 APNs JSON 的 reason 键的值 状态码 错误字符串 描述 400 BadCollapseId 合并标识符超过最大允许尺寸 400 BadDeviceToken 指定的设备令牌错误。请确认请求包含一个有效的令牌并且该令牌与环境匹配 400 BadExpirationDate apns-expiration 的值有误 400 BadMessageId apns-id 的值有误 400 BadPriority apns-priority 的值有误 400 BadTopic apns-topic失效 400 DeviceTokenNotForTopic 设备令牌与指定的主题不匹配 400 DuplicateHeaders 有一个或多个头部重复 400 IdleTimeout 空闲超时 400 MissingDeviceToken 请求的 :path 中没有指定设备令牌。请确认 :path 头部包含设备令牌 400 MissingTopic 请求的 apns-topic 头部未指定，需要指定。在客户端使用支持多个主题的证书进行连接时，apns-topic 头部是必须的 400 PayloadEmpty 消息负载为空 400 TopicDisallowed 不允许推送通知到本主题 403 BadCertificate 证书错误 403 BadCertificateEnvironment 客户端证书与环境不匹配 403 ExpiredProviderToken 提供者令牌过期了需要生成新的 403 Forbidden 指定的动作没有得到允许 403 InvalidProviderToken 提供者令牌失效或者令牌签名无法验证 403 MissingProviderToken 没有使用证书来连接到 APNs 并且 Authorization 头部缺失（或者没有指定提供者令牌） 404 BadPath 请求包含一个错误的 :path 值 405 MethodNotAllowed 指定的 :method 不是 POST 410 Unregistered 设备令牌对指定的主题无效。预期的 HTTP/2 状态码为 410，请看表 8-4 413 PayloadTooLarge 消息负载过大，请看关于最大负载尺寸的细节 Creating the Remote Notification Payload 429 TooManyProviderTokenUpdates 提供者令牌更新太频繁 429 TooManyRequests 连续给同一设备令牌发出太多请求 500 InternalServerError 出现服务器内部错误 503 ServiceUnavailable 服务不可用 503 Shutdown 服务器已关闭 APNs 的 HTTP/2 请求及响应的例子 清单 8-1 演示了一个为提供者证书构造的请求的例子 清单 8-1 单个主题的证书的请求示例 HEADERS - END_STREAM + END_HEADERS :method = POST :scheme = https :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0 host = api.development.push.apple.com apns-id = eabeae54-14a8-11e5-b60b-1697f925","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:8:4","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"负载的键参考目录 每条通知提供一个负载（负载中有应用特有信息和有关如何传递通知给用户的细节）。负载是在服务器上创建的 JSON 字典对象（定义 RFC 4627）。JSON 字典对象必须包含 aps 键，它的值是一个字典（包含系统用来传递通知的数据）。aps 字典的主要内容决定系统是否做以下的事情： 显示提示消息给用户 给应用图标显示角标 播放一段声音 静默地传递通知 除了 aps 字典，JSON 字典可以包含应用特有内容的自定义键值。自定义值必须使用 JSON 结构并且只能使用基本数据类型，例如：字典（对象）、数组、字符串、数字和布尔类型。不要在负载中包含客户的信息或任何敏感数据，除非数据经过加密或者数据在应用之外是无用的。例如，一个即时通讯应用可以包含会话标识，之后可以用来找出相应的用户会话。通知的数据永远不该有破坏性，也就是说，应用永远不该使用通知来删除用户设备上的数据。 当使用基于 HTTP/2 的 APNs 提供者 API 时，最大的 JSON 字典尺寸是 4KB。对于遗留的 API，负载的最大尺寸较小。 关于如何创建负载的信息及例子，请看 Creating the Remote Notification Payload。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:9:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"APS 字典键 aps 字典包含苹果用来传递通知到用户设备的键。键指定了在提醒用户时想让系统使用的交互类型。表 9-1 列举了字典中包含的键与每一个键的类型。aps 字典中其它的键会被苹果忽略。 表 9-1 aps字典的键和值 键 值类型 注解 alert Dictionary or String 当你想让系统显示标准的弹框或横幅时，包含这个键。应用的通知设置决定了弹框或横幅是否显示。这个键的推荐值为一个字典，字典的键在表 9-2列出。如果给这个键指定一个字符串的值，该字符串会被当做弹框或横幅的消息文本显示。不支持 JSON \\u 符号，改为在提示文本中放入实际的 UTF-8 字母 badge Number 当想让系统修改应用图标的角标时包含这个键。如果字典中不含这个键，角标不变。要移除角标，把这个键的值设置为 0。 sound String 当想让系统播放音频时包含这个键。这个键的值为应用 main bundle 中或应用数据容器的 Library/Sounds 文件夹中的音频文件名。如果无法找到音频文件或者该值指定为 default，系统会播放默认的提示音。关于为通知提供音频文件的细节，请看Preparing Custom Alert Sounds。 content-available Number 包含这个键（值为 1）以配置后台更新通知。当这个键出现，系统在后台唤醒你的应用并传递通知到应用的代理。关于配置和处理后台更新通知的信息，请看Configuring a Background Update Notification。 category String 为这个键提供一个字符串值代表通知的类型。这个值与应用已注册分类中的某个分类的 identifier 属性的值相对应。了解更多使用自定义动作的信息，请看Configuring Categories and Actionable Notifications。 thread-id String 为这个键提供一个字符串值代表用来给通知分组的应用特有的标识符。如果提供通知内容应用扩展，可以使用这个值来把通知合并到一起。对于本地通知来说，这个键与 UNNotificationContent 对象的 threadIdentifier 属性相对应。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:9:1","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"弹框提示的键 表 9-2 列举了 alert 字典的键和预期的值 表 9-2 alert 属性的子属性 键 值类型 注解 title String 用来描述通知目的的短字符串。Apple Watch 把这个字符串当作通知界面的一部分来显示。这个字符串仅仅短暂地显示，因而应当精心制作以便可以被快速理解。这个键是在 iOS 8.2 添加的。 body String 提示消息的文本 title-loc-key String or null 当前本地化 Localizable.strings 文件的标题字符串的键。这个键的字符串可以使用 %@ 和 %n$@ 说明符来格式化以获取在 title-loc-args 数组中指定的变量。更多信息请看Localizing the Content of Your Remote Notifications。这个键是在 iOS 8.2 添加的。 title-loc-args Array of strings or null 变量字符串的值用来替换 title-loc-key 中的格式说明符。更多信息请看Localizing the Content of Your Remote Notifications。这个键是在 iOS 8.2 添加的。 action-loc-key String or null 如果为这个键指定字符串，系统会显示包含 “Close” 和 “View” 按钮的弹框。这个字符串会被当成键来从当前本地化中获取本地化字符串，然后用来当做右按钮的标题而不是“View”。更多信息请看 Localizing the Content of Your Remote Notifications。 loc-key String 当前本地化 Localizable.strings 文件的提示消息字符串的键（由用户语言偏好设置）。这个键的字符串可以使用 %@ 和 %n$@ 说明符来格式化以获取在 loc-args 数组中指定的变量。更多信息请看 Localizing the Content of Your Remote Notifications。 loc-args Array of strings 变量字符串的值用来替换 loc-key 中的格式说明符。更多信息请看 Localizing the Content of Your Remote Notifications。 launch-image String 应用包中的图片文件名（包含或不含文件扩展名）。当用户点击动作按钮或者移动动作滑动条时这张图片用来当做启动图。如果这个属性没有指定，系统要么使用之前的截图要么使用 Info.plist 文件中的 UILaunchImageFile 键所指定图片，或者用回 Default.png。 遗留信息 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:9:2","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"二进制提供者 API 遗留的二进制接口需要提供者服务器采用本附录所描述的二进制 API。所有的开发者都应当把远程通知提供者服务器迁移到 Communicating with APNs 中所描述的更给力的更高效基于 HTTP/2 的 API。 官方不推荐使用，此节不翻译，有需要请移步官方文档。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:10:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["iOS","翻译"],"content":"遗留的通知格式 新的开发应当使用现代格式来连接到 APNs，正如 Communicating with APNs 中所描述。 官方不推荐使用，此节不翻译，有需要请移步官方文档。 ","date":"2017-11-27","objectID":"/ios-local-and-remote-notification-programming-guide/:11:0","tags":["iOS","Notification"],"title":"Local and Remote Notification Programming Guide 译文","uri":"/ios-local-and-remote-notification-programming-guide/"},{"categories":["读书笔记"],"content":"最近为了学习 Android，找从事 Android 开发的朋友推荐些书，最后他推荐了《第一行代码》（第 2 版）和《Android 开发艺术探索》两本书。本文是在阅读了《第一行代码》之后所做的笔记，主要记录 Android 平台上的一些比较有趣的特性以及它和 iOS 的不同之处。 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:0:0","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"Android 全貌 2008 年 9 月，Google 正式发布 Android 1.0 系统 2014 年 Google I/O 大会上发布号称史上版本改动最大的 Android 5.0 系统，这版本使用 ART 运行环境替换 Dalvik 虚拟机，同时推出 Wear、Auto、TV 系统 2016 年 Google I/O 大会推出 Android 7.0，加入多窗口模式 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:1:0","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"Android 系统架构 Android 系统架构分为四层：Linux 内核层、系统运行库层、应用架构层、应用层。 Linux 内核层：主要包含一些硬件的底层驱动。 系统运行库层：包含 C/C++ 的底层支持库，例如：支持 3D 绘图的 OpenGL|ES 库、浏览器内核 Webkit 库和 SQLite 数据库支持库。另外还包含 Android 运行时库。 应用架构层：包含构建应用程序用到的 API，开发人员主要使用这层提供的 API 来构建应用。 应用层：包含手机上安装的应用，联系人、短信等。 Android 系统为开发人员提供了： 四大组件，活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver） 和内容提供器（Content Provider） 系统控件 SQLite 数据库 多媒体，音乐、视频、图片、拍照、闹铃等 地理位置定位 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:1:1","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"Android 开发环境及工具 环境：JDK + Android SDK 工具：Eclipse+ADT 或者 Android Studio 在 Android Studio 中，使用 Gradle 来构建 Android 项目，笔者在 Mac 上安装 Android Studio 工具时联网安装 Gradle 不成功，最后，自己手动下载后导入到工具中。 后来尝试过在 Mac 上使用 Eclipse+ADT 的工具集，但是下载的 ADT 导入不成功，最后放弃使用 Eclipse。 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:1:2","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"Android 工程 Android 系统通过包名来区分不同的应用程序，需要确保报名的唯一性。 Android 的日志打印没有使用 System.out，而是重新设计了一个工具类 android.util.log，该类日志打印分级比较细，分为 verbose、debug、info、warn、error 5 个等级，同时包含打印时间、过滤等功能。 gradle 相关文件，通过修改这些 gradle 配置文件可以编译出不同的安装包 代码混淆规则文件 proguard-rules.pro，指定代码混淆规则，增加破解安装包的人阅读代码的难度 逻辑与视图分离的设计，布局文件和 Activity 文件分开 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:1:3","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"Android UI 界面 Android UI 界面的编写可以使用可视化编辑器或者使用 XML 代码。 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:2:0","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"常用控件 TextView 用来显示一段文本。 Button 点击事件通过注册监听器来处理 系统默认对 Button 中的所有英文字母自动进行大写转换，可以使用 android:textAllCaps=\"false\" 来禁用这一默认属性 EditText 文本输入框。 ImageView 用来显示图片。Nine-Patch 图片可以指定图片拉伸区域，通过 sdk 中的 draw8patch.bat 文件可以生成 Nine-Patch 文件。 ProgressBar 进度条。有圆形进度条和水平进度条两种，可以通过样式来指定。 AlertDialog 确认的对话框。用来提示非常重要的内容或者警告信息，让用户再次确认。会在界面中置顶，并屏蔽其它控件的交互能力。 ProgressDialog 会在对话框中显示一个进度条，用来提示用户等待耗时操作。会在界面中置顶，并屏蔽其它控件的交互能力。 ListView 列表视图控件，当界面上条目较多时使用。（类似 iOS UITableView） RecycleView 列表视图控件，增强版本的 ListView，弥补了 ListView 的不足之处。 （类似 iOS UICollectionView）。支持横向滚动和瀑布流布局。 列表视图控件的数据都是通过 Adapter 类提供的，该类相当于 MVC 中 ViewModel，Android 通过这个类把这一模式固定下来。ListView 条目的点击事件是通过 ListView 的注册监听器来处理的，没有细化到条目中的子控件，RecycleView 把点击事件处理归到条目中的子控件来处理。 Fragment 碎片（Fragment）是一种可以嵌入在活动当中的 UI 片段，使用碎片可以充分利用大屏幕设备的屏幕空间。碎片有自己的生命周期，可以在程序运行时动态地添加到活动中，通过指定 最小宽度限定符 指定屏幕宽度最小值，以这个值为临界点，大于和小于这个值的设备分别加载不同的布局。 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:2:1","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"UI 布局 Android 中包含 4 种布局： 线性布局（LinearLayout）、相对布局(RelativeLayout)、帧布局(FrameLayout)、百分比布局。布局中放置控件还可以嵌套布局。 LinearLayout：将包含的控件在线性方向上依次排列。 android:layout_weight 属性允许按比例的方式来指定控件的大小（单位 dp）。系统会把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，每个空间所占的大小比例就是该控件的 layout_weight 的值除以刚才算出的总值。 RelativeLayout：以相对定位的方式来排列控件。 百分比布局：直接指定控件在布局中所占的百分比。包含 PercentFrameLayout 和 PercentRelativeLayout。 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:2:2","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"四大组件 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:3:0","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"活动 待续 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:3:1","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"广播接收器 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:3:2","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"服务 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:3:3","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["读书笔记"],"content":"内容提供器 ","date":"2017-10-14","objectID":"/android-first-line-code-note/:3:4","tags":["读书笔记","Android"],"title":"《第一行代码》","uri":"/android-first-line-code-note/"},{"categories":["iOS"],"content":" 在代理方法中拦截协议 使用 JavaScriptCore WKWebView 的 WKScriptMessagehandler 使用 NSURLProtocol 拦截请求 使用第三方库 WebViewJavascriptBridge 使用 WebSocket 这里只介绍第 6 种，其它的相关资料网上有很多。 使用 WebSocket 的方式需要在应用内起一个 websocket server 服务（有很多第三方的 websocket server 库），html 页面通过 Websocket 连接到服务，接着就是发送消息了，剩下的就跟代理方法拦截协议类似。 // OC code, 以 PocketSocket 这个库为例 _socketServer = [PSWebSocketServer serverWithHost:nil port:9001]; _socketServer.delegate = self; _socketServer.delegateQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); [_socketServer start]; #pragma mark - PSWebSocketServerDelegate - (void)serverDidStart:(PSWebSocketServer *)server { NSLog(@\"Server did start…\"); } - (void)serverDidStop:(PSWebSocketServer *)server { NSLog(@\"Server did stop…\"); } - (BOOL)server:(PSWebSocketServer *)server acceptWebSocketWithRequest:(NSURLRequest *)request { NSLog(@\"Server should accept request: %@\", request); return YES; } - (void)server:(PSWebSocketServer *)server webSocket:(PSWebSocket *)webSocket didReceiveMessage:(id)message { // 在这里拦截 NSLog(@\"Server websocket did receive message: %@\", message); NSString *text = message; NSURL *url = [NSURL URLWithString:text]; if ([url.scheme isEqualToString:@\"camera\"]) { ...... } } - (void)server:(PSWebSocketServer *)server webSocketDidOpen:(PSWebSocket *)webSocket { NSLog(@\"Server websocket did open\"); } - (void)server:(PSWebSocketServer *)server didFailWithError:(NSError *)error { NSLog(@\"Server did fail with error: %@\", error); } - (void)server:(PSWebSocketServer *)server webSocket:(PSWebSocket *)webSocket didCloseWithCode:(NSInteger)code reason:(NSString *)reason wasClean:(BOOL)wasClean { NSLog(@\"Server websocket did close with code: %@, reason: %@, wasClean: %@\", @(code), reason, @(wasClean)); } - (void)server:(PSWebSocketServer *)server webSocket:(PSWebSocket *)webSocket didFailWithError:(NSError *)error { NSLog(@\"Server websocket did fail with error: %@\", error); } // JS code var wsServer = 'ws://localhost:9001'; var websocket = new WebSocket(wsServer); websocket.onopen = function (evt) { onOpen(evt) }; websocket.onclose = function (evt) { onClose(evt) }; websocket.onmessage = function (evt) { onMessage(evt) }; websocket.onerror = function (evt) { onError(evt) }; function onOpen(evt) { console.log(\"Connected to WebSocket server.\"); } function onClose(evt) { console.log(\"Disconnected\"); } function onMessage(evt) { console.log(\"Recieve data: \" + evt.data); } function onError(evt) { console.log('Error occured: ' + evt.data); } // 发送消息 websocket.send(\"camera://openCamera?index=1\u0026quality=high\u0026callback=callbackFunction); function callbackFunction(data){ } 参考： javascriptcore WKWebView 自定义 NSURLProtocol WebViewJavascriptBridge WebSocket ","date":"2017-06-23","objectID":"/ios-oc-interact-with-js/:0:0","tags":["iOS","JavaScript"],"title":"OC 与 JS 通信的几种方式","uri":"/ios-oc-interact-with-js/"},{"categories":["翻译"],"content":"译自 Three Common Mistakes of the First Time Tech Lead by Patrick Kua Tech Principal and generalising Specialist Don’t miss the author’s earlier post on the 5 Tips for Being an Effective Tech Lead. 别错过作者先前写的关于成为高效技术主管的5个秘诀。 The first time a developer steps into the role of a Tech Lead can be difficult. The skills and experience of a seasoned developer do not automatically translate into the skills necessary for the Tech Lead role. In fact, some of the habits of a developer can do more harm than good, when not applied well and with more authority in this new role. 头一回由开发人员转换到技术主管的角色可能比较困难。开发老手的技能及经验不会自动变成技术主管所需要的技能。事实上，在没有充分用好这个新角色的权利时，开发人员的一些习惯非但无益反而有害。 In this article, we explore three common traps a first time Tech Lead experiences, and what they can do to avoid them. 在这篇文章里，将会探讨技术主管新手会遇到的三个常见陷阱和避开陷阱的做法。 Coding Full-Time A first time Tech Lead will miss writing code. In fact, it is easy for them to assume that they need to demonstrate their leadership by writing code all the time. Although effective Tech Leads need to spend some time writing, reading and reviewing code, other responsibilities are left unfulfilled when they spend too much time writing code, - such as creating a technical vision and ensuring that the team understands key system quality attributes. 整天写代码 技术主管新手很怀念写代码。事实上，他们很容易认为，需要通过不停地写代码来展示他们的领导能力。虽然高效的技术主管也需要花时间写代码、读代码、检查代码，但是当他们花大量时间去写代码时，其它的责任并没有得到落实。比如：创建技术视角并确保团队理解关键系统质量属性。 A lack of technical vision might lead to three different implementations, as developers make decisions individually about what they feel is best, or a deployment might fail because developers are not aware of operational constraints or environmental differences in production. Worse yet is when the code must constantly be reworked because a developer chooses to do something differently without considering maintenance, or how the system may evolve over time. 缺乏技术视角可能会导致三种不同的执行结果，如开发人员单独作出他们觉得最好的决定；或者部署失败，因为开发人员没有知道生产上的运行约束和环境不同点；更有甚者代码必须不断重写，因为开发人员没有考虑到运维或者系统可能会随时间演变，选了一个不同的做法。 The more experienced Tech Lead understands that they must balance their time to code with other responsibilities. They split their time daily, or at the very least weekly, to ensure that they spend time addressing other responsibilities including building a shared architectural vision, identifying and addressing technical risks, being involved in planning sessions and focusing on team and code cohesiveness and consistency. 较老练的技术主管知道必须平衡写代码和其他责任两者间的时间。他们每天抽时间，或者至少每周，来确保花时间去履行其他职责，包括：建立共享技术愿景，识别和定位技术风险，参与规划会议，关注团队和代码内聚力和一致性。 Making all the Technical Decisions 独揽技术决策 A first time Tech Lead may sometimes be the most experienced developer on the team, or feel the pressure to make all the technical decisions to demonstrate their authority or influence. When a Tech Lead is making all the technical decisions, they become a bottleneck in the team and the team cannot progress when the Tech Lead is not around. Other team members might feel demotivated when the Tech Lead makes all the important decisions, because their contributions are overruled and this could lead to resentment. 技术主管新手有时是团队中最熟练的开发人员，还是感受到为了树立威信或影响力而独揽技术决策的压力。技术主管独揽技术决策会成为团队的瓶颈，当技术主管不在时团队无法前进。所有重大决策都由技术主管一手独揽，其他成员也会失去动力，因为他们的贡献被驳回，这可能会导致怨恨。 The more experienced Tech Lead realizes there are different ways of making decisions, and often, the best decision comes from using the breadth of experience and knowledge from the entire team. They might draw upon the following techniques, depending on how critical a decision is, how quick a decision must be made and how much commitment they want from team members: 较老练的技术主管知道有很多做决策的不同方式，通常，最好的决策来源于整个团队的经验和知识的利用。根据决策的重要性、紧迫性以及他们想要团队成员付出多少，他们可能会利用下面的技巧： Only delegating - A Tech Lead gives the decision to someone else without any other interaction Offering advice - A Tech Lead delegates the decision to someone else, but offers their input and opinions for consideration Inquiring - A Tech Lead delegates the decision to someone else, but inquires about the outcome and factors","date":"2016-12-16","objectID":"/three-common-mistakes-of-the-first-time-tech-lead/:0:0","tags":["Management","翻译"],"title":"第一次成为技术主管易犯的3个常见错误","uri":"/three-common-mistakes-of-the-first-time-tech-lead/"},{"categories":["web"],"content":"HTTPS HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。 Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。 SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。 ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:1:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"单向认证 客户端校验服务端证书 client hello 客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。 server hello 服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。 authentication 客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。 send premaster key 客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。 decrypt premaster key 服务端解密 premaster key create session key 客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。 client send finished 客户端使用 session key 加密一条 finished 消息并发送给服务端。 server send finished 服务端使用 session key 加密一条 finished 消息并发送给客户端。 symmetric encrypt communication 使用对称加密来进行通信。 ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:2:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"双向认证 客户端校验服务端证书 + 服务端校验客户端证书 verify certificate(digital signature) 客户端发送一个 CertificateVerify 消息，这是使用客户端证书的私钥对前一个握手消息的签名。这个签名可以通过使用客户端证书的公钥进行验证。这样服务端就知道客户端可以访问证书的私钥，亦即拥有该证书。 ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:3:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"证书校验什么 验数字签名 客户端发送一个“Certificate Verify”消息，其中包含前一个握手消息的数字签名副本。此消息使用客户端证书的私钥进行签名。服务器可以使用客户端的公钥(在客户端证书中找到)来验证数字签名的消息摘要。一旦验证了数字签名，服务器就知道属于客户端的公钥与用于创建签名的私钥相匹配。 验证书链 服务端维护一个受信任的ca列表，该列表决定服务端将接受哪些证书。服务端将使用来自CA证书的公钥(在其可信CA列表中)来验证CA对所提供证书的数字签名。如果消息摘要已经更改，或者公钥与用于签名证书的CA私钥不对应，则验证失败，握手终止。 验有效期 服务端将当前日期与证书中列出的有效期进行比较。如果过期日期没有通过，当前日期在期限内，那么一切都好。如果不是，则验证失败，握手终止。 验证书撤销状态 服务端将客户端证书与系统中已撤销的证书列表进行比较。如果客户端证书在列表中，则验证失败，握手终止。 ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:4:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"nginx 配置双向认证 listen 443; server_name localhost; ssl on; ssl_certificate /usr/local/opt/nginx/certificates/server.cer; ssl_certificate_key /usr/local/opt/nginx/certificates/server.key.pem; ssl_client_certificate /usr/local/opt/nginx/certificates/ca.cer; ssl_verify_client on; 开启 ssl ssl_certificate 是服务端证书的路径，ssl_certificate_key是服务端私钥的路径 ssl_verify_client 是配置双向认证（client certificate） ssl_client_certificate 是签发客户端证书的根证书 为什么是根证书，因为可以签发很多客户端证书，只要是由该根证书签发的，服务端都视为认证通过 配置完成以后，一般需要把80端口的http请求跳转到443端口，否则用户可以通过80端口以http方式访问，就失去了安全保护的意义 ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:5:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"iOS 客户端 使用 NSURLSession 发出一个 https 请求 NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil]; NSURL *url = [NSURL URLWithString:@\"https://localhost/test\"]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setCachePolicy:NSURLRequestReloadIgnoringLocalCacheData]; [request setHTTPShouldHandleCookies:NO]; [request setTimeoutInterval:30]; [request setHTTPMethod:@\"GET\"]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { NSString *message = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@\"%@\", message); }]; [task resume]; 认证处理 握手阶段回调方法两次，一次是 server 认证，一次是 client 认证。 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler { NSString *method = challenge.protectionSpace.authenticationMethod; NSLog(@\"%@\", method); // 服务端证书认证 if([method isEqualToString:NSURLAuthenticationMethodServerTrust]){ NSString *host = challenge.protectionSpace.host; NSLog(@\"%@\", host); NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential, credential); return; } // 客户端证书 NSString *thePath = [[NSBundle mainBundle] pathForResource:@\"client\" ofType:@\"p12\"]; NSData *PKCS12Data = [[NSData alloc] initWithContentsOfFile:thePath]; CFDataRef inPKCS12Data = (CFDataRef)CFBridgingRetain(PKCS12Data); SecIdentityRef identity; // 读取p12证书中的内容 OSStatus result = [self extractP12Data:inPKCS12Data toIdentity:\u0026identity]; if(result != errSecSuccess){ completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil); return; } SecCertificateRef certificate = NULL; SecIdentityCopyCertificate (identity, \u0026certificate); const void *certs[] = {certificate}; CFArrayRef certArray = CFArrayCreate(kCFAllocatorDefault, certs, 1, NULL); NSURLCredential *credential = [NSURLCredential credentialWithIdentity:identity certificates:(NSArray*)CFBridgingRelease(certArray) persistence:NSURLCredentialPersistencePermanent]; completionHandler(NSURLSessionAuthChallengeUseCredential, credential); } - (OSStatus)extractP12Data:(CFDataRef)inP12Data toIdentity:(SecIdentityRef*)identity { OSStatus securityError = errSecSuccess; CFStringRef password = CFSTR(\"the_password\"); const void *keys[] = { kSecImportExportPassphrase }; const void *values[] = { password }; CFDictionaryRef options = CFDictionaryCreate(NULL, keys, values, 1, NULL, NULL); CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL); securityError = SecPKCS12Import(inP12Data, options, \u0026items); if (securityError == 0) { CFDictionaryRef ident = CFArrayGetValueAtIndex(items,0); const void *tempIdentity = NULL; tempIdentity = CFDictionaryGetValue(ident, kSecImportItemIdentity); *identity = (SecIdentityRef)tempIdentity; } if (options) { CFRelease(options); } return securityError; } ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:6:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"Postman 客户端 配置路径：偏好设置 》 证书 》 添加客户端证书 ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:7:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["web"],"content":"HTTPS 办不到的事情 隐藏要访问的站点名称 这是因为网站的名称(又名“域名”)是通过DNS(域名服务)发送的，而DNS(域名服务)不在HTTPS隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称(例如 google.com)，只是不能读取任何来回传输的实际内容。除非采用 DNSSEC 。 防止访问恶意网站 HTTPS并不能确保网站本身是安全的。仅仅因为连接安全并不意味着你不会连接到一个由不法分子运营的网站。 提供匿名性（IP、物理位置） HTTPS 不会隐藏物理位置或个人身份。个人 IP 地址不能加密，因为如果 IP 地址也被加密了，互联网就不知道该把它发送到哪里。而且它也不会在你访问的网站上掩盖你的身份，你访问的网站仍然知道你的一切。 防止感染病毒 HTTPS 不是过滤器，所以会有可能在 HTTPS 连接中收到病毒或木马。如果网络服务器被感染，病毒就会像其他报文一样被发送到 HTTPS 流中。然而，HTTPS确实阻止了中间人向流量中注入木马。 防止电脑被黑 HTTPS 仅在数据在客户端和服务端之间传输时提供安全保证，如果有恶意软件在监控连接的一端的流量，它仍然可以读取加密之前和之后的 HTTPS 流。 参考链接 Wikipedia, Transport Layer Security first-few-milliseconds-of-https ","date":"2016-11-08","objectID":"/https-uni-bidirectional-authentication/:8:0","tags":["web","Security","iOS","nginx"],"title":"HTTPS 单向/双向认证","uri":"/https-uni-bidirectional-authentication/"},{"categories":["iOS"],"content":" 国内 DCloud 团队推出的 HTML5+ 技术框架可以用来开发 Hybrid 应用。经过调研，我们决定试一试 。框架的核心原理是使用 iOS 系统原生 UIWebView 和 WKWebView 来加载资源并渲染界面，Native 的能力（如拍照、蓝牙）通过自定义插件来提供。 我们的应用有个需求，就是在 webview 加载完页面或者加载页面之前加入一些东西。比如：加载完页面后，根据 HTML 的 title 标签来设置导航栏标题。 原生想要插手页面加载周期，只能靠代理方法。但是因为没法修改源码，所以只能找其它办法。主要思路是：使用 Method Swizzle 找出代理对象然后再换掉代理方法实现。 以 UIWebView 为例，具体操作如下： 第一步，通过交换 setDelegate 的实现，找到目标代理对象所属的类； UIWebView+Intercepter.m - (void)p_setDelegate:(id\u003cUIWebViewDelegate\u003e)delegate { [self p_setDelegate:delegate]; Class delegateClass = [self.delegate class]; // 进一步交换 delegateClass 的代理方法 [UIWebViewDelegateHook exchangeUIWebViewDelegateMethod:delegateClass]; } #pragma mark - Method Swizzling + (void)load { static dispatch_once_t onceToken; dispatch_once(\u0026onceToken, ^{ Class class = [super class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(setDelegate:); SEL swizzledSelector = @selector(p_setDelegate:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } 第二步，把目标代理对象所属类的代理方法实现换成我们自己写的方法实现。 UIWebViewDelegateHook.m + (void)exchangeUIWebViewDelegateMethod:(Class)aClass { p_exchangeMethod(aClass, @selector(webViewDidStartLoad:), [self class], @selector(replaced_webViewDidStartLoad:)); p_exchangeMethod(aClass, @selector(webViewDidFinishLoad:), [self class], @selector(replaced_webViewDidFinishLoad:)); p_exchangeMethod(aClass, @selector(webView:didFailLoadWithError:), [self class], @selector(replaced_webView:didFailLoadWithError:)); p_exchangeMethod(aClass, @selector(webView:shouldStartLoadWithRequest:navigationType:), [self class], @selector(replaced_webView:shouldStartLoadWithRequest:navigationType:)); } - (BOOL)replaced_webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { NSLog(@\"shouldStartLoadWithRequest\"); return [self replaced_webView:webView shouldStartLoadWithRequest:request navigationType:navigationType]; } - (void)replaced_webViewDidStartLoad:(UIWebView *)webView { NSLog(@\"webViewDidStartLoad\"); [self replaced_webViewDidStartLoad:webView]; } - (void)replaced_webViewDidFinishLoad:(UIWebView *)webView { NSLog(@\"webViewDidFinishLoad\"); [self replaced_webViewDidFinishLoad:webView]; NSString *pageTitle = [webView stringByEvaluatingJavaScriptFromString:@\"document.title\"]; [[NSNotificationCenter defaultCenter] postNotificationName:PAFWebViewPageTitleDidChange object:self userInfo:@{PAFPageTitle:pageTitle}]; } - (void)replaced_webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error { NSLog(@\"didFailLoadWithError\"); [self replaced_webView:webView didFailLoadWithError:error]; } 注意防止 setDelegate 被调用多次，这样会导致方法又被换掉。 static void p_exchangeMethod(Class originalClass, SEL originalSel, Class replacedClass, SEL replacedSel) { static NSMutableArray *classList = nil; if (classList == nil) { classList = [NSMutableArray array]; } NSString *className = [NSString stringWithFormat:@\"%@__%@\", NSStringFromClass(originalClass), NSStringFromSelector(originalSel)]; for (NSString *item in classList) { // 防止 setDelegate 方法被调用多次，导致代理方法又被换掉 if ([className isEqualToString:item]) { return; } } [classList addObject:className]; Method originalMethod = class_getInstanceMethod(originalClass, originalSel); assert(originalMethod); Method replacedMethod = class_getInstanceMethod(replacedClass, replacedSel); assert(replacedMethod); IMP replacedMethodIMP = method_getImplementation(replacedMethod); BOOL didAddMethod = class_addMethod(originalClass, replacedSel, replacedMet","date":"2016-10-18","objectID":"/ios-hook-uiwebview-delegate-method/:0:0","tags":["iOS","WebView","Hook"],"title":"iOS Hook WebView 的代理方法","uri":"/ios-hook-uiwebview-delegate-method/"},{"categories":["iOS"],"content":"iOS 10 开始对隐私权限更加严格, 如需使用隐私权限需要在工程的 info.plist 文件中声明,如果不声明程序在调用隐私权限（如相机）时应用程序会崩溃。 key 可以从下拉列表选择，value 为弹框提示文字（类型 String） 权限名称 Key 值 通讯录 NSContactsUsageDescription 麦克风 NSMicrophoneUsageDescription 相册 NSPhotoLibraryUsageDescription 相机 NSCameraUsageDescription 持续获取地理位置 NSLocationAlwaysUsageDescription 使用时获取地理位置 NSLocationWhenInUseUsageDescription 蓝牙 NSBluetoothPeripheralUsageDescription 语音转文字 NSSpeechRecognitionUsageDescription 日历 NSCalendarsUsageDescription ","date":"2016-10-07","objectID":"/ios-ios10-user-privacy/:0:0","tags":["iOS","Privacy"],"title":"iOS 10 需要在 info.plist 中添加权限设置","uri":"/ios-ios10-user-privacy/"},{"categories":["iOS"],"content":"GCD（Grand Central Dispatch）是异步执行任务的技术之一。 一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。 dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ /** * 长时间处理 * 例如：AR用图像识别、数据库访问 */ /** * 长时间处理结束，主线程使用该处理结果 */ dispatch_async(dispatch_get_main_queue(), ^{ /** * 只在主线程可以执行的处理 * 例如用户界面刷新 */ }); }); 在导入 GCD 之前，Cocoa 框架提供了 NSObject 类的performSelectorInBackground:withObject实例方法和performSelectorOnMainThread实例方法等简单的多线程编程技术。 线程 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 “一个 CPU 执行的 CPU 命令列为一条无分叉路径”即为“线程”。 现在一个物理的 CPU 芯片实际上有64个（64核）CPU，尽管如此，“一个 CPU 执行的 CPU 命令列为一条无分叉路径”仍然不变。 OS X 和 iOS 的核心 XNU 内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原 CPU 寄存器等信息，继续执行切换路径的 CPU 命令列。这称为“上下文切换”。 由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去好像1个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是“看上去像”了，而是真的提供了多个CPU核并行执行多个线程的技术。 使用多线程容易引发的常见问题 数据竞争（多个线程更新相同的资源会导致数据不一致） 死锁（停止等待事件的线程会导致多个线程相互持续等待） 内存占用（使用太多线程会消耗大量内存） 尽管容易发生问题，但是为了保证应用程序的响应性能，也应当使用多线程编程。 ","date":"2015-01-05","objectID":"/ios-gcd/:0:0","tags":["iOS","GCD"],"title":"Grand Central Dispatch","uri":"/ios-gcd/"},{"categories":["iOS"],"content":"GCD的API Dispatch Queue是执行处理的等待队列，按照FIFO（先进先出）的追加顺序执行处理。开发者要做的只是定义想执行的任务并追加到适当地Dispatch Queue中。 Dispatch Queue分两种： 等待现在执行中处理结束的Serial Dispatch Queue; 不等待现在执行中处理结束的Concurrent Dispatch Queue。 dispatch_queue_create 生成Dispatch Queue的方法。 dispatch_queue_t queue = dispatch_queue_create(\"com.example.gcd.MyQueue\", DISPATCH_QUEUE_CONCURRENT); /* dispatch_release(queue); */ 如果你部署的最低目标低于 iOS 6.0 or Mac OS X 10.8 ，你应该自己管理GCD对象,使用(dispatch_retain,dispatch_release),ARC并不会去管理它们。如果你部署的最低目标是 iOS 6.0 or Mac OS X 10.8 或者更高的， ARC 已经能够管理 GCD 对象了,这时候, GCD 对象就如同普通的 OC 对象一样,不应该使用 dispatch_retain 或者 dispatch_release 。 为了避免多个线程更新相同资源导致数据竞争，推荐使用 Serial Dispatch Queue。当想并发执行不发生数据竞争等问题的处理时，使用 Concurrent Dispatch Queue。 Main Dispatch Queue / Global Dispatch Queue 系统提供的 Dispatch Queue。 Main Dispatch Queue 是在主线程中执行的 Dispatch Queue。 因为主线程只有1个，所以它是 Serial Dispatch Queue。 追加到 Main Dispatch Queue 的处理在主线程的 Runloop 中执行。 Global Dispatch Queue是所有应用程序都能够使用的 Concurrent Dispatch Queue。没有必要通过 dispatch_queue_create 函数逐个生成 Concurrent Dispatch Queue。只要获取 Global Dispatch Queue 使用即可。 表 1-1 Dispatch Queue种类 名称 Dispatch Queue的种类 说明 Main Dispatch Queue Serial Dispatch Queue 主线程执行 Global Dispatch Queue(High Priority) Concurrent Dispatch Queue 执行优先级：高（最高优先级） Global Dispatch Queue(Default Priority) Concurrent Dispatch Queue 执行优先级：默认 Global Dispatch Queue(Low Priority) Concurrent Dispatch Queue 执行优先级：低 Global Dispatch Queue(Background Priority) Concurrent Dispatch Queue 执行优先级：后台 获取方法： dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue(); dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_set_target_queue dispatch_queue_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue，都使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程。而变更生成的 Dispatch Queue 的执行优先级要使用 dispatch_set_target_queue 函数。 dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(\"com.example.gcd.mySerialDispatchQueue\", NULL); dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground); 指定要变更执行优先级的 Dispatch Queue 为 dispatch_set_target_queue 函数的第一个参数，指定与要使用的执行优先级相同优先级的 Global Dispatch Queue 为第二个参数（目标优先级）。 dispatch_after 当我们想要在指定时间后执行某个处理时（切确来说，是在指定时间追加处理到Dispatch Queue），使用 dispatch_after 函数。 /* 在3秒后用dispatch_asyn函数追加Block到Main Dispatch Queue * ull 是C语言的数值字面量，是显示表明类型时使用的字符串（表示“unsigned long long”） */ dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC); dispatch_after(time, dispatch_get_main_queue(), ^{ NSLog(@\"waited at least three seconds.\"); }); 第一个参数是指定时间用的 dispatch_time_t 类型的值。可以使用 dispatch_time 函数或者 dispatch_walltime 函数获得。 dispatch_time 函数能够获取从第一个参数 dispatch_time_t 类型值中指定的时间开始，到第二个参数指定的毫微秒单位时间后的时间。（相对时间） dispatch_walltime 函数通常用于计算绝对时间，比如：2011年11月11日11分11秒 这一绝对时间，这可以当做粗略的闹钟功能使用。 dispatch_walltime 函数由 POSIX 中使用的 struct timespec 类型的时间得到 dispatch_time_t 类型的值。 Dispatch Group 在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。只使用一个 Serial Dispatch Queue 时，只要将想执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。但是在使用 Concurrent Dispatch Queue 时或同时使用多个 Dispatch Queue时，源代码就会变得颇为复杂。这是就用到 Dispatch Group。 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ NSLog(@\"blk1\"); }); dispatch_group_async(group, queue, ^{ NSLog(@\"blk2\"); }); dispatch_group_async(group, queue, ^{ NSLog(@\"blk3\"); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\"done\"); }); 这里除了使用 dispatch_group_notify，还可以使用 dispatch_group_wait 函数。 例如： long result = dispatch_group_wait(group,DISPATCH_TIME_FOREVER); 永远等待下去，直到全部处理完成，所以result恒为0 例如： dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC); long result = dispatch_group_wait(group, time); if (result == 0) { // 属于Dispatch Group的全部处理结束 } else { // 属于Dispatch Group的某个处理还在执行中 } 如果 dispatch_group_wait 函数的返回值不","date":"2015-01-05","objectID":"/ios-gcd/:0:1","tags":["iOS","GCD"],"title":"Grand Central Dispatch","uri":"/ios-gcd/"},{"categories":["iOS"],"content":"视图需要有确定的位置与大小才能正确显示在屏幕上。Auto Layout 使用对齐矩阵来确定视图的位置与大小，也就是所谓的约束。我们创建的每一条规则都规定了界面的一部分与另一部分的关系，某一部分可以由另一部分计算得出结果。 y = ax + b; 是一种线性关系。 创建约束的常见的方式： Xib NSLayoutConstraint VFS 第一种，可以在(Interface Builder)IB中布局约束，并且根据需求自定义它们。 第二种，可以使用代码创建单个约束。NSLayoutConstraint 类提供constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:contant:方法，可以让你每次创建一个约束，它将某项的属性关联到另一项。 第三种，使用可视化格式语言来表示各项是如何沿着垂直和水平坐标轴布局的。 所有约束都是 NSLayoutConstraint 类的成员，无论你是以何种方式创建它们的。每个约束都在一个 Objective—C 对象中存储y = ax + b规则，并且通过 Auto Layout 引擎来表达该规则。可视化约束 是另一种实现相同效果的工具。 ","date":"2014-10-15","objectID":"/ios-autolayout/:0:0","tags":["iOS","AutoLayout"],"title":"Auto Layout 知识点梳理","uri":"/ios-autolayout/"},{"categories":["iOS"],"content":"什么是自动引用计数 自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术。要使用 ARC，需要满足以下条件： 使用 Xcode4.2 或以上版本 使用 LLVM 编译器 3.0 或以上版本 编译器选项中设置 ARC 有效 生活例子：办公室开关灯 最早进入办公室的人开灯。 count = 1 之后进入办公室的人，需要照明。 count = 2 下班离开办公室的人，不需要照明。 count = 1 最后离开办公室的人关灯。（此时已无人需要照明） count = 0 ","date":"2014-09-22","objectID":"/ios-arc/:1:0","tags":["iOS","ARC"],"title":"ARC","uri":"/ios-arc/"},{"categories":["iOS"],"content":"内存管理 思考方式： 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 表 1- 2 对象操作与 Objective-C 方法的对应 对象操作 Objective-C方法 生成并持有对象 alloc/new/copy/mutableCopy方法 持有对象 retain方法 释放对象 release方法 废弃对象 dealloc方法 区域(zone) NSDefaultMallocZone、NSZoneMalloc 等名称中包含的NSZone是什么呢？它是为防止内存碎片化而引入的结构。对内存分配的区域本身进行多重化管理，根据使用对象的目的、对象的大小分配内存，从而提高了内存管理的效率。但是，如同苹果官方文档 Programming With ARC Release Notes 中所说，现在的运行时系统只是简单地忽略了区域的概念。运行时系统中的内存管理本身已极具效率，使用区域来管理内存反而会引起内存使用效率低下以及源代码复杂化问题。 修饰符 __strong 修饰符 __weak 修饰符 __unsafe_unretained 修饰符 __autoreleasing 修饰符 __unsafe_unretained 修饰符正如其名 unsafe 所示，是不安全的所有权修饰符。尽管 ARC 式的内存管理是编译器的工作，但附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象。同附有 __weak 修饰符的变量一样，因为自己生成并持有的对象不能继续为自己所有，所以生成的对象会立即被释放。 为什么需要使用附有 __unsafe_unretained 修饰符？ 在 iOS4 以及 OS X Snow Leopard 的应用程序中，必须使用 __unsafe_unretained 修饰符来替代 __weak 修饰符。赋值给附有 __unsafe_unretained 修饰符的对象在通过该变量使用时，如果没有确保其确实存在（可能已经被废弃，悬垂指针），那么应用程序可能会崩溃。 ","date":"2014-09-22","objectID":"/ios-arc/:2:0","tags":["iOS","ARC"],"title":"ARC","uri":"/ios-arc/"},{"categories":["iOS"],"content":"ARC规则： 不能使用 retain/release/retainCount/autorelease 不能使用 NSAllocateObject/NSDeallocateObject 须遵守内存管理的方法命名规则 不要显式调用 dealloc 使用 @autoreleasepool 块替代 NSAutoreleasePool 不能使用区域（NSZone） 对象型变量不能作为 C 语言结构体（struct/union）的成员 显示转换“id”和“void *” 对象型变量不能作为C语言结构体的成员 struct Data { NSMutableArray *array; } 会引发编译错误。 虽然是 LLVM 编译器 3.0，但 C 语言的规约上没有方法来管理结构体成员的生存周期。因为 ARC 把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生存周期。例如 C 语言的自动变量（局部变量）是使用该变量的作用域管理对象。但是对于 C 语言的结构体成员来说，这在标准上就是不可实现的。要把对象型变量加入到结构体成员中时，可强制转换为 void * 或者是附加__unsafe_unretained 修饰符。 显示转换“id”和“void *” /* ARC无效 */ id obj = [[NSObject alloc] init]; void *p = obj; id q = p; /* ARC有效 */ id obj = [[NSObject alloc] init]; void *p = (__bridge void *)obj; id q = (__bridge id)p; ARC 有效时，通过 __bridge 转换，id 和 void * 就能够相互转换。但是转换为 void * 的 __bridge 转换，其安全性与赋值给 __unsafe_unretained 修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。 __bridge 转换中还有两种，分别是__bridge_retained 和__bridge_transfer。 __bridge_retained 转换可使要转换赋值的变量也持有所赋值的对象。 __bridge_transfer 转换提供相反的动作，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。 这些转换多数发生在 Objective-C 对象与 Core Foundation 对象之间的相互变换中。 ","date":"2014-09-22","objectID":"/ios-arc/:3:0","tags":["iOS","ARC"],"title":"ARC","uri":"/ios-arc/"},{"categories":["iOS"],"content":"Objective-C 对象与 Core Foundation 对象 Core Foundation 对象主要使用在用 C 语言编写的 Core Foundation 框架中，并使用引用计数的对象。在 ARC 无效时，Core Foundation 框架中的 retain/release 分别是 CFRetain/CFRelease。 Core Foundation 对象与 Objective-C 对象的区别很小，不同之处只在于是由哪一个框架（Core Foundation或者Foundation）所生成的。无论是由哪种框架生成的对象，一旦生成之后，便能在不同的框架中使用。Foundation 框架的 API 生成并持有的对象可以用 Core Foundation 框架的 API 释放。反之亦然。 因为二者区别不大，所以，在 ARC 无效时，只用简单的C语言的转换也能实现互换。另外这种转换不需要使用额外的 CPU 资源，因此也被称为“免费桥”（Toll-free Bridge）。 ","date":"2014-09-22","objectID":"/ios-arc/:4:0","tags":["iOS","ARC"],"title":"ARC","uri":"/ios-arc/"},{"categories":["iOS"],"content":"blocks 是 C 语言的扩充功能。blocks 是带有自动变量（局部变量）的匿名函数。 ","date":"2014-09-20","objectID":"/ios-blocks/:0:0","tags":["Block","iOS"],"title":"iOS Block","uri":"/ios-blocks/"},{"categories":["iOS"],"content":"截获自动变量 int main() { int dmy = 256; int val = 10; const char *fmt = \"val = %d\\n\"; void (^blk)(void) = ^{ printf(fmt,val); }; val = 2; fmt = \"These value were changed. val = %d\\n\"; blk(); return 0; } 结果：val = 10 分析：block 语法的表达式使用的是它之前声明的自动变量 fmt 和 val。block 表达式截获所使用的自动变量的值为瞬间值。因为 block 表达式保存了自动变量的值（截获），所以在执行 block 语法后，即使改写了 block 中使用的自动变量的值也不会影响 block 执行的结果。 需要在 block 中修改一个变量的值，需要使用 __block 说明符。 ","date":"2014-09-20","objectID":"/ios-blocks/:0:1","tags":["Block","iOS"],"title":"iOS Block","uri":"/ios-blocks/"},{"categories":["iOS"],"content":"block 的实质 block 实际上是作为极普通的 C 语言源代码来处理的。通过支持 block 的编译器，含有 block 语法的源代码转换为一般 C 语言编译器能够处理的源代码，并作为极为普通的 C 语言代码被编译。 clang -rewrite-objc sourceFileName 通过这个命令可以将含有 block 语法的源代码转换为 C++ 代码。 通过观察，Block 转换为 Block 的结构体类型的自动变量，__block 变量转换为 __block 变量的结构体类型的自动变量（即栈上生成的该结构体的实例）。 表 1-1 Block 与 __block 变量的实质 名称 实质 Block 栈上 Block 的结构体实例 __block 变量 栈上 __block 变量的结构体实例 表 1-2 Block 的类 类 设置对象的存储域 _NSConcreteStackBlock 栈 _NSConcreteGlobalBlock 程序的数据区域(.data区) _NSConcreteMallocBlcok 堆 Block 为 _NSConcreteGlobalBlock 类对象的情况 记述全局变量的地方有 Block 语法时 Block 语法的表达式中不使用应截获的自动变量时 除了以上两种情况 block 语法生成的 block 为 _NSConcreteStackBlock 类对象，且设置在栈上。 将 block 配置在堆上的 _NSConcreteMallocBlock 类在何时使用呢？ block 超出变量作用域可存在的原因是？ __block 变量用结构体成员变量 __forwarding 存在的原因是？ Blocks 提供了将 Block 和 __block 变量从栈上复制到堆上的方法，这样，即使 Block 语法记述的变量作用域结束，堆上的 Block 还可以继续存在。 ","date":"2014-09-20","objectID":"/ios-blocks/:0:2","tags":["Block","iOS"],"title":"iOS Block","uri":"/ios-blocks/"},{"categories":["iOS"],"content":"什么时候栈上的 Block 会复制到堆 调用 Block 的 copy 实例方法时 Block 作为函数返回值返回时 将 Block 赋值给附有 __strong 修饰符、id 类型的类或 Block 类型成员变量时 在方法名中含有 usingBlock 的 Cocoa 框架方法或 Grand Central Dispatch 的 API 中传递 Block 时 堆上的 Block 被废弃时会调用 dispose 函数。 只有调用 _Block_copy 函数才能持有截获的附有 __strong 修饰符的对象类型的自动变量值。当需要在 Block 中使用对象类型自动变量时，除以下情形，推荐调用 Block 的 copy 方法。 Block 作为函数返回值返回时 将 Block 赋值给附有 __strong 修饰符、id 类型的类或 Block 类型成员变量时 在方法名中含有 usingBlock 的 Cocoa 框架方法或 Grand Central Dispatch 的 API 中传递 Block 时 ","date":"2014-09-20","objectID":"/ios-blocks/:0:3","tags":["Block","iOS"],"title":"iOS Block","uri":"/ios-blocks/"},{"categories":["C"],"content":"看到项目中，有人这样写 __weak __typeof__(self) wself = self;。我查了一下资料，总结一下。 typeof关键字是C语言中的一个新扩展,在linux内核中应用非常广泛。 ","date":"2014-07-27","objectID":"/c-typeof/:0:0","tags":["C"],"title":"Typeof()","uri":"/c-typeof/"},{"categories":["C"],"content":"说明 typeof()的参数可以是表达式或一种类型。返回的结果是一种类型。 表达式 typeof(x[0](1)); 这里假设 x 是一个函数指针数组，这样就可以得到这个函数返回值的类型了。如果将 typeof 用于表达式，则该表达式不会执行。只会得到该表达式的类型。以下示例声明了 int 类型的 var 变量，因为表达式 foo() 是 int 类型的。由于表达式不会被执行，所以不会调用 foo 函数。 extern int foo(); typeof(foo()) var; 一种类型 typeof(int *) a,b; 等价于：int *a,*b; ","date":"2014-07-27","objectID":"/c-typeof/:0:1","tags":["C"],"title":"Typeof()","uri":"/c-typeof/"},{"categories":["C"],"content":"例子 把 y 定义成 x 指向的数据类型： typeof(*x) y; 把 y 定义成 x 指向数据类型的数组： typeof(*x) y[4]; 把 y 定义成一个字符指针数组： typeof(typeof(char *)[4]) y; 这与下面的定义等价： char *y[4]; typeof(int *) p1,p2; 等价于 int *p1, *p2; typeof(int) *p3,p4;等价于 int *p3, p4; typeof(int [10]) a1, a2;等价于 int a1[10], a2[10]; ","date":"2014-07-27","objectID":"/c-typeof/:0:2","tags":["C"],"title":"Typeof()","uri":"/c-typeof/"},{"categories":["C"],"content":"特殊情况 typeof 构造中的类型名不能包含存储类说明符，如 extern 或 static。不过允许包含类型限定符，如 const 或 volatile。例如，下列代码是无效的，因为它在 typeof 构造中声明了 extern： typeof(extern int) a; 以上是typeof()总结。 ","date":"2014-07-27","objectID":"/c-typeof/:0:3","tags":["C"],"title":"Typeof()","uri":"/c-typeof/"},{"categories":["iOS"],"content":"在项目导航面板中选中 main.m ，可以看到 int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } 这是 iOS 应用的入口函数。UIApplicationMain 函数会创建一个 UIApplication 对象。每个 iOS 应用都有且只有一个 UIApplication 对象（单例），该对象的作用时维护运行循环。一旦程序创建了某个 UIApplication 对象，该对象的运行循环就会一直循环下去，main() 的执行也会因此阻塞。 此外，UIApplicationMain 函数还会创建某个指定类(此处为 AppDelegate)的对象，并将其设置为 UIApplication 对象的 delegate。UIApplicationMain 函数的第三个实参为 NSString 类型，指定了该对象所属的类。UIApplication 的 delegate 都需要遵守 UIApplicationDelegate 协议。 @interface AppDelegate : UIResponder \u003cUIApplicationDelegate\u003e 在应用启动运行循环时，UIApplication 对象会在应用出现相应状态变化时，向其 delegate 发送特定的消息。如： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; - (void)applicationWillResignActive:(UIApplication *)application; - (void)applicationDidEnterBackground:(UIApplication *)application; - (void)applicationWillEnterForeground:(UIApplication *)application; - (void)applicationDidBecomeActive:(UIApplication *)application; - (void)applicationWillTerminate:(UIApplication *)application; UIApplication 负责建立应用程序的事件循环（Event Loop），事件循环中可以不断接收交互操作，比如屏幕触摸手势、各类传感器（重力加速器、陀螺仪等）等。 ","date":"2014-07-13","objectID":"/ios-main/:0:0","tags":["iOS"],"title":"iOS 应用的 main.m 文件","uri":"/ios-main/"}]