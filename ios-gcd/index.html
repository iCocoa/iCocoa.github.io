<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Grand Central Dispatch - Haisheng Wu's Tech Blog</title><meta name=description content="This is Haisheng Wu's Tech Blog"><meta property="og:title" content="Grand Central Dispatch"><meta property="og:description" content="GCD（Grand Central Dispatch）是异步执行任务的技术之一。
一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  dispatch_queue_t queue = dispatch_queue_create(&#34;myQueue&#34;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ /** * 长时间处理 * 例如：AR用图像识别、数据库访问 */ /** * 长时间处理结束，主线程使用该处理结果 */ dispatch_async(dispatch_get_main_queue(), ^{ /** * 只在主线程可以执行的处理 * 例如用户界面刷新 */ }); });   在导入 GCD 之前，Cocoa 框架提供了 NSObject 类的performSelectorInBackground:withObject实例方法和performSelectorOnMainThread实例方法等简单的多线程编程技术。
线程
线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 “一个 CPU 执行的 CPU 命令列为一条无分叉路径”即为“线程”。 现在一个物理的 CPU 芯片实际上有64个（64核）CPU，尽管如此，“一个 CPU 执行的 CPU 命令列为一条无分叉路径”仍然不变。 OS X 和 iOS 的核心 XNU 内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原 CPU 寄存器等信息，继续执行切换路径的 CPU 命令列。这称为“上下文切换”。 由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去好像1个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是“看上去像”了，而是真的提供了多个CPU核并行执行多个线程的技术。  使用多线程容易引发的常见问题"><meta property="og:type" content="article"><meta property="og:url" content="http://www.redscarf.me/ios-gcd/"><meta property="og:image" content="http://www.redscarf.me/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-01-05T20:13:18+10:00"><meta property="article:modified_time" content="2015-01-05T20:13:18+10:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://www.redscarf.me/logo.png"><meta name=twitter:title content="Grand Central Dispatch"><meta name=twitter:description content="GCD（Grand Central Dispatch）是异步执行任务的技术之一。
一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  dispatch_queue_t queue = dispatch_queue_create(&#34;myQueue&#34;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ /** * 长时间处理 * 例如：AR用图像识别、数据库访问 */ /** * 长时间处理结束，主线程使用该处理结果 */ dispatch_async(dispatch_get_main_queue(), ^{ /** * 只在主线程可以执行的处理 * 例如用户界面刷新 */ }); });   在导入 GCD 之前，Cocoa 框架提供了 NSObject 类的performSelectorInBackground:withObject实例方法和performSelectorOnMainThread实例方法等简单的多线程编程技术。
线程
线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 “一个 CPU 执行的 CPU 命令列为一条无分叉路径”即为“线程”。 现在一个物理的 CPU 芯片实际上有64个（64核）CPU，尽管如此，“一个 CPU 执行的 CPU 命令列为一条无分叉路径”仍然不变。 OS X 和 iOS 的核心 XNU 内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原 CPU 寄存器等信息，继续执行切换路径的 CPU 命令列。这称为“上下文切换”。 由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去好像1个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是“看上去像”了，而是真的提供了多个CPU核并行执行多个线程的技术。  使用多线程容易引发的常见问题"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://www.redscarf.me/ios-gcd/><link rel=prev href=http://www.redscarf.me/ios-autolayout/><link rel=next href=http://www.redscarf.me/ios-ios10-user-privacy/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Grand Central Dispatch","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/www.redscarf.me\/ios-gcd\/"},"genre":"posts","keywords":"iOS, GCD","wordcount":949,"url":"http:\/\/www.redscarf.me\/ios-gcd\/","datePublished":"2015-01-05T20:13:18+10:00","dateModified":"2015-01-05T20:13:18+10:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Haisheng Wu"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Haisheng Wu's Tech Blog"></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/>Home </a><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/about/>About Me </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Haisheng Wu's Tech Blog"></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/ title>Home</a><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/about/ title>About Me</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Grand Central Dispatch</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>Haisheng Wu</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/ios/><i class="far fa-folder fa-fw"></i>iOS</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2015-01-05>2015-01-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 949 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#gcd的api>GCD的API</a></li></ul></li></ul></nav></div></div><div class=content id=content><p><strong>GCD</strong>（Grand Central Dispatch）是异步执行任务的技术之一。</p><p>一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_queue_t queue = dispatch_queue_create(&#34;myQueue&#34;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
   /**
    *  长时间处理
    *  例如：AR用图像识别、数据库访问
    */
   
   /**
    *  长时间处理结束，主线程使用该处理结果
    */
   
   dispatch_async(dispatch_get_main_queue(), ^{
       /**
        *  只在主线程可以执行的处理
        *  例如用户界面刷新
        */
   });
});
</code></pre></td></tr></table></div></div><p>在导入 GCD 之前，Cocoa 框架提供了 NSObject 类的<code>performSelectorInBackground:withObject</code>实例方法和<code>performSelectorOnMainThread</code>实例方法等简单的多线程编程技术。</p><p><strong>线程</strong></p><pre><code>线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。
“一个 CPU 执行的 CPU 命令列为一条无分叉路径”即为“线程”。
现在一个物理的 CPU 芯片实际上有64个（64核）CPU，尽管如此，“一个 CPU 执行的 CPU 命令列为一条无分叉路径”仍然不变。
	
OS X 和 iOS 的核心 XNU 内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原 CPU 寄存器等信息，继续执行切换路径的 CPU 命令列。这称为“上下文切换”。
由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去好像1个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是“看上去像”了，而是真的提供了多个CPU核并行执行多个线程的技术。
</code></pre><p><strong>使用多线程容易引发的常见问题</strong></p><ul><li>数据竞争（多个线程更新相同的资源会导致数据不一致）</li><li>死锁（停止等待事件的线程会导致多个线程相互持续等待）</li><li>内存占用（使用太多线程会消耗大量内存）</li></ul><p>尽管容易发生问题，但是为了保证应用程序的响应性能，也应当使用多线程编程。</p><h3 id=gcd的api>GCD的API</h3><p>Dispatch Queue是执行处理的等待队列，按照FIFO（先进先出）的追加顺序执行处理。开发者要做的只是定义想执行的任务并追加到适当地Dispatch Queue中。
Dispatch Queue分两种：</p><ul><li>等待现在执行中处理结束的Serial Dispatch Queue;</li><li>不等待现在执行中处理结束的Concurrent Dispatch Queue。</li></ul><p><strong>dispatch_queue_create</strong></p><p>生成Dispatch Queue的方法。</p><p><code>dispatch_queue_t queue = dispatch_queue_create("com.example.gcd.MyQueue", DISPATCH_QUEUE_CONCURRENT);</code></p><p><code>/* dispatch_release(queue); */</code></p><p>如果你部署的最低目标低于 iOS 6.0 or Mac OS X 10.8 ，你应该自己管理GCD对象,使用(dispatch_retain,dispatch_release),ARC并不会去管理它们。如果你部署的最低目标是 iOS 6.0 or Mac OS X 10.8 或者更高的，
ARC 已经能够管理 GCD 对象了,这时候, GCD 对象就如同普通的 OC 对象一样,不应该使用 dispatch_retain 或者 dispatch_release 。</p><p>为了避免多个线程更新相同资源导致数据竞争，推荐使用 Serial Dispatch Queue。当想并发执行不发生数据竞争等问题的处理时，使用 Concurrent Dispatch Queue。</p><p><strong>Main Dispatch Queue / Global Dispatch Queue</strong></p><p>系统提供的 Dispatch Queue。</p><p>Main Dispatch Queue 是在主线程中执行的 Dispatch Queue。
因为主线程只有1个，所以它是 Serial Dispatch Queue。
追加到 Main Dispatch Queue 的处理在主线程的 Runloop 中执行。</p><p><strong>Global Dispatch Queue</strong>是所有应用程序都能够使用的 Concurrent Dispatch Queue。没有必要通过 dispatch_queue_create 函数逐个生成 Concurrent Dispatch Queue。只要获取 Global Dispatch Queue 使用即可。</p><p>表 1-1 Dispatch Queue种类</p><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>Dispatch Queue的种类</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>Main Dispatch Queue</td><td style=text-align:center>Serial Dispatch Queue</td><td style=text-align:center>主线程执行</td></tr><tr><td style=text-align:center>Global Dispatch Queue(High Priority)</td><td style=text-align:center>Concurrent Dispatch Queue</td><td style=text-align:center>执行优先级：高（最高优先级）</td></tr><tr><td style=text-align:center>Global Dispatch Queue(Default Priority)</td><td style=text-align:center>Concurrent Dispatch Queue</td><td style=text-align:center>执行优先级：默认</td></tr><tr><td style=text-align:center>Global Dispatch Queue(Low Priority)</td><td style=text-align:center>Concurrent Dispatch Queue</td><td style=text-align:center>执行优先级：低</td></tr><tr><td style=text-align:center>Global Dispatch Queue(Background Priority)</td><td style=text-align:center>Concurrent Dispatch Queue</td><td style=text-align:center>执行优先级：后台</td></tr></tbody></table><p>获取方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
</code></pre></td></tr></table></div></div><p><strong>dispatch_set_target_queue</strong></p><p>dispatch_queue_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue，都使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程。而变更生成的 Dispatch Queue 的执行优先级要使用 dispatch_set_target_queue 函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(&#34;com.example.gcd.mySerialDispatchQueue&#34;, NULL);
dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);
</code></pre></td></tr></table></div></div><p>指定要变更执行优先级的 Dispatch Queue 为 dispatch_set_target_queue 函数的第一个参数，指定与要使用的执行优先级相同优先级的 Global Dispatch Queue 为第二个参数（目标优先级）。</p><p><strong>dispatch_after</strong></p><p>当我们想要在指定时间后执行某个处理时（切确来说，是在指定时间追加处理到Dispatch Queue），使用 dispatch_after 函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>/* 在3秒后用dispatch_asyn函数追加Block到Main Dispatch Queue 
 * ull 是C语言的数值字面量，是显示表明类型时使用的字符串（表示“unsigned long long”）
 */
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);
dispatch_after(time, dispatch_get_main_queue(), ^{
  NSLog(@&#34;waited at least three seconds.&#34;);
});
</code></pre></td></tr></table></div></div><p>第一个参数是指定时间用的 dispatch_time_t 类型的值。可以使用 dispatch_time 函数或者 dispatch_walltime 函数获得。 dispatch_time 函数能够获取从第一个参数 dispatch_time_t 类型值中指定的时间开始，到第二个参数指定的毫微秒单位时间后的时间。（相对时间） dispatch_walltime 函数通常用于计算绝对时间，比如：2011年11月11日11分11秒 这一绝对时间，这可以当做粗略的闹钟功能使用。 dispatch_walltime 函数由 POSIX 中使用的 struct timespec 类型的时间得到 dispatch_time_t 类型的值。</p><p><strong>Dispatch Group</strong></p><p>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，这种情况会经常出现。只使用一个 Serial Dispatch Queue 时，只要将想执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。但是在使用 Concurrent Dispatch Queue 时或同时使用多个 Dispatch Queue时，源代码就会变得颇为复杂。这是就用到 Dispatch Group。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{
  	NSLog(@&#34;blk1&#34;);
});
dispatch_group_async(group, queue, ^{
  	NSLog(@&#34;blk2&#34;);
});
dispatch_group_async(group, queue, ^{
  	NSLog(@&#34;blk3&#34;);
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
  	NSLog(@&#34;done&#34;);
});
</code></pre></td></tr></table></div></div><p>这里除了使用 dispatch_group_notify，还可以使用 dispatch_group_wait 函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>例如：	
long result = dispatch_group_wait(group,DISPATCH_TIME_FOREVER);
永远等待下去，直到全部处理完成，所以result恒为0
	
例如：
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);
long result = dispatch_group_wait(group, time);

if (result == 0) {
	// 属于Dispatch Group的全部处理结束
} else {
	// 属于Dispatch Group的某个处理还在执行中
}
</code></pre></td></tr></table></div></div><p>如果 dispatch_group_wait 函数的返回值不为 0，就意味着虽然经过了指定的时间，但属于 Dispatch Group 的某一个处理还在执行中。如果返回值为 0，那么全部处理执行结束。指定<code>DISPATCH_TIME_NOW</code>，则不用任何等待即可判定属于 Dispatch Group 的处理是否执行结束。</p><p><code>long result = dispatch_group_wait(group,DISPATCH_TIME_NOW);</code></p><p>在主线程的 Runloop 的每次循环中，可检查执行是否结束，从而不耗费多余的等待时间，虽然这样可以，但一般在这种情况下，还是推荐用 dispatch_group_notify 函数追加技术处理到 Main Dispatch Queue 中，这样可以简化源代码。</p><p><strong>dispatch_barrier_async</strong></p><p>在访问数据库或文件时，使用 Serial Dispatch Queue 可避免数据竞争的问题。写入处理确实不可与其他的处理以及包含读取处理的其他处理并行执行。但是如果读取处理只是与读取处理并行执行，那么多个并行执行就不会发生问题。也就是说，为了高效率地进行访问，读取处理追加到 Concurrent Dispatch Queue 中，写入处理在任何一个读取处理没有执行的状态下，追加到 Serial Dispatch Queue 中即可（在写入处理结束之前，读取处理不可执行）。</p><p>这时，用到<code>dispatch_barrier_async</code>函数。<code>dispatch_barrier_async</code>函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束之后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_async(queue, blk0_for_reading);
dispatch_async(queue, blk1_for_reading);
dispatch_async(queue, blk2_for_reading);
dispatch_async(queue, blk3_for_reading);

//写入处理
dispatch_barrier_async(queue, blk_for_writing);

dispatch_async(queue, blk4_for_reading);
dispatch_async(queue, blk5_for_reading);
dispatch_async(queue, blk6_for_reading);
</code></pre></td></tr></table></div></div><p><strong>dispatch_sync(同步)</strong>
<strong>dispatch_apply(同步操作)</strong></p><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联API。该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(10, queue, ^(size_t index) {
 	NSLog(@&#34;%zu&#34;,index);
});
</code></pre></td></tr></table></div></div><p><strong>dispatch_suspend / dispatch_resume</strong></p><p>当追加大量处理到 Dispatch Queue 时，在追加处理的过程中，有时希望不执行已经追加的处理。这时，需要挂起 Dispatch Queue，当可以执行时再恢复。</p><p>dispatch_suspend 函数挂起指定的 Dispatch Queue。</p><p><code>dispatch_suspend(queue);</code></p><p>dispatch_resume 函数恢复指定的 Dispatch Queue。</p><p><code>dispatch_resume(queue);</code></p><p>这两个函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p><p><strong>Dispatch Semaphore</strong></p><p>如前所述，当并行执行的处理更新数据时，会产生数据不一致的情况，有时应用程序还会异常结束。虽然使用 Serial Dispatch Queue 和 dispatch_barriel_async 函数可以避免这类问题，但有必要进行更细粒度的排他控制。</p><p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。计数为 0 时等待，计数为 1 或者大于 1 时，减去 1 而不等待。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
/**
*  生成Dispatch Semaphore
*
*  Dispatch Semaphore的计数初始值设定为“1”。
*
*  保证可访问 NSMutableArray 类对象的线程同时只能有一个
*
*/
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
    
NSMutableArray *array = [NSMutableArray array];
    
for (NSInteger i = 0; i &lt; 100000; i++) {
   	dispatch_async(queue, ^{
       /**
        * 等待 Dispatch Semaphore
        * 一直等待，直到 Dispatch Semaphore 的计数值大于或者等于 1
        */
       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
       
       /**
        * 由于 Dispatch Semaphore 的计数值大于等于1
        * 所以将 Dispatch Semaphore 的计数值减去1
        * dispatch_semaphore_wait 函数执行返回
        *
        * 执行到此时，计数值恒为“0”
        *
        * 此时可访问 NSMutableArray 类对象的线程只有1个
        * 可以安全地进行更新
        */
       
       [array addObject:[NSNumber numberWithInt:1]];
       
       /**
        *  排他控制结束
        *  使用 dispatch_semaphore_signal 函数将计数值加 1
        *
        *  如果有通过 dispatch_semaphore_wait 函数等待计数值增加的线程
        *  由最先等待的线程执行。
        */
       
       dispatch_semaphore_signal(semaphore);
   	});
}
</code></pre></td></tr></table></div></div><p><strong>dispatch_once</strong></p><p>dispatch_once 函数是保证在应用程序执行中只执行一次指定处理的 API。在生成单例对象时使用。在多线程下执行，也可保证百分之百安全。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>static dispatch_once_t pred;
dispatch_once(&amp;pred, ^{
   /**
    *  初始化
    */
});
</code></pre></td></tr></table></div></div><p><strong>Dispatch I/O</strong></p><p>在读取较大文件时，如果将文件分成合适的大小使用 Global Dispatch Queue 并列读取的话，会比一般的读取速度快不少。苹果中使用 Dispatch I/O 和 Dispatch Data 的例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>pipe_q = dispatch_queue_create(&#34;PipeQ&#34;, NULL);
pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err){
   close(fd);
});
    
*out_fd = fdpair[1];
    
dispatch_io_set_low_water(pipe_channel, SIZE_MAX);
    
dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err){
   if (err == 0)
   {
       size_t len = dispatch_data_get_size(pipedata);
       if (len &gt; 0)
       {
           const char *bytes = NULL;
           char *encoded;
           dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&amp;bytes, &amp;len);
           encoded = asl_core_encode_buffer(bytes, len);
           asl_set((aslmsg)merged_msg, ASL_KEY_AUX_DATA, encoded);
           free(encoded);
           _asl_send_message(NULL, merged_msg, -1, NULL);
           asl_msg_release(merged_msg);
           dispatch_release(md);
       }
   }
   
   if (done)
   {
       dispatch_semaphore_signal(sem);
       dispatch_release(pipe_channel);  
       dispatch_release(pipe_q);  
   }  
});
</code></pre></td></tr></table></div></div><p>以上摘自 Apple System Log API 用的源代码(Libc-763.11 gen/asl.c)。<code>dispatch_io_create</code>函数创建了一个 dispatch I/O。并指定发生错误的时候被执行的block，以及执行该 block 的队列。<code>dispatch_io_set_low_water</code>函数设定一次读取的大小（分割大小），<code>dispatch_io_read</code>函数在全局队列上开启读取操作。每当一块数据被读取后，数据作为参数会被传递给<code>dispatch_io_read</code>函数指定的读取结束时回调的 Block。回调的用的 Block 分析传递过来的 Dispatch Data 并进行结合处理。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2015-01-05</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/ios-gcd/index.md target=_blank rel="noopener noreferrer">阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch" data-hashtags=iOS,GCD><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=http://www.redscarf.me/ios-gcd/ data-hashtag=iOS><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch"><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch" data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=http://www.redscarf.me/ios-gcd/ data-title="Grand Central Dispatch"><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/ios/>iOS</a>,&nbsp;<a href=/tags/gcd/>GCD</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/ios-autolayout/ class=prev rel=prev title="Auto Layout 知识点梳理"><i class="fas fa-angle-left fa-fw"></i>Auto Layout 知识点梳理</a>
<a href=/ios-ios10-user-privacy/ class=next rel=next title="iOS 10 需要在 info.plist 中添加权限设置">iOS 10 需要在 info.plist 中添加权限设置<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.84.4">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/sunt-programator/CodeIT target=_blank rel="noopener noreferrer" title="CodeIT 0.2.10"><i class="fas fa-laptop-code fa-fw"></i> CodeIT</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer">Haisheng Wu</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=https://redscarf.disqus.com/embed.js defer></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:1e3},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>