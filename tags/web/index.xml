<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on Haisheng Wu's Tech Blog</title><link>https://redscarf.me/tags/web/</link><description>Recent content in Web on Haisheng Wu's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 11 Nov 2024 20:15:32 +1000</lastBuildDate><atom:link href="https://redscarf.me/tags/web/index.xml" rel="self" type="application/rss+xml"/><item><title>应用层数据分布路由算法</title><link>https://redscarf.me/d-route-alg/</link><pubDate>Mon, 11 Nov 2024 20:15:32 +1000</pubDate><guid>https://redscarf.me/d-route-alg/</guid><description>应用层数据分布路由算法主要用于分布式系统中，将数据或请求分配到多个节点（服务器、存储设备或服务实例）上，以实现负载均衡、高可用性和扩展性。常见的有： 哈希取模（Modulo Hashing）、随机路由 (Random Routing)、一致性哈希（Consistent Hashing）等等。
随机路由 (Random Routing) 原理：随机选择一个节点处理请求。
特点： 简单直观，但不能保证均匀分布。 不适合高负载系统，因为可能导致数据倾斜。
应用：用于初步负载均衡或测试场景。
哈希取模（Modulo Hashing） 原理：使用简单的哈希函数对节点数量取模，将请求分配到相应节点。
公式：节点 = Hash(Key) % N，其中 N 是节点数量。
特点：简单高效，易于实现。
缺点：节点增减时，所有数据都需要重新分配，无法满足动态性要求。
应用：适用于小规模系统或节点数固定的场景。
一致性哈希（Consistent Hashing） 原理：将节点和数据映射到一个逻辑环上，数据存储在与其哈希值最接近的节点中。
特点： 高动态性：节点增减时，仅影响邻近的节点，减少数据迁移量。 负载均衡：通过虚拟节点均衡数据分布。
应用： 分布式缓存（如 Memcached、Redis）。 分布式存储（如 Cassandra、Amazon Dynamo）。 微服务负载均衡。
一致性哈希算法实现 一致性Hash首先构建一个Hash 环的结构。环的大小是 0 到2^32-1，也就是无符号整型的取值范围，0 和最后一个 2^32-1 首尾相连，构成一个 Hash 环。将每个缓存服务节点 hash值放到环上。每次一次进行服务器查找路由计算的时候，都是根据key 的hash 值顺时针查找距离它最近的服务器节点。通过这种方式，key 不变的情况下找到的总是相同的服务器。但是，Hash 值是一个随机值，把一个随机值放到一个环上以后，可能是不均衡的，也就是某两个服务器节点在环上的距离可能很近，而和其它的服务器节点距离很远。这会导致有些服务负载压力特别大，有些服务器的负载压力特别小。在实践中，需要使用虚拟节点对方法进行改进，把一个服务节点放到环上时，把它虚拟成200个虚拟节点，然后把 200 个虚拟节点随机放到环上。key 依然是按照顺时针查找距离它最近的虚拟节点，再根据映射关系找到真正的物理节点。
Java 代码实现如下：
public class Consistent { SortedMap&amp;lt;Long, PhysicalNode&amp;gt; ring; int virtualNodeCount; public Consistent(int virtualNodeCount) { ring = new TreeMap(); this.</description></item><item><title>Json Web Token</title><link>https://redscarf.me/jwt/</link><pubDate>Wed, 09 Oct 2019 22:15:32 +1000</pubDate><guid>https://redscarf.me/jwt/</guid><description/></item><item><title>HTTPS 单向/双向认证</title><link>https://redscarf.me/https-uni-bidirectional-authentication/</link><pubDate>Tue, 08 Nov 2016 20:09:40 +1000</pubDate><guid>https://redscarf.me/https-uni-bidirectional-authentication/</guid><description>HTTPS HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。
Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。
SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。
单向认证 客户端校验服务端证书
client hello 客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。
server hello 服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。
authentication 客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。
send premaster key 客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。
decrypt premaster key 服务端解密 premaster key
create session key 客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。
client send finished 客户端使用 session key 加密一条 finished 消息并发送给服务端。</description></item></channel></rss>