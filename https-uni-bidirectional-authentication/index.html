<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>HTTPS 单向/双向认证 - Haisheng Wu's Tech Blog</title><meta name=description content="This is Haisheng Wu's Tech Blog"><meta property="og:title" content="HTTPS 单向/双向认证"><meta property="og:description" content="HTTPS HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。
Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。
SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。
单向认证 客户端校验服务端证书
  client hello 客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。
  server hello 服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。
  authentication 客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。
  send premaster key 客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。
  decrypt premaster key 服务端解密 premaster key
  create session key 客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。"><meta property="og:type" content="article"><meta property="og:url" content="http://www.redscarf.me/https-uni-bidirectional-authentication/"><meta property="og:image" content="http://www.redscarf.me/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-11-08T20:09:40+10:00"><meta property="article:modified_time" content="2016-11-08T20:09:40+10:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://www.redscarf.me/logo.png"><meta name=twitter:title content="HTTPS 单向/双向认证"><meta name=twitter:description content="HTTPS HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。
Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。
SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。
单向认证 客户端校验服务端证书
  client hello 客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。
  server hello 服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。
  authentication 客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。
  send premaster key 客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。
  decrypt premaster key 服务端解密 premaster key
  create session key 客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://www.redscarf.me/https-uni-bidirectional-authentication/><link rel=prev href=http://www.redscarf.me/ios-hook-uiwebview-delegate-method/><link rel=next href=http://www.redscarf.me/three-common-mistakes-of-the-first-time-tech-lead/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"HTTPS 单向/双向认证","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/www.redscarf.me\/https-uni-bidirectional-authentication\/"},"genre":"posts","keywords":"web, Security, iOS, nginx","wordcount":513,"url":"http:\/\/www.redscarf.me\/https-uni-bidirectional-authentication\/","datePublished":"2016-11-08T20:09:40+10:00","dateModified":"2016-11-08T20:09:40+10:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Haisheng Wu"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Haisheng Wu's Tech Blog"></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/>Home </a><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/about/>About Me </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Haisheng Wu's Tech Blog"></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/ title>Home</a><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/about/ title>About Me</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">HTTPS 单向/双向认证</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>Haisheng Wu</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/web/><i class="far fa-folder fa-fw"></i>web</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2016-11-08>2016-11-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 513 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 3 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#https>HTTPS</a></li><li><a href=#单向认证>单向认证</a></li><li><a href=#双向认证>双向认证</a></li><li><a href=#证书校验什么>证书校验什么</a></li><li><a href=#nginx-配置双向认证>nginx 配置双向认证</a></li><li><a href=#ios-客户端>iOS 客户端</a></li><li><a href=#postman-客户端>Postman 客户端</a></li><li><a href=#https-办不到的事情>HTTPS 办不到的事情</a></li></ul></nav></div></div><div class=content id=content><h2 id=https>HTTPS</h2><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg data-srcset="https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg, https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg 1.5x, https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg 2x" data-sizes=auto alt=https://github.com/iCocoa/blog-diagram/raw/main/http.drawio.svg title=http&amp;amp;https></p><p>HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。</p><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。</p><p>SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg data-srcset="https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg, https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg 1.5x, https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg 2x" data-sizes=auto alt=https://images.ctfassets.net/slt3lc6tev37/34iiS7GovwS9tVEBisLVWb/65b0f7a31632a52ba6047c9d38daff0e/asymmetric-encryption.svg title=asymmetric-encryption></p><h2 id=单向认证>单向认证</h2><p>客户端校验服务端证书</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg data-srcset="https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg, https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg 1.5x, https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg 2x" data-sizes=auto alt=https://github.com/iCocoa/blog-diagram/raw/main/unidirectional-authentication.drawio.svg title=unidirectional-authentication></p><ol><li><p><strong>client hello</strong>
客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。</p></li><li><p><strong>server hello</strong>
服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。</p></li><li><p><strong>authentication</strong>
客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。</p></li><li><p><strong>send premaster key</strong>
客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。</p></li><li><p><strong>decrypt premaster key</strong>
服务端解密 premaster key</p></li><li><p><strong>create session key</strong>
客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。</p></li><li><p><strong>client send finished</strong>
客户端使用 session key 加密一条 finished 消息并发送给服务端。</p></li><li><p><strong>server send finished</strong>
服务端使用 session key 加密一条 finished 消息并发送给客户端。</p></li><li><p><strong>symmetric encrypt communication</strong>
使用对称加密来进行通信。</p></li></ol><h2 id=双向认证>双向认证</h2><p>客户端校验服务端证书 + 服务端校验客户端证书</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/iCocoa/blog-diagram/raw/main/bidirectional-authentication.drawio.svg data-srcset="https://github.com/iCocoa/blog-diagram/raw/main/bidirectional-authentication.drawio.svg, https://github.com/iCocoa/blog-diagram/raw/main/bidirectional-authentication.drawio.svg 1.5x, https://github.com/iCocoa/blog-diagram/raw/main/bidirectional-authentication.drawio.svg 2x" data-sizes=auto alt=https://github.com/iCocoa/blog-diagram/raw/main/bidirectional-authentication.drawio.svg title=bidirectional-authentication></p><ol start=8><li><strong>verify certificate(digital signature)</strong>
客户端发送一个 CertificateVerify 消息，这是使用客户端证书的私钥对前一个握手消息的签名。这个签名可以通过使用客户端证书的公钥进行验证。这样服务端就知道客户端可以访问证书的私钥，亦即拥有该证书。</li></ol><h2 id=证书校验什么>证书校验什么</h2><ol><li>验数字签名</li></ol><p>客户端发送一个“Certificate Verify”消息，其中包含前一个握手消息的数字签名副本。此消息使用客户端证书的私钥进行签名。服务器可以使用客户端的公钥(在客户端证书中找到)来验证数字签名的消息摘要。一旦验证了数字签名，服务器就知道属于客户端的公钥与用于创建签名的私钥相匹配。</p><ol start=2><li>验证书链</li></ol><p>服务端维护一个受信任的ca列表，该列表决定服务端将接受哪些证书。服务端将使用来自CA证书的公钥(在其可信CA列表中)来验证CA对所提供证书的数字签名。如果消息摘要已经更改，或者公钥与用于签名证书的CA私钥不对应，则验证失败，握手终止。</p><ol start=3><li>验有效期</li></ol><p>服务端将当前日期与证书中列出的有效期进行比较。如果过期日期没有通过，当前日期在期限内，那么一切都好。如果不是，则验证失败，握手终止。</p><ol start=4><li>验证书撤销状态</li></ol><p>服务端将客户端证书与系统中已撤销的证书列表进行比较。如果客户端证书在列表中，则验证失败，握手终止。</p><h2 id=nginx-配置双向认证>nginx 配置双向认证</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>listen       443;
server_name  localhost;
ssl on;
ssl_certificate      /usr/local/opt/nginx/certificates/server.cer;
ssl_certificate_key  /usr/local/opt/nginx/certificates/server.key.pem;
ssl_client_certificate /usr/local/opt/nginx/certificates/ca.cer;
ssl_verify_client    on;
</code></pre></td></tr></table></div></div><p>开启 ssl
ssl_certificate 是服务端证书的路径，ssl_certificate_key是服务端私钥的路径
ssl_verify_client 是配置双向认证（client certificate）
ssl_client_certificate 是签发客户端证书的根证书</p><blockquote><p>为什么是根证书，因为可以签发很多客户端证书，只要是由该根证书签发的，服务端都视为认证通过</p></blockquote><p>配置完成以后，一般需要把80端口的http请求跳转到443端口，否则用户可以通过80端口以http方式访问，就失去了安全保护的意义</p><h2 id=ios-客户端>iOS 客户端</h2><ol><li>使用 NSURLSession 发出一个 https 请求</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    
NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];
    
NSURL *url = [NSURL URLWithString:@&#34;https://localhost/test&#34;];

NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];
[request setCachePolicy:NSURLRequestReloadIgnoringLocalCacheData];
[request setHTTPShouldHandleCookies:NO];
[request setTimeoutInterval:30];
[request setHTTPMethod:@&#34;GET&#34;];
    
NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
    NSString *message = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@&#34;%@&#34;, message);
}];
    
[task resume];
</code></pre></td></tr></table></div></div><ol start=2><li>认证处理</li></ol><p>握手阶段回调方法两次，一次是 server 认证，一次是 client 认证。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSString *method = challenge.protectionSpace.authenticationMethod;
    NSLog(@&#34;%@&#34;, method);
    
    // 服务端证书认证
    if([method isEqualToString:NSURLAuthenticationMethodServerTrust]){
        
        NSString *host = challenge.protectionSpace.host;
        NSLog(@&#34;%@&#34;, host);
        
        NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
        completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
        return;
    }

    // 客户端证书
    NSString *thePath = [[NSBundle mainBundle] pathForResource:@&#34;client&#34; ofType:@&#34;p12&#34;];
    NSData *PKCS12Data = [[NSData alloc] initWithContentsOfFile:thePath];
    CFDataRef inPKCS12Data = (CFDataRef)CFBridgingRetain(PKCS12Data);
    SecIdentityRef identity;
    
    // 读取p12证书中的内容
    OSStatus result = [self extractP12Data:inPKCS12Data toIdentity:&amp;identity];
    if(result != errSecSuccess){
        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
        return;
    }
    
    SecCertificateRef certificate = NULL;
    SecIdentityCopyCertificate (identity, &amp;certificate);
    
    const void *certs[] = {certificate};
    CFArrayRef certArray = CFArrayCreate(kCFAllocatorDefault, certs, 1, NULL);
    
    NSURLCredential *credential = [NSURLCredential credentialWithIdentity:identity certificates:(NSArray*)CFBridgingRelease(certArray) persistence:NSURLCredentialPersistencePermanent];
    
    completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
}

- (OSStatus)extractP12Data:(CFDataRef)inP12Data toIdentity:(SecIdentityRef*)identity {
    
    OSStatus securityError = errSecSuccess;
    
    CFStringRef password = CFSTR(&#34;the_password&#34;);
    const void *keys[] = { kSecImportExportPassphrase };
    const void *values[] = { password };
    
    CFDictionaryRef options = CFDictionaryCreate(NULL, keys, values, 1, NULL, NULL);
    
    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);
    securityError = SecPKCS12Import(inP12Data, options, &amp;items);
    
    if (securityError == 0) {
        CFDictionaryRef ident = CFArrayGetValueAtIndex(items,0);
        const void *tempIdentity = NULL;
        tempIdentity = CFDictionaryGetValue(ident, kSecImportItemIdentity);
        *identity = (SecIdentityRef)tempIdentity;
    }
    
    if (options) {
        CFRelease(options);
    }
    
    return securityError;
}
</code></pre></td></tr></table></div></div><h2 id=postman-客户端>Postman 客户端</h2><p>配置路径：偏好设置 》 证书 》 添加客户端证书</p><h2 id=https-办不到的事情>HTTPS 办不到的事情</h2><ul><li>隐藏要访问的站点名称</li></ul><p>这是因为网站的名称(又名“域名”)是通过DNS(域名服务)发送的，而DNS(域名服务)不在HTTPS隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称(例如 google.com)，只是不能读取任何来回传输的实际内容。除非采用 <a href=https://www.icann.org/resources/pages/dnssec-what-is-it-why-important-2019-03-05-en target=_blank rel="noopener noreferrer">DNSSEC</a> 。</p><ul><li>防止访问恶意网站</li></ul><p>HTTPS并不能确保网站本身是安全的。仅仅因为连接安全并不意味着你不会连接到一个由不法分子运营的网站。</p><ul><li>提供匿名性（IP、物理位置）</li></ul><p>HTTPS 不会隐藏物理位置或个人身份。个人 IP 地址不能加密，因为如果 IP 地址也被加密了，互联网就不知道该把它发送到哪里。而且它也不会在你访问的网站上掩盖你的身份，你访问的网站仍然知道你的一切。</p><ul><li>防止感染病毒</li></ul><p>HTTPS 不是过滤器，所以会有可能在 HTTPS 连接中收到病毒或木马。如果网络服务器被感染，病毒就会像其他报文一样被发送到 HTTPS 流中。然而，HTTPS确实阻止了中间人向流量中注入木马。</p><ul><li>防止电脑被黑</li></ul><p>HTTPS 仅在数据在客户端和服务端之间传输时提供安全保证，如果有恶意软件在监控连接的一端的流量，它仍然可以读取加密之前和之后的 HTTPS 流。</p><p>参考链接</p><ul><li><a href=https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_handshake target=_blank rel="noopener noreferrer">Wikipedia, Transport Layer Security</a></li><li><a href=http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html target=_blank rel="noopener noreferrer">first-few-milliseconds-of-https</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2016-11-08</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/https-uni-bidirectional-authentication/index.md target=_blank rel="noopener noreferrer">阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证" data-hashtags=web,Security,iOS,nginx><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-hashtag=web><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证"><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证" data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=http://www.redscarf.me/https-uni-bidirectional-authentication/ data-title="HTTPS 单向/双向认证"><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/web/>web</a>,&nbsp;<a href=/tags/security/>Security</a>,&nbsp;<a href=/tags/ios/>iOS</a>,&nbsp;<a href=/tags/nginx/>nginx</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/ios-hook-uiwebview-delegate-method/ class=prev rel=prev title="iOS Hook WebView 的代理方法"><i class="fas fa-angle-left fa-fw"></i>iOS Hook WebView 的代理方法</a>
<a href=/three-common-mistakes-of-the-first-time-tech-lead/ class=next rel=next title=第一次成为技术主管易犯的3个常见错误>第一次成为技术主管易犯的3个常见错误<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.85.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/sunt-programator/CodeIT target=_blank rel="noopener noreferrer" title="CodeIT 0.2.10"><i class="fas fa-laptop-code fa-fw"></i> CodeIT</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer">Haisheng Wu</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=https://redscarf.disqus.com/embed.js defer></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:1e3},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>