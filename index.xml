<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Haisheng Wu's Tech Blog</title><link>https://redscarf.me/</link><description>Recent content on Haisheng Wu's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 05 Feb 2025 21:53:32 +1000</lastBuildDate><atom:link href="https://redscarf.me/index.xml" rel="self" type="application/rss+xml"/><item><title>IntelliJ IDEA 集成 DeepSeek 辅助编程</title><link>https://redscarf.me/ai-idea-deepseek/</link><pubDate>Wed, 05 Feb 2025 21:53:32 +1000</pubDate><guid>https://redscarf.me/ai-idea-deepseek/</guid><description>在人工智能辅助编程工具日益普及的今天，DeepSeek 以其卓越的性能和实惠的价格在开发者社区中迅速走红。作为一名从 DeepSeek v1 就开始使用的资深用户，我见证了它在代码生成、问题解答和开发建议等方面的持续进步。当时为什么选择用它？一方面，与 ChatGPT 相比，DeepSeek 不仅提供了更具竞争力的 API 定价策略，其网页版对话应用更是完全免费。另一方面，经过与国内其他同类产品的深入对比测试，我发现 DeepSeek 的回复更加简洁精准，特别适合技术场景下的使用需求。
随着 DeepSeek-R1 版本的发布，其性能指标在多个基准测试中均表现出显著优势。本文将详细介绍如何将这一强大的 AI 模型集成到 IntelliJ IDEA 中，为您的开发工作流程注入新的活力。
环境准备 在开始集成之前，请确保您的开发环境满足以下要求：
IntelliJ IDEA 2023 或更高版本 （注：较早版本的 IDEA 可能无法完全支持 codeGPT 插件的 UI 显示） 下载地址：IntelliJ IDEA 官方下载页面
安装 codeGPT 插件 codeGPT 是一个功能强大的插件，它充当了 IDE 与 AI 模型之间的桥梁。通过它，开发者可以直接在 IDE 中调用 DeepSeek 的服务。
安装步骤：
打开 IntelliJ IDEA 进入插件市场（File -&amp;gt; Settings -&amp;gt; Plugins） 搜索 &amp;ldquo;codeGPT&amp;rdquo; 并安装 重启 IDE 完成安装 获取 DeepSeek API 密钥 访问 DeepSeek 开发者平台：https://platform.</description></item><item><title>抽象泄露法则</title><link>https://redscarf.me/code-leaky-abstractions/</link><pubDate>Sat, 11 Jan 2025 20:15:32 +1000</pubDate><guid>https://redscarf.me/code-leaky-abstractions/</guid><description>在 AI 时代，开发效率大幅提升。某团队借助 AI 辅助开发，仅用 5 分钟便完成了一个新功能的开发，初看运行正常。然而，在某些特定场景下，功能却出现了意料之外的问题。团队花了半天时间排查，才发现问题的根源深藏于底层实现之中——本以为可以忽略的细节，最终却成了最大的坑。
另一边，某系统突发线上故障，业务开发人员求助平台开发人员，期待快速定位问题。然而，平台开发人员查看后表示：“底层代码没有问题，业务侧再看看。” 业务开发团队只好继续摸索，试图在复杂的调用链与抽象层中找到线索。原本清晰分工的技术栈，在关键时刻变得模糊不清，底层的复杂性不可避免地泄露出来。
软件世界就是一层抽象套着另一层抽象的千层饼，就好像 HTTP 协议下有 TCP、TCP 下有 IP，每一层抽象都声称自己是完美的：“你无需关注在我之下的任何细节”。
但事实却是，所有抽象必定泄露。而当抽象泄露时，就像要从 AI 的 1000 行代码里找到那个错误——事情非常棘手，但我们别无选择。
早在 2002 年，程序员 Joel Spolsky 就敏锐地发现了这类现象，并将它们总结为：“抽象泄露法则”。
译文如下：
抽象泄露法则 作者：Joel Spolsky
日期：2002年11月11日，星期一
互联网工程中有一项关键的魔法，你每天都在依赖它。这种魔法发生在TCP协议中，TCP是互联网的基础构建模块之一。
TCP是一种可靠的数据传输方式。我的意思是：如果你通过网络使用TCP发送一条消息，它将会到达目的地，并且不会出现乱码或损坏。
我们使用TCP来做很多事情，比如获取网页和发送电子邮件。TCP的可靠性确保了每一封来自东非诈骗者的激动人心的电子邮件都能以完美的状态送达。哦，真是令人欣喜。
相比之下，还有一种称为IP的数据传输方式，它是不可靠的。没有人保证你的数据会到达目的地，而且数据在到达之前可能会被搞乱。如果你用IP发送一堆消息，不要惊讶只有一半的消息到达，而且其中一些消息的顺序与发送时的顺序不同，还有一些消息可能被替换为其他内容，或许是可爱的猩猩宝宝图片，或者更可能只是一堆无法阅读的垃圾，看起来像台湾垃圾邮件的主题行。
这里的神奇之处在于：TCP是建立在IP之上的。换句话说，TCP必须通过一种不可靠的工具来可靠地发送数据。
为了说明这为什么是魔法，请考虑以下道德上等效但有些荒谬的现实世界场景。
想象一下，我们有一种将百老汇演员送到好莱坞的方式，方法是把他们塞进车里，然后开车穿越全国。有些车会撞毁，可怜的演员因此丧生。有时演员在路上喝醉了，剃了光头或纹了鼻环，结果变得太丑无法在好莱坞工作。而且，演员们到达的顺序通常与他们出发的顺序不同，因为他们都走了不同的路线。现在想象一种名为“好莱坞快线”的新服务，它保证将演员送到好莱坞，并确保他们（a）到达，（b）按顺序到达，（c）状态完好。神奇之处在于，好莱坞快线没有任何其他方法可以运送演员，除了将他们塞进车里并开车穿越全国这种不可靠的方式。好莱坞快线的工作原理是检查每个演员是否完好无损地到达，如果没有，就打电话给总部，要求发送该演员的同卵双胞胎代替。如果演员到达的顺序不对，好莱坞快线会重新排列他们。如果一架飞往51区的大型UFO在内华达州的高速公路上坠毁，导致道路无法通行，所有走那条路的演员都会通过亚利桑那州重新安排路线，而好莱坞快线甚至不会告诉加利福尼亚的电影导演发生了什么。对他们来说，演员只是比平时到得慢了一点，他们甚至从未听说过UFO坠毁事件。
这大致就是TCP的魔法。它是计算机科学家喜欢称之为“抽象”的东西：一种对底层复杂事物的简化。事实证明，许多计算机编程工作都涉及构建抽象。什么是字符串库？它是一种假装计算机可以像操作数字一样轻松操作字符串的方式。什么是文件系统？它是一种假装硬盘并不是一堆可以存储比特的旋转磁性盘片，而是一个由文件夹嵌套文件夹组成的层次系统，其中包含由一或多个字节串组成的单个文件。
回到TCP。为了简单起见，我之前撒了一个小谎，现在可能有些人已经气得冒烟了，因为这个谎言让你抓狂。我说TCP保证你的消息会到达。实际上，它并不保证。如果你的宠物蛇咬断了连接到你电脑的网络电缆，导致没有IP数据包可以通过，那么TCP对此无能为力，你的消息也不会到达。如果你对公司的系统管理员态度粗鲁，他们惩罚你，把你连接到一个过载的集线器上，那么只有部分IP数据包能通过，TCP仍然可以工作，但一切都会变得非常慢。
这就是我所说的“抽象泄漏”。TCP试图提供一个对底层不可靠网络的完整抽象，但有时，网络会通过抽象泄漏暴露出来，你会感受到那些抽象无法完全保护你免受的影响。这只是我称之为“抽象泄漏法则”的一个例子：
所有非平凡的抽象，在某种程度上，都是有泄漏的。
抽象会失效。有时是小问题，有时是大问题。泄漏会出现。事情会出错。当你使用抽象时，这种情况无处不在。以下是一些例子。
即使是遍历一个大的二维数组这样简单的事情，如果你水平遍历而不是垂直遍历，性能可能会有天壤之别，这取决于“木纹的方向”——一个方向可能会导致比另一个方向多得多的页面错误，而页面错误是很慢的。即使是汇编程序员也被允许假装他们有一个大的平坦地址空间，但虚拟内存意味着它实际上只是一个抽象，当发生页面错误时，某些内存访问会比其他的多花很多纳秒，这时抽象就出现了泄漏。
SQL语言旨在抽象出查询数据库所需的过程步骤，而是让你只需定义你想要的内容，并让数据库自行找出查询的过程步骤。但在某些情况下，某些SQL查询比其他逻辑上等效的查询慢数千倍。一个著名的例子是，在某些SQL服务器上，如果你指定“where a=b and b=c and a=c”，查询速度会比只指定“where a=b and b=c”快得多，尽管结果集是相同的。你本不应该关心过程，只需关心规范。但有时抽象会泄漏，导致性能极差，你不得不拿出查询计划分析器，研究它哪里出了问题，并找出如何让你的查询运行得更快。
尽管像NFS和SMB这样的网络库让你可以像对待本地文件一样对待远程机器上的文件，但有时连接会变得非常慢或中断，文件就不再表现得像本地文件一样，作为程序员，你必须编写代码来处理这种情况。“远程文件与本地文件相同”的抽象出现了泄漏。这里有一个针对Unix系统管理员的具体例子。如果你将用户的主目录放在NFS挂载的驱动器上（一种抽象），而用户创建了.forward文件以将所有电子邮件转发到其他地方（另一种抽象），当新邮件到达时，如果NFS服务器宕机，邮件将不会被转发，因为.forward文件将无法找到。抽象中的泄漏实际上导致了一些邮件被丢弃。
C++字符串类本应让你假装字符串是一等数据。它们试图抽象出字符串的复杂性，让你感觉它们像整数一样容易操作。几乎所有的C++字符串类都重载了+操作符，因此你可以写s + &amp;ldquo;bar&amp;quot;来进行连接。但你知道吗？无论它们多么努力，地球上没有任何一个C++字符串类能让你输入&amp;quot;foo&amp;rdquo; + &amp;ldquo;bar&amp;rdquo;，因为C++中的字符串字面量始终是char*，而不是字符串。抽象出现了泄漏，而语言本身不允许你修补它。（有趣的是，C++的演变历史可以被描述为试图修补字符串抽象泄漏的历史。为什么他们不能在语言本身中添加一个原生的字符串类，这让我一时难以理解。）
而且，下雨时你也不能开得太快，尽管你的车有雨刷、头灯、车顶和暖气，这些都让你不必关心下雨的事实（它们抽象了天气），但瞧，你必须担心打滑（在英国称为“水上漂”），有时雨太大，你看不清前方，所以你只能在雨中开得更慢，因为天气永远无法被完全抽象掉，这就是抽象泄漏法则的作用。
抽象泄漏法则之所以成问题，原因之一是它意味着抽象并没有像预期那样真正简化我们的生活。当我培训某人成为C++程序员时，如果我能永远不必教他们关于char和指针运算的知识，那将是非常好的。如果我能直接跳到STL字符串，那将是非常好的。但有一天他们会写&amp;quot;foo&amp;quot; + &amp;ldquo;bar&amp;quot;这样的代码，然后真正奇怪的事情会发生，那时我将不得不停下来教他们所有关于char的知识。或者有一天，他们会尝试调用一个Windows API函数，该函数的文档显示它有一个OUT LPTSTR参数，直到他们学习了char*、指针、Unicode、wchar_t和TCHAR头文件等知识，他们才能理解如何调用它。所有这些泄漏都会暴露出来。
在教某人COM编程时，如果我能只教他们如何使用Visual Studio向导和所有代码生成功能，那将是非常好的。但如果出现问题，他们将完全不知道发生了什么，也不知道如何调试和恢复。我将不得不教他们所有关于IUnknown、CLSID、ProgID等的知识……哦，真是让人头疼！
在教某人ASP.NET编程时，如果我能只教他们可以双击某些东西，然后编写在用户点击这些内容时在服务器上运行的代码，那将是非常好的。事实上，ASP.NET抽象了处理点击超链接（&amp;lt;a&amp;gt;）的HTML代码和处理点击按钮的代码之间的区别。问题是：ASP.NET的设计者需要隐藏一个事实，即在HTML中，没有办法通过超链接提交表单。他们通过生成几行JavaScript代码并将onclick处理程序附加到超链接上来实现这一点。然而，抽象出现了泄漏。如果最终用户禁用了JavaScript，ASP.NET应用程序将无法正常工作，如果程序员不理解ASP.NET抽象了什么，他们将完全不知道哪里出了问题。
抽象泄漏法则意味着，每当有人提出一个花哨的新代码生成工具，声称能让我们变得非常高效时，你会听到很多人说：“先学会手动操作，然后再用花哨的工具来节省时间。”那些假装抽象某些东西的代码生成工具，像所有抽象一样，都是有泄漏的，而唯一能有效处理这些泄漏的方法是学习抽象的工作原理以及它们抽象了什么。因此，抽象节省了我们工作的时间，但它们并没有节省我们学习的时间。
这一切意味着，尽管我们有了越来越高级的编程工具和越来越好的抽象，但成为一名熟练的程序员却变得越来越难。</description></item><item><title>付鹏11月24日在HSBC内部演讲速记</title><link>https://redscarf.me/economy-fp-hsbc/</link><pubDate>Sat, 30 Nov 2024 22:15:32 +1000</pubDate><guid>https://redscarf.me/economy-fp-hsbc/</guid><description>《2024年年终回顾和2025年展望——对冲风险VS软着陆》
上篇
正值年底，虽然刚才汇丰一直强调大家不录音不录像，但大概率你挡不住。我在这儿讲话会谨慎一些，非常小心谨慎，大概率会有人透露出去，放到YouTube上，基本上所有见我都说付总我在YouTube上看过你的视频，我说那都是盗版的，靠盗版发财的也不少。
今天和大家分享的内容基本上都是官方的，回顾会多一点，展望不多，因为这个月展望完了之后下个月怎么办？有些话对我来讲我倒觉得很简单，本质上原来我们是做Hedge Fund出身，所以我们的逻辑框架整体具有极强的延续性，不是说今年去讨论，或者说明年去讨论。
惯性思维从2016年开始，我一直在跟大家强调这个世界已经完全不一样了。当然经历过过去的几年时间，我相信在座各位应该对这番话的理解变得越发深刻。
2016年实际上是美国特朗普的第一次大选，我有一个特点，我的特征是如果我觉得什么地方有投资机会，我可能第一时间去一线调研，我不喜欢看YouTube，我也不喜欢在网上扒。当然你会说，现在ChatGPT很强大了，人工智能好像能帮你解决很多问题，但你们有没有想过，可能广泛流传或者广泛传播的很多信息是错的。这一点在2012年当时我从日本做完调研回来之后，我的感悟是最深的。
当然去日本有一个重要的人物，名字叫本森特，很快大家就会非常熟悉他的，目前来讲应该是特朗普政府提名的美国财长。本森特原来是索罗斯基金实际掌控人，因为索大爷已经年龄很大了，去年的时候才刚刚把基金的业务交给他儿子亚历山大，但在这之前，最主要的几场战役本质上来讲都是本森特在主导。
2012年当时我从北京去香港约朋友们吃饭的饭局上，当时斯索罗斯基金在香港办公室跟我说，本森特从这儿去了日本。我说OK。我经常说一句话“站在巨人的肩膀上看问题。”
当然你知道，网民们最可怕的地方是巴菲特“SB”、索罗斯“SB”，我最“牛逼”。你要记住，他们的所有行为一定有很大的变化，很多人可能都不知道，巴菲特第一次去是2011年，我们正在讲福岛核电站泄漏，核废水污染以后海鲜不能吃的时候，一个80多岁的老头顶着核辐射泄漏去日本吃海鲜了，当然他去日本干吗，这其实很关键。
之后我们跑到日本做完调研回来之后那几年，我陆陆续续跟很多人讲，日本正在发生变化，日本的利率结构都会随之变化的，当然包括日本的证券市场。今年日本股市终于走出这35年了，创下了历史性纪录。
但网上很多人还在说，我从经济数据里好像没看出什么状况来，这就是我们说的“信息差”，因为有时候你知道人的理解，对社会的理解，对经济的理解带有惯性思维。前几年我经常普及的一点是关于日本的理解，很多人总在想经济增长，有没有一种可能性经济不增长也很爽呢？比如说中国过去三四十年改革开放之后我们习惯的就是经济要增长，经济不增长我们就很难过，你有没有想过一种不增长还会把蛋糕吃多的方法呢？答案是分配，你怎么老想着分工、努力、工作、干活儿、挣钱、增长，有没有另外一种可能性是进行再分配？
你对日本的理解为什么要增长？用我的话说在过去30年的时间里保持着这块蛋糕没有变，但现在远端利率抬起来的根本原因是因为年轻人可以吃多了，年轻人为什么可以吃多了？你们知道2012年日本的死亡数据是什么吗？你有注意过他的人口结构变化吗？到了今天为止，你突然之间发现日本现在招聘怎么会是应聘的在下面坐着，招聘的在上面站着？放心，中国现在不是招聘的问题，是HR砍人的问题，这种变化的根因到底来自于什么？其实很多人只是惯性思维，你不一定能看懂世界。
过去40年已经发生翻天覆地的变化了，从2016年开始，中国也不再是过去40年的中国，美国也不再是过去40年的美国，日本也不再是过去40年的日本，东南亚也不再是过去40年的东南亚，你资本运转的逻辑框架都在发生着巨变，而这种时刻下，如果你保持着过去的思维，你并不能理解我在讲什么。
我只能说，大家一切看缘分，我不需要完全说“付总在胡说，我并不认同”，无所谓的，你能听懂你就听懂，你能早理解你就早理解，早理解你就能顺着这条线Get到2016年之后世界发生的巨变。
最新的美国大选，特朗普重新上来，但这次上来跟2016年又不一样了，因为他比2016年变的更加右翼化了，2016年大的政治转变本质上就是逆全球化和右翼化。2016年我把我自己的书稿整理过一版，当年也没空没时间把这个东西出版，去年因为我们家孩子回来以后做了传媒公司，原则上来讲我就把书稿送给他作为传媒公司的一部分出版业务去做，这就是大家后来见到的《见证逆潮》。但这本书不完整，全文将近70万字，你们拿到手的只有50万字，中间差不多有20万字被删减掉了，这20万字其实非常关键，涉及到我们对世界大类资产顶层逻辑的核心框架，金字塔究竟是什么？底层是我们的所有资产和市场，市场其实是在框架中最底层的，大家天天想问的房价的上涨、股票价格，这实际上是金字塔中最底层的。
稍微往上一点有人说宏观经济很重要，尤其是中国2008年次贷危机结束之后，中国的投资人开始发生巨变，2008年金融危机之前，中国大部分投资人讲的是“擒龙大法”，如何抓涨停。但2008年的次贷危机，全球的冲击使得很多从事金融交易、资产交易的人开始意识到，原来全球金融市场是这样的，是联动的。自那一刻起，真正意义上的金融才开始在中国慢慢生根发芽。
稍微有人开始意识到宏观经济的重要性，当然像现在证监会的首经团队中，36个首经里，我一直说我是那个最不正经的，因为我又不是搞学术的，我也不是搞政府出身的，我是市场一线的，我们对很多问题的理解是完全不同的。
前两天的时候，在Fox News上，本森特和几个诺贝尔经济学家在那儿争吵关于关税作用的时候，你就突然间发现，一个站在市场角度上的人理解关税作为一个手段到底起到什么样的作用，和那帮老学究们去讲的，甚至跟在座各位在新闻联播上看到的关税描述“美帝国主义打关税，使得老百姓生活在水深火热中”，你会发现好像你聪明点的话就知道好多东西并不对，这就是差异性。这次特朗普组成的第一是实权派，第二是通杀了，可以理解右翼化已经完全没有牵制了，第三上来的全是实干派。你猜后面的结果是什么？这场仗可不好打，比2016年那一届还难拿。
再往上是什么呢？有人说终于讲到了政治，没错，再往上是政治，民主党、共和党、全球政治的变动。但再往上的顶层，金字塔的最核心是什么东西？实际上是意识形态。
我教很多研究员说你们在研究世界经济的时候别盲目地做简单的对比，我估计很多研究报告都会犯这样的错误，动不动就做对比，和70年代、80年代做对比，这种对比纯粹写报告凑字数的，换成我的角度，我都不会看完直接撕了就扔垃圾桶了，我其实挺心疼这些券商研究员的，为什么呢？是个事儿就得写个报告，写个报告就得好几万字，好辛苦，结果还没人看。
顶层断代，也就是大家经常讲的周期性的断代到底是什么？你记住一点，顶层的断代是意识形态，社会政治的发展本质上是群体性意识形态的周期，也就是大家学过的思想政治课中的“左”和“右”，左倾右倾、左派右派、左翼右翼、集体个体，这些东西的变动才是世界经济周期的最大变动。
当前是什么？大领导讲的那句话很对，百年之未有大变局（百年未有之大变局），基本上就是1929年大萧条到二战后完整一个周期的结束。全球从二战的极端右翼，慢慢发展到中右，再偏向中左，再到差不多这20年左右的极端左翼化，最终导致重新开始右翼，这个世界很有意思，没有任何方向是绝对正确的。
我一直告诫大家，你们不要在网上争吵，我站在左边，你站在右边，PK，非得讨论出谁最牛逼，谁最正确，没有。就好像你想找个女朋友，又漂亮，腿又长，胸又大，腰又细，还有钱，还特别爱你，你想多了，挑一样就行了，完美主义哪儿有？最终的结果就是在运动的过程中对政治造成影响，进而对经济造成影响，进而对金融市场造成影响，一定记住金字塔的逻辑。
大部分时间我们不用Care顶层，因为在过去百年，顶层的方向是固定的，就是从极端右翼不断向左翼在运动，所以顶层方向不变的情况下就会形成下面的一套运转逻辑。
比如说以美国为代表，你们应该看到Ray Dalio关于债务危机的那本书，里面有个利率曲线，二战前我们的利率就是0，到80年代利率达到顶峰，2008年次贷危机到疫情期间利率再次达到0。利率的低点到底是什么意思？为什么在过去的百年历史里，利率的低点总是战争的起点？是有原因的，因为利率的本质实际上就是贫富差距，利率越低的时候，贫富差距越大的，利率越高的时候，贫富差距越小的。
当然，我们每个人都是屁股决定脑袋，比如大家手上拿着一堆金融资产，拿着一堆杠杆，我可以告诉你，你永远高呼的是低利率是对的，就好像大家对于美国的理解一样，永远认为美国在过去的40年的逻辑就是不能加息，加息就崩溃，崩溃就降息，利率永远是低的，美元永远是Carry的借贷方，但你从来没有想过这个逻辑会变的。
几年前我跟很多人讲的时候，我说你记住一点，中国从高利率变低利率，海外从低利率变高利率，所谓的几毛档还动不动说付总说了高利率是多少，4-5都是高利率。低利率是多少？0、1、2有多大区别吗？没有的，这是关键的点。有人说非得纠，把我的话直接变成了付总说的，中国不会加息，永远降息，美国永远加息不会降息，降一点加一点，加一点降一点，这不很正常吗？比如特朗普上来了，明年有没有另外一种意外性呢？比如说降了50，降了25，大概回到4.75，5的水平了，突然间又抬回到5.25了，这不正常吗？4和5的纠结不重要，重要的是他不会再回到0、1、2了，这是很关键的。
对于劳动力来讲，利率是很关键的，如果利率的抬升来自于劳动收入的增长，这是好事情。你想想中国，你把时间拨回到20年前，利率高不高？那时候你难受吗？不难受。现在利率低不低？低，你难受吗？你难受。为什么？所以你要知道是通过劳动获得收入还是通过资本杠杆获得收入的，你对利率的感觉完全是反的。
但是整体社会去讨论贫富的时候，贫富主要讨论来自于劳动价值，简单讲，天天外面送外卖跑滴滴的，他们就是失去的一代，在过去的二三十年里，靠劳动力的就是被淘汰的一代，没办法，这是社会发展的必然结果。但是当这种矛盾压力大了，就会转化成社会矛盾，甚至可以通过选票转化成对政治的影响，对意识形态的影响。所以贫富到极端的时候一定会进行修正，无论是极左的贫富还是极右的贫富，都会最终产生矛盾，这就是社会运转的规律。
过去百年发生的这一轮大周期就是完整的周期，到2016年表面上看叫中美贸易战，表面上看是中美两个大国之间所谓的对抗和博弈，其实是全球各个国家内部的矛盾展示，对内是内部的分配，对外是外部的分配。在这个背景下，战争的风险将加大。
前两天，我们也看到了，人类历史上第一次使用了洲际弹道导弹，无非就是前面没挂核弹头而已，仅此。你觉得这个东西离你还很远吗？我们这一代可以说是幸福的一代，但我们这一代也将经历不常见的百年之未有大变局了。
很多人在思考这个世界的时候，真的不要以为我们现在还能回到过去，回不去了，那个全世界包容融合的，不断左翼化推进的，全球化不断推进的路径，这个时代彻底在2016年已经开始结束了。
2016年很多人判断是错误的，总觉得2016年只是一场贸易战，那时候我从华盛顿调研两周回来以后，我跟很多人讲，不是贸易战，不是说哪个党派，民主党、共和党上来对中国就会温和的，不会的，两党的共识，他两者之间只存在着我比你左一点，我比你右一点，但咱俩都是往右的。美国政治的变化核心在于不管民主党和共和党，对中国的压力都是一样的，只不过是他俩谁压力多一点谁压力少一点，谁在外交上压力多一点，谁在经济上压力多一点，仅此而已。
对中国来讲现在也麻烦，在过去的80年代、90年代，西方在不断包容融合右翼化，同时当时的中国也在不断地往右走，当然此处不是指的中国的右倾。注意西方右翼概念和中国完全反的，你们不要觉得是错误的，如果你觉得错误的，你先了解了解什么是左派右派、左倾右倾、左翼右翼。如果你不能理解这个东西，你肯定对左和右在中国和西方的框架里完全是颠倒的。
中国也是朝着包容、融合的，所以我们才有了非常好的入市、WTO、改革开放等一系列的操作。我经常说家庭中女生是天生右翼，右翼有一个典型特征，右翼可以叫民粹，可以叫国家主义，可以叫爱国主义，极端右翼可以叫纳粹。但右翼的特征很明显，“我没错，都是你的错”，这就是右翼。
家庭中女同志天生带有，当然我不是歧视各位女士，这是你们DNA里带的，两个X里带的，如果家庭中男生是左翼，家庭是幸福的，什么意思呢？“老婆，没事儿没事儿，都是我的错”，男生是个左翼，家庭很好，左+右。
如果男女都是左翼，这简直是幸福无比了，男生回家了，女生把拖鞋一放说“老婆你打会儿游戏，我正做饭呢，一会儿做好了叫你洗手吃饭”，这个男同志真的去打游戏了，吃完饭了说“你歇一会儿，看会儿剧，我来把碗洗了。”你可千万别当个大直男，锅一甩又去玩儿了，不行，时间长了，她会右翼化的。
此时你也表现出左翼特征，你家庭就是融合的。家里如果两个右翼就完蛋了，都是你的错我没错，凭什么说是我的错？就是你的错，就是你做错了。直男碰上女生，一般来讲没啥好组合，两个右翼就是战争，打架到离婚。
不要认为这是在讨论家庭、婚姻，同样在讨论国家，同样在讨论全球。当国家和国家之间的组合出现统统左翼化的时候，就是包容、融合、全球化共同增长的俱佳的历史环境，当全是右翼化的时候，就是战争。
我们现在的大麻烦在哪儿？就在这儿。全世界在过去5、6年时间里已经陆陆续续都在右翼化了，右翼化的特征，政治的重要性已经体现出来了，选票回归传统的特征已经体现出来了，反移民的特征已经体现出来了。
我之前说过，这两年全球著名的交易就是“多美国，空加拿大”，原因就是加拿大的小土豆放了那么多印度裔进来，就完蛋了，加拿大的核心矛盾是什么？经济增长创造了五个蛋糕，原本加拿大的国民可以一人吃一个，现在放了10个阿X进来，加拿大问题是分配，当分配不够的时候，一定会趋于保守，一定会趋于右翼化，一定会趋于反移民。
各国都一样，70年代80年代的时候，英国那时候有过排华，现在又开始反穆斯林了，这正常。世界的动荡不是简简单单表现在单纯的资产上，前两天英国又出台了新的政策，你只要非英国国民的，原则上来讲要交遗产税的，英国政府也要收你的遗产税。我之前跟很多富人说，别天天琢磨避税了，包容融合的时候藏点私房钱是没事儿的，当都右翼化的时候，你再藏私房钱你就完蛋了，现在全世界的大麻烦是什么？找个税率低的地方该缴的缴。当年特朗普上来的时候20%只要你愿意回流美国，全部合法化，你看有多少资本往回回流？所以你们知道左翼和右翼大概的框架和特征，这才是我那本书里的真正精髓，但被删掉了。
你把它理解了，你对应的穿透到经济上，穿透到利率上，穿透到资产上，你会门清儿的，这就是大类资产的精髓，真正的精髓。你要问这东西谁创造的，索罗斯那批人，本森特那批人，整体框架大家都是一样的。
我到底在讲什么？其实我就是在讲回顾，因为从那一刻开始，几个问题就在陆陆续续暴露。美国在进行重构，特朗普上来以后方向继续重构，这里面其实就涉及到民主党为什么是错的，民主党的很多政策为什么是极端左翼，左翼政策不一定是对的，右翼为什么会使得美国进入到增长通胀利率的环境。
包括有些华人带有意识形态，我只能说一句话，我们作为全球投资人，最佳的选择是没有任何意识形态，对我来讲，我非常清楚左有左的问题，右有右的问题，左有左的好处，右有右的好处，我不会站在任何一侧。我的答案是全世界选择往左走，我就知道我的交易路径是什么，全世界选择往右走，我也同样知道我的交易路径是什么，但我绝对不会站队说谁是绝对正确的，否则的话就会压错宝。世界有时候不一定按照我们的意识走，美国的这次大选也是典型的结果，其实我也没想到，美国右翼化的速度会这么快，推进速度会如此迅速。本来想的是民主党还能够撑一撑，但现在来看基本上是完败的。
对于中国来讲，当前我们面临的问题不仅仅是外患的问题，还包括了内忧。综合在一起，会有一个非常奇特的答案，之前很多人问我中国到底和日本一不一样？网上这句话炒的纷纷扬扬的，有人说中国就是会走日本的老路，有人说中国不会走日本的老路，你要问我正确的答案，我会告诉你这个问题没有任何意义，为什么？太泛了，如果拆的细一点我能回答你。比如你要问中国的居民部门和日本的居民部门一不一样？我的答案是一样；中国的企业部门跟当年日本的企业部门一样不一样？我的答案是不一样；中国的政府部门和当年日本的政府部门一不一样？我的答案是不一样；中国的金融机构跟当年日本的金融机构不一样？不一样；中国当前面临的国际环境和当时90年日本面临的国际环境一不一样？不一样。
你说最后的答案是什么？如果站在纯居民角度来讲，我可以告诉你99.99%可以复刻，但如果站在大的国际环境上来讲，可能得到的是完全不同于日本的最终答案。用我的话说，你是说一样还是不一样呢？没有意义。
所以我大部分时间给你们分拆的是日本居民部门和中国居民部门的比对。而日本的企业部门、金融部门、发展模型我也给大家分享过，去年你们应该都知道了，巴菲特买三井、三菱、丸红、伊藤忠商社，大笔发行日元债券购入到日本的三井、三菱、丸红、伊藤忠这些资产中，他到底在干吗？
那时候第一财经找我说付总你去讲讲巴菲特为什么买，我发现很多评论人员单纯在讲三井、三菱、丸红、伊藤忠资产怎么样，稍微聪明点的会讲到当年的商社们是日本的海外资产，是日本Carry trade套息交易的主要收入端。再聪明一点的会讲到巴菲特在参与日本过去40年存量财富的再分配。
我可能明年把我们家小儿子送到日本去，我跟他讲的很清楚，我不需要你去学习人工智能、AI，为啥呢？你好像没那么聪明，也不是IT技术男，你把日语学好，能考上应庆就不错了，那里面都是一些日本传统贵族的姑娘，你娶一个就行了，最好她们家都是80岁90岁的，你就躺赢就行，等她们家80岁90岁的明后年一挂，房是你的，股权是你的，土地是你的，财富是你的，存款是你的，咱们就参与日本存量40年财富再分配。巴菲特是用钱去参与，我们用人参与，本质上都一样，你买股票，我把儿子嫁过去，这都是参与财富存量分配。
你们要明白日本的核心究竟是什么？日本的核心是参与分配，而不是参与增长。很多人不太理解，因为他在国内没参与过分配，永远都是增长处在哪个环节，我距离权力近一点，资源近一点，资本近一点，我就多吃点，卖劳动力的就少吃点。当经济增长增速不够的时候，最底层就没饭吃了。经济增长5，可能各个阶层的体感是完全不同的，所以网上会有些人说经济数据造假，真的造假了吗？也许没有。5代表的是整体的蛋糕，而你的体感仅仅代表你的阶层。
在过去几年中国经济的调研中，我们到底做对了什么？
《2024年年终回顾和2025年展望——对冲风险VS软着陆》 中篇
在过去几年中国经济的调研中，我们到底做对了什么？
第一，在2020年疫情后，那时候长白山论坛我跟大家讲的很清楚，我说的非常赤裸裸，中国居民资产负债表出现问题，那时候券商们都很Happy，因为他们永远需要Happy，只能做多。但对于我们做Hedge Fund出身的来讲，我可不能这么做，我这么做我就完蛋了，我的钱在里头。10月8日之后，有人在里头吗？千万别自己麻醉自己，那都扯淡。网上一般来讲，拿所谓的这种东西蒙蒙别人可以，你自己信了就完蛋了，就跟当时“6000点不是梦，1万点刚起步”，记住那话是说给散户听的，你信了那你就完了。核心是什么？从我们的角度非常明确地大家，大家的预期很高，但现实很残酷。
那两年跟各家公募基金每个季度做交流的时候，他们没法去理解现在的经济情况，比如说那时候我跟他们讲网约车司机、外卖，那两年我大量的调研样本参数是底层。经济增长消费扩张升级的时候，调研样本是富人先进五星级酒店，富人先买超跑，富人先吃海鲜，然后你的样本参数是下沉的，到最后是老百姓吃上海鲜，老百姓开上汽车，老百姓进五星级酒店。
但是当经济收缩的时候，倒过来的，第一步先收缩的是底层。我前几年我说每年现在新增几千万的网约车司机，你们都没有想想人从哪儿来的吗？有人说了，农村劳动力进城，我说都啥年代了，还农村劳动力进城，这又不是你当年搞大规模基建城镇化建设的时候缺农民工，把农村劳动力大规模转移过来。现在的农村你去看看，哪儿还有劳动力，除了老弱病残幼以外，还有劳动力吗？你就没想想这两年突然激增的两千万的网约车司机这些人从哪儿来的？答案很简单，中产阶级的陨落。只不过是你的阶层不一样，你看的问题不一样。
很多人的调研很有问题的，很多人说美国通胀导致美国居民部门水深火热，我问他为什么？他说你看我打电话问了我在美国的朋友，他们都很惨。我说那你美国朋友的样本是个什么状态？他一描述，我说那当然惨了，他们以前爽的时候是老公在中国挣着通胀的钱，老婆在那边花着通缩的钱，享受着社会福利保障体系，还不交税。现在倒过来变成了老公在国内挣不着钱了，海外人家上门给你弄个草皮清理一下要多收你50美金一小时，你的钱没增长，花的钱多了，你当然难受。我要是那个铲草皮的，我会告诉你那点通胀算个屁，5块钱的三明治涨到7.5元，翻了50%，对我来讲不重要，重要的是我从你们家弄个草皮，挣50多一个小时，劳动价值提升了。从事劳动的人就很舒服，从事单纯支出的人来讲你就难受了。
你要调研的样本是一样的，前两年的样本收缩的是时候是底层先吃苦，但对宏观经济数据影响不大，你们记住一点。
我就说网约车司机，如果你在广州做调研，他们的特征就是有钱没钱，今天都吃龙江猪脚饭。但注意，北京北四环的网约车司机吃的中午盒饭到多少钱吗？15块钱送瓶水，还带锅包肉，猪肉炖粉条子，耙子肉，嘎嘎香。但你记住一点，千万别问肉多少年，问你就吃不下了，因为基本上都是80年陈酿拉菲，一定是冻肉，一定是冻了20年、10年以上的肉，不然怎么那么便宜。所以你们也不要瞧不起预制菜，我觉得预制菜很好，没有预制菜老百姓日子更苦，有预制菜老百姓好一点，为啥？12块钱能吃饱，还能吃上肉，吃上足够的蛋白质。
你就记住一点，当你都吃12块钱了，你还注意肉多少年吗？现在统计中国在讲需求的时候很有意思，我从来不会用一个数字，从来不会用中国的CPI，中国的CPI一直有一个大的问题，当年宏观经济数据设立的时候中国老百姓第一目标是解决吃穿，解决温饱，所以对我们来讲，物价中的菜价、猪肉价格、粮食价格、油价波动，我们看的比天都大。
那时候一般来讲，领导们下去做慰问的时候，第一件事儿都是去家里掀锅，动作都很标准，打开锅看看你吃啥，这个动作其实就是因为当年我们的重要问题是解决老百姓的吃穿住行，所以我第一件事情就关注你吃的情况。但改革开放下来以后，到现在为止，吃如果都成问题，那就是大问题了。
为什么不用数据？因为数据中这部分的波动很大，这部分的波动已经跟需求没关系了。比如说城市里洪涝，那蔬菜价格那几天就会暴涨，那种变动其实影响已经不重要了。我们现在讲需求，比如中国经济从2019年获得大问题，非常麻烦，你们不要觉得现在的经济问题是现在，是2019年就开始了，在今年是恶化的，所以今年的情况你们都不知道有多严峻，数据里已经告诉你，非常严峻，而在调研的时候更严峻。
8、9月份的时候，必须转向，那时候很多人不理解，因为过去的一年大家都养成了一种习惯，这也是右翼化的特征，右翼化的特征就是我没错都是你的错，我不许你说我错。你想想，家里的老婆你敢说她错吗？到最后男生就是出门抽烟，不吭。</description></item><item><title>应用层数据分布路由算法</title><link>https://redscarf.me/d-route-alg/</link><pubDate>Mon, 11 Nov 2024 20:15:32 +1000</pubDate><guid>https://redscarf.me/d-route-alg/</guid><description>应用层数据分布路由算法主要用于分布式系统中，将数据或请求分配到多个节点（服务器、存储设备或服务实例）上，以实现负载均衡、高可用性和扩展性。常见的有： 哈希取模（Modulo Hashing）、随机路由 (Random Routing)、一致性哈希（Consistent Hashing）等等。
随机路由 (Random Routing) 原理：随机选择一个节点处理请求。
特点： 简单直观，但不能保证均匀分布。 不适合高负载系统，因为可能导致数据倾斜。
应用：用于初步负载均衡或测试场景。
哈希取模（Modulo Hashing） 原理：使用简单的哈希函数对节点数量取模，将请求分配到相应节点。
公式：节点 = Hash(Key) % N，其中 N 是节点数量。
特点：简单高效，易于实现。
缺点：节点增减时，所有数据都需要重新分配，无法满足动态性要求。
应用：适用于小规模系统或节点数固定的场景。
一致性哈希（Consistent Hashing） 原理：将节点和数据映射到一个逻辑环上，数据存储在与其哈希值最接近的节点中。
特点： 高动态性：节点增减时，仅影响邻近的节点，减少数据迁移量。 负载均衡：通过虚拟节点均衡数据分布。
应用： 分布式缓存（如 Memcached、Redis）。 分布式存储（如 Cassandra、Amazon Dynamo）。 微服务负载均衡。
一致性哈希算法实现 一致性Hash首先构建一个Hash 环的结构。环的大小是 0 到2^32-1，也就是无符号整型的取值范围，0 和最后一个 2^32-1 首尾相连，构成一个 Hash 环。将每个缓存服务节点 hash值放到环上。每次一次进行服务器查找路由计算的时候，都是根据key 的hash 值顺时针查找距离它最近的服务器节点。通过这种方式，key 不变的情况下找到的总是相同的服务器。但是，Hash 值是一个随机值，把一个随机值放到一个环上以后，可能是不均衡的，也就是某两个服务器节点在环上的距离可能很近，而和其它的服务器节点距离很远。这会导致有些服务负载压力特别大，有些服务器的负载压力特别小。在实践中，需要使用虚拟节点对方法进行改进，把一个服务节点放到环上时，把它虚拟成200个虚拟节点，然后把 200 个虚拟节点随机放到环上。key 依然是按照顺时针查找距离它最近的虚拟节点，再根据映射关系找到真正的物理节点。
Java 代码实现如下：
public class Consistent { SortedMap&amp;lt;Long, PhysicalNode&amp;gt; ring; int virtualNodeCount; public Consistent(int virtualNodeCount) { ring = new TreeMap(); this.</description></item><item><title>AI 笔记</title><link>https://redscarf.me/ai-note/</link><pubDate>Tue, 09 Jan 2024 20:10:22 +1000</pubDate><guid>https://redscarf.me/ai-note/</guid><description>如何找落地场景 从最熟悉的领域入手 让 AI 学习最厉害员工的能力，再让 ta 辅助其他员工，实现降本增效 找 【文本进，文本出】的场景 别求大而全。将任务拆解，先解决小任务、小场景（小切口、大纵深） 通俗原理 通过上文，猜测下一个词出现的概率。
大模型阅读了大量人类说过的所有话（训练），就是机器学习 把一串 token 后面跟着的不同 token 的概率存入神经网络，保存的数据就是参数，也叫权重 当我们给它若干 token，大模型就能算出概率最高的下一个 token 是什么。这就是生成，也叫推理 用生成的 token，再加上上文，就能继续生成下一个 token。以此类推，生成更多文字 如何用好 AI？ 数字神经网络和人脑的生物神经网络，在数学原理上是一样的。 ——OpenAI 首席科学家 Ilya Sutskever
所以，把 AI 当人看！！！和人怎么相处就和 AI 怎么相处。
使用 AI 的几种模式 Embedding AI（少） AI Copilot（协助） AI Agent（代理） 从上往下，AI 参与处理的任务越多。
AI 相关的编程基本是 Python 语言。 安装 OpenAI pip3 install --upgrade openai 大模型里面的角色 System Role：主要是定义系统的行为规范和全局设置。 Assistant Role：主要负责与用户的交互，根据用户的输入生成响应。 这两种角色在构建对话系统时是互补的，共同决定了系统的整体行为和用户体验。
LangChain 里面的 LLM 模块和 ChatModel LLM：通常用于生成单个文本输出，适合一次性提示和响应的场景。 ChatModel：专门用于处理对话，能够记住对话历史并生成连贯的回复，适合构建多轮对话系统。 框架对比 Llamaindex：主要用于构建和管理向量数据库，特别适合文档检索和知识库管理。 Semantic Kernel：专注于构建对话系统，支持多轮对话和上下文管理，适合构建复杂的对话应用。 LangChain：全面的框架，支持链式处理和多种模型，适合构建多样化的语言模型应用。 Replicate Replicate 是一个云端 AI 模型运行平台，它允许用户通过云端 API 直接运行机器学习模型，非专业人士也能上手。</description></item><item><title>数据库的动态列</title><link>https://redscarf.me/db-dynamic-column/</link><pubDate>Tue, 25 Jul 2023 20:17:32 +1000</pubDate><guid>https://redscarf.me/db-dynamic-column/</guid><description>动态列的几种设计思路 在需求开发过程中，我们有时会遇到一种场景：某个具体业务中的属性是动态的。在理想情况下，我们可以使用穷举法对所有可能的属性进行分析，然后进行分类，最终形成一套解决方案。然而，现实往往是骨感的，Leader和客户通常不会给我们这个时间。因此，我们需要探讨一些更为实际的解决方案。
一、使用数据库DDL进行动态创建 优点：
操作简单，只需通过SQL管理即可实现。 缺点：
不同情况下的动态字段增加会导致表结构膨胀。 在已有数据的表中修改字段容易导致锁表，影响性能。 二、使用数据库预留字段 优点：
与数据库无关，对业务侵入性小。 缺点：
扩展性差，超出预留字段范围后如何处理新字段？ 可读性差，预留字段通常为attr1、attr2等，影响字段的可读性。 性能较低，为兼容多种数据类型，预留字段通常采用较长的文本数据类型存储，影响数据库性能。 三、使用数据库中的JSON数据类型 优点：
使用简单，绝大多数编程语言都支持JSON操作，方便快捷。 对于MySQL或PostgreSQL等数据库，已原生支持JSON字段，可基于JSON进行扩展查询。 JSON采用key:value形式存储数据，可避免字段可读性差的问题，通过规范命名提高可读性。 扩展性高，增加或删除字段实现简单，直接移除key即可，不影响表性能。 缺点：
JSON字段查询操作与普通字段稍有差异，有一定复杂度。 JSON字段的索引性能有待提高。 四、使用NoSQL数据库 优点：
采用MongoDB等JSON数据库，可以快速扩展。 专业数据存储，查询等性能可针对优化，性能高。 缺点：
需要一定的学习成本。 综上所述，第一种和第二种方案若非必要，不建议采用。第三种方案在中小项目中能应对绝大多数需求。如果存储的数据较多且性能要求较高，可以考虑采用第四种方案或第三、四种方案相结合。
支持动态列的数据库 MariaDB 通过创建BLOB列（最大64k？），可以使用mariadb-dynamic-columns实现动态列。
示例： CREATE TABLE items ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name varchar(100) NOT NULL, attributes BLOB ); 插入数据时使用特定函数（COLUMN_CREATE）指定动态列的数据结构，key/value形式： INSERT INTO items (name, attributes) VALUES (&amp;#39;MariaDB t-shirt&amp;#39;, COLUMN_CREATE(&amp;#39;colour&amp;#39;,&amp;#39;blue&amp;#39;, &amp;#39;size&amp;#39;,&amp;#39;XXL&amp;#39;)), (&amp;#39;MariaDB t-shirt&amp;#39;, COLUMN_CREATE(&amp;#39;colour&amp;#39;,&amp;#39;blue&amp;#39;, &amp;#39;size&amp;#39;,&amp;#39;XL&amp;#39;)), (&amp;#39;Samsung Galaxy S5&amp;#39;, COLUMN_CREATE(&amp;#39;colour&amp;#39;,&amp;#39;white&amp;#39;, &amp;#39;OS&amp;#39;, &amp;#39;Android&amp;#39;, &amp;#39;type&amp;#39;, &amp;#39;phone&amp;#39;)), (&amp;#39;Samsung Galaxy Pro 3&amp;#39;, COLUMN_CREATE(&amp;#39;colour&amp;#39;,&amp;#39;white&amp;#39;, &amp;#39;size&amp;#39;,8, &amp;#39;OS&amp;#39;, &amp;#39;Android&amp;#39;, &amp;#39;resolution&amp;#39;,&amp;#39;1920x1200&amp;#39;, &amp;#39;type&amp;#39;,&amp;#39;tablet&amp;#39;)); 查询时使用COLUMN_JSON函数，返回JSON格式的数据： SELECT name AS Item, COLUMN_JSON(attributes) AS &amp;#39;Dynamic Columns&amp;#39; FROM items LIMIT 1; 使用COLUMN_LIST函数列举列中包含的属性，如colour、size： SELECT name AS Item, COLUMN_LIST(attributes) AS &amp;#39;Attribute Names&amp;#39; FROM items; 查询动态列中具体的某个属性，如colour： SELECT name AS Item, COLUMN_GET(attributes, &amp;#39;colour&amp;#39; AS CHAR) AS Colour FROM items; PostgreSQL 支持JSON数据类型，相比普通text文本字段类型，JSON数据类型强制要求列中每个存储的值都符合JSON格式规则。</description></item><item><title>多租户</title><link>https://redscarf.me/multi-tenant/</link><pubDate>Mon, 24 Jul 2023 19:30:32 +1000</pubDate><guid>https://redscarf.me/multi-tenant/</guid><description>多租户架构概述与实现 多租户（Multi-tenancy） 是一种软件架构模式，允许多个客户（租户）共享同一个应用实例和底层资源，同时保障租户数据的隔离与安全。租户可以是企业、部门或个人用户。其目标是在优化资源利用效率的同时，满足租户对个性化、安全性和成本效益的需求。
多租户的背景与优势 背景 云计算的普及：随着云计算技术的发展，SaaS（软件即服务）模式迅速崛起，多租户架构成为共享资源和优化成本的关键技术。 资源利用效率需求：通过在同一物理或逻辑服务器上运行多个租户应用，提高资源利用率并降低运营成本。 个性化和隔离需求：满足租户定制化的同时，确保数据安全与隔离。 降低运维成本：多租户架构显著减少了软件升级与补丁管理的复杂性。 优势 低成本：通过共享资源，显著降低基础设施和维护费用。SaaS多租户软件通常以订阅形式提供，租户分担运营成本。 可伸缩性：租户可根据需求灵活扩展，只需调整订阅配置。 无代码定制化：无需复杂的开发，租户即可通过配置满足特定业务需求。 持续更新与维护：软件提供商统一管理更新与补丁，租户自动获得改进，无需额外操作。 提高生产率：租户可专注于核心业务，无需管理基础设施或软件。 多租户架构的实现方式 根据隔离程度和成本，不同场景下的多租户实现方式如下：
1. 共享数据库 + 共享架构 所有租户共享一个数据库实例与数据库架构，租户数据通过租户标识（如租户ID）区分。
优点： 成本低：资源利用率高，节约硬件与运维成本。 开发简单：实现复杂度较低。 适合中小规模租户：支持批量操作。 缺点： 安全性较低：需严格控制租户间的数据隔离。 扩展性有限：租户增长可能引发性能瓶颈。 适用场景：小型SaaS应用，租户间数据隔离需求较低。 2. 独立数据库 + 共享架构 每个租户拥有独立的数据库，但共享数据库架构。
优点： 数据隔离性好：提升安全性。 扩展性强：可独立扩展租户数据库。 缺点： 成本较高：需分配单独数据库实例。 运维复杂度提升：需管理多个数据库实例。 适用场景：中型SaaS应用，数据隔离需求高。 3. 独立数据库 + 独立架构 每个租户拥有独立的数据库与架构，支持更高的定制化。
优点： 高度隔离：数据、性能、定制化完全独立。 灵活性高：满足复杂业务需求。 缺点： 成本高：需为每个租户单独配置资源。 开发与运维复杂度高：架构需逐一维护。 适用场景：大型企业级应用，少量租户但数据敏感且需求复杂。 4. 容器化隔离 通过容器技术（如Docker），为每个租户提供独立的容器化服务。
优点： 部署灵活：每个容器的环境可独立配置。 高扩展性：便于弹性伸缩。 强隔离性：容器内外环境相互独立。 缺点： 运维复杂：需管理容器编排工具（如Kubernetes）。 成本：资源分配灵活性可能引发一定浪费。 适用场景：需要高度隔离和动态扩展的中大型应用。 特殊技术：命名空间与多租户 Linux命名空间 Linux命名空间是一种操作系统层面的资源隔离技术，可以将全局资源划分为命名空间范围内的资源。命名空间隔离涵盖主机名、用户权限、文件系统、网络、进程等，支撑了容器技术（如Docker）。
命名空间通过为每个租户创建独立的资源视图来实现隔离。与Cgroups（控制组）结合使用时，可以进一步限制每个租户对CPU、内存和I/O的使用，从而实现资源的公平分配。例如，网络命名空间可以为每个租户分配独立的虚拟网络接口和IP地址，进而避免资源争夺。
在多租户架构中，Linux命名空间的典型应用包括：</description></item><item><title>Prompt 框架模版</title><link>https://redscarf.me/ai-prompt-template/</link><pubDate>Sun, 09 Jul 2023 21:30:32 +1000</pubDate><guid>https://redscarf.me/ai-prompt-template/</guid><description>Crispe Matt Nigh 的 CRISPE Framework，比较适合用于编写 prompt 模板。CRISPE 分别代表以下含义：
CR: Capacity and Role（能力与角色）。你希望 ChatGPT 扮演怎样的角色。
I:Insight（洞察力），背景信息和上下文（坦率的说我觉得用Context 更好）。
S： Statement（指令），你希望 ChatGPT 做什么。
P：Personality（个性），你希望 ChatGPT 以什么风格或方式回答你。
E：Experiment（尝试），要求 ChatGPT 为你提供多个答案。
以下是这几个参数的例子：
Step Example Capacity and Role Act as an expert on software development on the topic of machine learning frameworks, and an expert blog writer. 把你想象成机器学习框架主题的软件开发专家，以及专业博客作者。 Insight The audience for this blog is technical professionals who are interested in learning about the latest advancements in machine learning.</description></item><item><title>Kafka 总结</title><link>https://redscarf.me/kafka-1/</link><pubDate>Thu, 27 Jan 2022 20:56:50 +1000</pubDate><guid>https://redscarf.me/kafka-1/</guid><description>consumer 是推还是拉？ https://kafka.apache.org/documentation/#design_pull kafka 生产者端生成消息推送（push）到 broker，消费者端从 broker 拉取（pull）消息。
统一采用 pull 的方式？ boker 从生产者 pull 消息。在生产者数量庞大的场景下，broker 需要管理维护很多的关系，简直是梦魇。所以采用的是生产者往 broker push 消息。
统一采用 push 的方式？ broker 往 consumer push 消息。在 consumer 多样化的场景下，如果生产者的生产速率远远大于消费者，broker 控制不好，push 会造成 consumer 不堪重负。反之，由 consumer 根据自身处理速率来决定何时从 broker 拉取消息，会更好。采用 pull 的弊端在于，如果 broker 没有消息，那么就会空转，这可以通过在调用 poll 接口时传入等待时间阻塞或者传入批次数据包大小来等待阻塞。
kafka 的 ack 机制 客户端连接到 leader broker 上，发送消息之后，等待或不等待 leader broker 的 ack（是否等待取决于参数request.required.acks 配置）。比如： 客户端设置 acks=0，客户端不作任何等待，即使消息没有写入 kafka 集群。 客户端设置 acks=1，客户端会等待 Leader 副本成功写入后返回的确认，但如果 Leader 副本在消息被同步到其他副本之前崩溃，消息可能会丢失。 客户端设置 acks=all 或 acks=-1参数，leader 在接收到客户端的消息之后，先写入日志文件，然后往同步副本（ISR）发送数据，等所有的 follower 都确认消息写入成功后，leader 再给客户端发送 ack 确认。</description></item><item><title>About Me</title><link>https://redscarf.me/about/</link><pubDate>Sat, 03 Jul 2021 21:04:32 +1000</pubDate><guid>https://redscarf.me/about/</guid><description>职业 Java&amp;amp;iOS developer
工作经历 2021.8 - now 软件开发工程师 金蝶软件 2018.12 - 2021.7 软件开发工程师 深圳鹏城实验室 网络通信研究中心</description></item><item><title>博客搬新家了！！！</title><link>https://redscarf.me/hugo_newbie/</link><pubDate>Sat, 03 Jul 2021 00:06:32 +1000</pubDate><guid>https://redscarf.me/hugo_newbie/</guid><description>将博客生成器从原来的 Hexo 换成了 Hugo。
特别感谢闫博推荐 Hugo 这个静态网站生成器并提供 技术支持！</description></item><item><title>Docker 使用</title><link>https://redscarf.me/docker-base-use/</link><pubDate>Tue, 07 Jul 2020 22:15:32 +1000</pubDate><guid>https://redscarf.me/docker-base-use/</guid><description>通过 Docker 命令行工具与 Docker Daemon 进程通讯使用。
使用步骤 安装 Docker 到宿主机（物理机） 到仓库拉取镜像
https://hub.docker.com 运行镜像产生容器（实例，一个镜像可以运行多个） 镜像操作 搜索镜像 docker search imageName 拉取镜像 docker pull imageName:tag tag 版本号，如不指定默认是 latest 查看本地镜像 docker images 删除镜像 docker rmi imageID docker rmi [repositoryname]:[tag] 删除所有未加标签的镜像(untagged) docker rmi $(docker images | grep &amp;#34;^&amp;lt;none&amp;gt;&amp;#34; | awk &amp;#34;{print $3}&amp;#34;) 重命名镜像 docker tag imageId imageName:tag 通过本地 Dockerfile 文件编译镜像文件 docker build -t mop:latest - &amp;lt; mopDockerfile 容器操作 进入容器 sudo docker exec -it ubuntu bash docker exec -it ardupilot bash 查看容器 docker ps -a -a：所有容器，包括停止的 -q：查看停止的容器，不加选项默认查看运行中的容器 保存容器 sudo docker save ubuntu &amp;gt; ubuntu_save.</description></item><item><title>Lombok</title><link>https://redscarf.me/lombok/</link><pubDate>Thu, 30 Apr 2020 19:10:32 +0100</pubDate><guid>https://redscarf.me/lombok/</guid><description>介绍 Lombok 是提升 Java 编码效率常用的工具，借助它开发人员可以使用注解来自动生成一些模版代码。比如 getter、setter、equals、toString 等方法。
安装 在 maven 中添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.4&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 在编辑器中添加插件 如：Intellij Idea，在 setting 的 plugin 里搜索lombok plugin，安装插件
使用 常用的几个注解
@Data ：注在类上，自动生成类的 get、set、equals、hashCode、canEqual、toString 方法
@AllArgsConstructor ：注在类上，自动生成类的全参构造方法
@NoArgsConstructor ：注在类上，自动生成类的无参构造
@Setter ：注在属性上，自动生成 set 方法
@Getter ：注在属性上，自动生成 get 方法
@EqualsAndHashCode ：注在类上，自动生成对应的 equals 和 hashCode 方法
@Log4j/@Slf4j ：注在类上，自动生成对应的 Logger 对象，变量名为 log
@Cleanup(&amp;ldquo;close&amp;rdquo;)：注在本地变量上，自动释放资源（如：关闭 InputStream）
@Synchronized：注在方法上，自动生成一个私有锁变量
@SneakyThrows：自动生成异常处理语句
注意继承关系中使用 Lombok @EqualsAndHashCode 与 @ToString 注解默认情况下忽略父类的成员变量。譬如打印时 toString 返回的结果中缺少父类的成员变量，解决办法是在注解中设置 callSuper 属性为 true， @ToString(callSuper = true) 、@EqualsAndHashCode(callsuper = true)。</description></item><item><title>Json Web Token</title><link>https://redscarf.me/jwt/</link><pubDate>Wed, 09 Oct 2019 22:15:32 +1000</pubDate><guid>https://redscarf.me/jwt/</guid><description/></item><item><title>WebViewJavascriptBridge 源码剖析</title><link>https://redscarf.me/ios-wvjb-sc-analyse/</link><pubDate>Thu, 20 Dec 2018 22:21:48 +1000</pubDate><guid>https://redscarf.me/ios-wvjb-sc-analyse/</guid><description>WebViewJavascriptBridge 是一个可以让 OC 与 JS 进行交互通信的第三方开源库。相比其他热门的第三方库，WebViewJavascriptBridge 代码量比较少，并且设计优雅巧妙，可以说是 “小而美”。
WebViewJavascriptBridge 库在 OC 端和 JS 端都有对等的逻辑实现，事先注册 handler，内部维护一个消息队列。透明的 iframe HTML 元素和 webview 的 stringByEvaluatingJavaScriptFromString 是通信的关键。OC 端发消息给 JS 端比较直观，调起 stringByEvaluatingJavaScriptFromString 执行脚本传入消息即可。JS 端发消息给 OC 端，需要事先把消息存到队列中，然后借助 iframe 发起一个伪请求，伪请求会被 webview 的代理方法拦截下来，OC 端因此得知 JS 端消息队列中有消息，最后调起 stringByEvaluatingJavaScriptFromString 方法解析 JS 方法拿到队列中的消息并处理。交互流程见下图：
整个库只有以下几个文件：
WebViewJavascriptBridge.h WebViewJavascriptBridge.m WKWebViewJavascriptBridge.h WKWebViewJavascriptBridge.m WebViewJavascriptBridgeBase.h WebViewJavascriptBridgeBase.m WebViewJavascriptBridge_JS.h WebViewJavascriptBridge_JS.m 一般使用只需要关注 WebViewJavascriptBridge 类提供的接口，这个类的主要职责是用来做 Mac 和 iOS webview 的适配（包括 WKWebView，但是这部分代理出去给 WKWebViewJavaScriptBridge 类）并为客户端提供便利的使用接口。WebViewJavascriptBridgeBase 类负责有关数据加工、消息队列管理、消息派发及回调的处理工作。WebViewJavascriptBridge_JS 类包含 JS 端的实现代码，通过宏处理返回 JS 端实现代码的一个 OC 字符串，便于在适当时机将其注入到文档模型中完成 bridge 的初始化。</description></item><item><title>iOS 远程打包脚本制作</title><link>https://redscarf.me/ios-remote-pack/</link><pubDate>Mon, 23 Jul 2018 20:00:50 +1000</pubDate><guid>https://redscarf.me/ios-remote-pack/</guid><description>在 iOS 开发中，一般打发布包都是在本地打包，也就是工程师在自己开发电脑上使用 Xcode 编译并导出安装包来进行发布，为了提高效率可能会制作一些自动化打包脚本。本文聊的是远程打包的内容，通过资源拷贝及参数替换然后编译完成打包。
由于 HTML5 跨平台的特点，很多技术团队考虑到代码复用，在部分模块中会采用 h5 来描述界面。甚至有些不需要太复杂交互的 app，全部界面采用 h5 来编写，也就是一个 web 工程。对于大部分现有的 web 工程，能打包成 app 就已经满足了业务诉求。DCloud 团队开发的 HBuilder（IDE）工具中提供了云打包的功能，用起来很方便，简单的说，就是把 web 工程上传到云打包服务器，最后打包生成 app，点击下载即可安装使用。
虽然云打包服务很方便，但上传源码总感觉不太妥当，总有些秘密不想让别人看见，并且其他同事也有打包的需求，但不一定会使用 HBuilder。因此，搭建一个自己的打包服务很有必要。
按照 HBuilder 提供的云打包功能，先定一个初步的需求：
支持修改应用 id、版本号 、icon、启动图 支持导入签名文件 开工！！！
准备工作 首先，需要一台安装了 MacOS 的电脑（当做服务器使用）。
笔者手头上刚好有台闲置的电脑就拿来当服务器使用了，装了 WMWare，然后装了 MacOS 虚拟机（问题较多，不建议使用虚拟机）。
物理机 windows7，内存 4G；虚拟机 MacOS，内存 3G。
其次，在服务器上部署一个 web 服务，提供打包交互界面方便客户端上传资源文件及下载安装包。我们的界面只提供了一个 www zip 包的上传入口，所有应用资源及打包相关的配置文件都在里面。www 目录结构如下：
appConfig.json 文件内容 { &amp;#34;id&amp;#34;:&amp;#34;com.domain.pack&amp;#34;, &amp;#34;appName&amp;#34;:&amp;#34;我的应用&amp;#34;, &amp;#34;debug&amp;#34;:true, &amp;#34;launchPath&amp;#34;: &amp;#34;index.html&amp;#34;, &amp;#34;version&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;code&amp;#34;: &amp;#34;100&amp;#34; }, ... } launchPath 对应 web 应用入口文件，iOS 工程使用这个文件路径作为 webview 的加载入口。</description></item><item><title>Android Gradle 注入编译变量</title><link>https://redscarf.me/android-gradle-build/</link><pubDate>Sat, 09 Jun 2018 12:36:16 +1000</pubDate><guid>https://redscarf.me/android-gradle-build/</guid><description>最近为了制作 Android 应用打包脚本，学习了一下 gradle。Gradle 构建系统语法简洁、功能强大、配置灵活，笔者只是把它当作一个构建工具来使用，基于它所提供的便利制作可以修改版本号、编译号、id 及导入证书的脚本。
对于一个项目或者一个工程，Gradle 可以定义多个构建任务，debug 和 release 是常见的两个构建任务，用户还可以根据需要自定义自己的构建任务，如测试构建任务和预发布构建任务，甚至是针对不同发布渠道的构建任务。这里只用到 debug 任务。
gradle 命令行支持传入自定义参数，并在编译过程注入这些参数。
修改 appid 及 版本号 修改 build.gradle 文件 android { compileSdkVersion 21 buildToolsVersion &amp;#39;26.0.2&amp;#39; defaultConfig { applicationId project.hasProperty(&amp;#39;applicationId&amp;#39;) ? applicationId : &amp;#34;com.domain.myApp&amp;#34; minSdkVersion 14 targetSdkVersion 21 versionCode project.hasProperty(&amp;#39;versionCode&amp;#39;) ? versionCode.toInteger() : 100 versionName project.hasProperty(&amp;#39;versionName&amp;#39;) ? versionName : &amp;#34;1.0.0&amp;#34; testInstrumentationRunner &amp;#34;android.support.test.runner.AndroidJUnitRunner&amp;#34; } 命令行中传入对应 key 的参数 gradle assembleDebug -PversionCode=&amp;#34;200&amp;#34; -PversionName=&amp;#34;2.0.0&amp;#34; -PapplicationId=&amp;#34;com.domain.myApp.debug&amp;#34; 修改应用 id 的最好同时修改包名，不然会有包名冲突，修改包名需要修改 AndroidManifest.xml 文件，先在 build.gradle 文件中使用 manifestPlaceholders 属性定义一个键：</description></item><item><title>Core Bluetooth Programming Guide 译文</title><link>https://redscarf.me/ios-core-bluetooth-programming-guide/</link><pubDate>Mon, 26 Mar 2018 19:09:15 +1000</pubDate><guid>https://redscarf.me/ios-core-bluetooth-programming-guide/</guid><description>介绍 关于 Core Bluetooth Core Bluetooth 框架提供 iOS 应用和 Mac 应用与设备（配备了蓝牙低能耗无线技术的设备）通信的类。例如，应用可以发现、探测并与低能耗外围设备（比如心率监听器和数字恒温器）交互。从 macOS 10.9 和 iOS 6 开始，Mac 和 iOS 设备还可以当做蓝牙低能耗外设来使用，为其它设备提供数据，包括其他 Mac 和 iOS 设备。
一览 蓝牙低能耗无线技术基于蓝牙 4.0 规范，规范中除了别的之外，定义了与低能耗设备通信的一套协议。Core Bluetooth 框架是蓝牙低能耗协议栈的一个抽象，也就是说，它为开发者隐藏了许多规范中的底层细节，让开发者更加容易开发应用（与蓝牙低能耗设备交互的应用）。
中央和外围是 Core Bluetooth 的核心成员 在蓝牙低能耗通信中，有两个核心成员：中央（central）和外围（peripheral）。每个成员扮演不同的角色。外围通常拥有其他设备需要的数据，中央通常使用外围提供的信息来完成一些任务。例如，一个配备了蓝牙低能耗技术的数字恒温器可能为一个 iOS 应用提供房间的温度信息，然后该应用采用用户友好的方式来显示温度。
每个成员在扮演它的角色时都会执行一组不同的任务。外围通过在空中广播持有的数据来让自身的存在被感知，中央设备扫描附近的外围设备（可能包含中央设备感兴趣的数据）。当中央设备发现外围设备，中央设备就请求与外围设备连接并开始探测和交互外围设备的数据。外围设备负责以适当的方式来响应中央设备。
相关章节：Core Bluetooth Overview
Core Bluetooth 简化了一般的蓝牙任务 Core Bluetooth 框架抽离了蓝牙 4.0 规范中的底层细节。因此，应用中需要实现的一般蓝牙低能耗任务被简化了。如果开发实现中央角色的应用，Core Bluetooth 使得发现、连接外围设备和探测、交互外围数据变得简单。另外，Core Bluetooth 还让本地设备实现外围角色变得简单。
相关章节：Performing Commmon Central Role Tasks,Performing Common Peripheral Role Tasks
iOS 应用的状态影响蓝牙的表现 当应用处于后台或挂起状态时，蓝牙相关的特性会受到影响。在这两种状态下，默认是应用无法执行蓝牙低能耗任务。也就是说，如果应用需要在后台执行蓝牙低能耗任务，可以声明支持 Core Bluetooth 后台运行模式中的一个或两个（一个属于中央角色，另一个属于外围角色）。即使在你指定了一个后台运行模式或两个都指定，当应用处于后台时，某些蓝牙任务的执行依然会有所不同，设计应用时，需要考虑到这些差异。
即使应用支持后台处理，应用仍然可能在任意时刻被系统终止以清空内存给当前前台应用使用。在 iOS 7之后，Core Bluetooth 支持保存中央和外围管理者对象的状态信息并在应用启动的时候恢复该状态，可以使用这个特性来支持涉及蓝牙设备的长期活动（long-term actions）。</description></item><item><title>Difference between authentication, authorization,verification, validation</title><link>https://redscarf.me/terminology-confusion/</link><pubDate>Tue, 12 Dec 2017 21:41:34 +1000</pubDate><guid>https://redscarf.me/terminology-confusion/</guid><description>verification, validation, authentication, authorization 这几个术语很常用，也经常被误用，这里做一次对比总结。
identity
A security principal (you or a computer, typically) wants to access a system. Because the system doesn’t know you yet, you need to make a declaration of who you are. Your answer to the question “Who are you” is the first thing you present to a system when you want to use it. Some common examples of identity are user IDs, digital certificates (which include public keys), and ATM cards.</description></item><item><title>Local and Remote Notification Programming Guide 译文</title><link>https://redscarf.me/ios-local-and-remote-notification-programming-guide/</link><pubDate>Mon, 27 Nov 2017 20:26:21 +1000</pubDate><guid>https://redscarf.me/ios-local-and-remote-notification-programming-guide/</guid><description>原文地址：本地和远程通知编程指南
应用中的通知 本地和远程通知概览 重要 这篇文档包含开发中有关 API 或技术的初步信息，这些信息可能会改变，并且根据这篇文档来实现的软件应当在最终的操作系统软件中进行测试。
本地通知和远程通知是在应用有新数据可用时通知用户的两种方式，即使此时应用不在前台运行。例如，短信应用可能会让用户知道有新的短信来了，日历应用可能会通知用户即将到来的约会。本地通知和远程通知的区别很简单：
对于本地通知，应用在本地配置通知的细节并把这些细节传给系统，然后由系统来处理通知的传递（当应用不在前台时）。iOS、tvOS、watchOS 都支持本地通知。 对于远程通知，使用公司服务器中的一个通过苹果推送通知服务把数据推送到用户的设备。iOS、tvOS、watchOS、macOS 都支持远程通知。 本地通知和远程通知都需要添加代码来支持应用中的通知的调度和处理。对于远程通知，必须提供一个服务器环境，该环境能够接收来自用户设备的数据和发送通知相关的数据到 苹果推送消息服务 (简称 APNs，由苹果提供的用来处理远程通知传递的服务)。
User Notifications 和 User Notifications UI 框架 从 iOS 10、watchOS 3、tvOS 10 开始，User Notifications 框架提供一致的方式来和处理本地通知。除了管理本地通知，该框架也支持远程通知的处理，然而远程通知的配置仍然需要一些平台特有的 API。因为这是一个独立的框架，所以可以在应用中或者扩展中使用，比如 WatchKit 扩展。
注意 macOS 上远程通知的配置和处理需要使用平台特有的方法（在 AppKit 框架中找）
User Notifications 框架也支持创建 通知服务应用扩展 (notification service app extension)，它可以让你在远程通知传递之前修改通知的内容。如果在应用中包含通知服务应用扩展，系统会把收到的通知在传递给用户之前先传递给扩展。可以使用这类扩展来给应用的通知实现端到端的加密、在通知传递前修改其内容，又或者下载与通知相关的额外的图片或媒体文件。
User Notifications UI 框架是 User Notifications 的配套，它可以让你自定义系统的通知界面的外观。使用User Notifications UI 框架来定义 通知内容应用扩展(notification content app extension)，它的任务就是提供一个包含自定义内容的视图控制器来显示在通知界面中。系统会显示自定义视图控制器而不是默认的系统界面。可以使用这种扩展在通知界面中加入多媒体或动态内容。
更多有关 User Notifications 框架的类的信息，请看 User Notifications Framework Reference。关于创建通知内容应用扩展的类的信息，请看 User Notifications UI Framework Reference。</description></item><item><title>《第一行代码》</title><link>https://redscarf.me/android-first-line-code-note/</link><pubDate>Sat, 14 Oct 2017 11:59:26 +1000</pubDate><guid>https://redscarf.me/android-first-line-code-note/</guid><description>最近为了学习 Android，找从事 Android 开发的朋友推荐些书，最后他推荐了《第一行代码》（第 2 版）和《Android 开发艺术探索》两本书。本文是在阅读了《第一行代码》之后所做的笔记，主要记录 Android 平台上的一些比较有趣的特性以及它和 iOS 的不同之处。
Android 全貌 2008 年 9 月，Google 正式发布 Android 1.0 系统 2014 年 Google I/O 大会上发布号称史上版本改动最大的 Android 5.0 系统，这版本使用 ART 运行环境替换 Dalvik 虚拟机，同时推出 Wear、Auto、TV 系统 2016 年 Google I/O 大会推出 Android 7.0，加入多窗口模式 Android 系统架构 Android 系统架构分为四层：Linux 内核层、系统运行库层、应用架构层、应用层。
Linux 内核层：主要包含一些硬件的底层驱动。
系统运行库层：包含 C/C++ 的底层支持库，例如：支持 3D 绘图的 OpenGL|ES 库、浏览器内核 Webkit 库和 SQLite 数据库支持库。另外还包含 Android 运行时库。
应用架构层：包含构建应用程序用到的 API，开发人员主要使用这层提供的 API 来构建应用。
应用层：包含手机上安装的应用，联系人、短信等。
Android 系统为开发人员提供了：
四大组件，活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver） 和内容提供器（Content Provider） 系统控件 SQLite 数据库 多媒体，音乐、视频、图片、拍照、闹铃等 地理位置定位 Android 开发环境及工具 环境：JDK + Android SDK</description></item><item><title>OC 与 JS 通信的几种方式</title><link>https://redscarf.me/ios-oc-interact-with-js/</link><pubDate>Fri, 23 Jun 2017 22:57:25 +1000</pubDate><guid>https://redscarf.me/ios-oc-interact-with-js/</guid><description>在代理方法中拦截协议 使用 JavaScriptCore WKWebView 的 WKScriptMessagehandler 使用 NSURLProtocol 拦截请求 使用第三方库 WebViewJavascriptBridge 使用 WebSocket 这里只介绍第 6 种，其它的相关资料网上有很多。
使用 WebSocket 的方式需要在应用内起一个 websocket server 服务（有很多第三方的 websocket server 库），html 页面通过 Websocket 连接到服务，接着就是发送消息了，剩下的就跟代理方法拦截协议类似。
// OC code, 以 PocketSocket 这个库为例 _socketServer = [PSWebSocketServer serverWithHost:nil port:9001]; _socketServer.delegate = self; _socketServer.delegateQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); [_socketServer start]; #pragma mark - PSWebSocketServerDelegate - (void)serverDidStart:(PSWebSocketServer *)server { NSLog(@&amp;#34;Server did start…&amp;#34;); } - (void)serverDidStop:(PSWebSocketServer *)server { NSLog(@&amp;#34;Server did stop…&amp;#34;); } - (BOOL)server:(PSWebSocketServer *)server acceptWebSocketWithRequest:(NSURLRequest *)request { NSLog(@&amp;#34;Server should accept request: %@&amp;#34;, request); return YES; } - (void)server:(PSWebSocketServer *)server webSocket:(PSWebSocket *)webSocket didReceiveMessage:(id)message { // 在这里拦截 NSLog(@&amp;#34;Server websocket did receive message: %@&amp;#34;, message); NSString *text = message; NSURL *url = [NSURL URLWithString:text]; if ([url.</description></item><item><title>重构的理由核对表</title><link>https://redscarf.me/refactor-reason-checklist/</link><pubDate>Sat, 31 Dec 2016 20:15:32 +1000</pubDate><guid>https://redscarf.me/refactor-reason-checklist/</guid><description>核对表：重构的理由 口 代码重复。 口 子程序太长。 口 循环太长或者嵌套太深。 口 类的内聚性太差。 口 类的接口的抽象层次不一致。 口 参数表中参数太多。 口 类的内部修改往往局限于某个部分。 口 需要对多个类进行并行修改。 口 对继承体系的并行修改。 口 需要对多个 case 语句进行并行修改。 口 相关的数据项只是被放在一起，没有组织到类中。 口 成员函数更多地使用了其他类的功能，而非自身类的。 口 过于依赖基本数据类型。 口 一个类不做什么事。 口 一连串传递流浪数据的子程序。 口 中间人对象什么也不干。 口 某个类同其他类关系过于密切。 口 子程序的命名太差。 口 数据成员被设置为公用。 口 派生类仅仅使用了基类的一小部分成员函数。 口 用注释来掩饰拙劣的代码。 口 使用了全局变量。 口 在子程序调用前使用设置代码，调用后使用收尾代码。 口 程序包含的某些代码似乎在将来某个时候才会被用到。</description></item><item><title>第一次成为技术主管易犯的3个常见错误</title><link>https://redscarf.me/three-common-mistakes-of-the-first-time-tech-lead/</link><pubDate>Fri, 16 Dec 2016 22:49:16 +1000</pubDate><guid>https://redscarf.me/three-common-mistakes-of-the-first-time-tech-lead/</guid><description>译自 Three Common Mistakes of the First Time Tech Lead
by Patrick Kua
Tech Principal and generalising Specialist
Don&amp;rsquo;t miss the author&amp;rsquo;s earlier post on the 5 Tips for Being an Effective Tech Lead.
别错过作者先前写的关于成为高效技术主管的5个秘诀。
The first time a developer steps into the role of a Tech Lead can be difficult. The skills and experience of a seasoned developer do not automatically translate into the skills necessary for the Tech Lead role.</description></item><item><title>HTTPS 单向/双向认证</title><link>https://redscarf.me/https-uni-bidirectional-authentication/</link><pubDate>Tue, 08 Nov 2016 20:09:40 +1000</pubDate><guid>https://redscarf.me/https-uni-bidirectional-authentication/</guid><description>HTTPS HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，不适合用来传输隐私信息。默认 80 端口。
Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了 SSL(Secure Sockets Layer) 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。默认 443 端口。
SSL 包含对称加密和非对称加密，在建立传输链路时，SSL 首先使用非对称加密的方式对对称加密密钥进行加密，建立链路后，使用对称加密的方式对传输内容进行加密。非对称加密有更高的安全性，在这个基础上使用对称加密可以获得更快的速度，提高传输效率。
单向认证 客户端校验服务端证书
client hello 客户端发起一条到服务端的连接，包含客户端支持的 TLS 版本、支持的加密套件(即加密算法)以及客户端随机数。
server hello 服务端回应，包含服务端 SSL 证书、选择的加密套件以及服务端随机数。
authentication 客户端向颁发证书的 CA 验证服务端的 SSL 证书，以确认服务端是它声称的那个身份，从而保证客户端与域名真正的所有者通信。
send premaster key 客户端发送另一个随机数 “premaster key”，并对它使用服务端的公钥（从服务端 SSL 证书中获取得到）进行加密。
decrypt premaster key 服务端解密 premaster key
create session key 客户端和服务端各自使用客户端随机数、服务端随机数以及 premaster key 来计算 “session key”，即对称加密密钥，两边计算得出同样的结果并各自保留。
client send finished 客户端使用 session key 加密一条 finished 消息并发送给服务端。</description></item><item><title>iOS Hook WebView 的代理方法</title><link>https://redscarf.me/ios-hook-uiwebview-delegate-method/</link><pubDate>Tue, 18 Oct 2016 20:09:01 +1000</pubDate><guid>https://redscarf.me/ios-hook-uiwebview-delegate-method/</guid><description>国内 DCloud 团队推出的 HTML5+ 技术框架可以用来开发 Hybrid 应用。经过调研，我们决定试一试 。框架的核心原理是使用 iOS 系统原生 UIWebView 和 WKWebView 来加载资源并渲染界面，Native 的能力（如拍照、蓝牙）通过自定义插件来提供。
我们的应用有个需求，就是在 webview 加载完页面或者加载页面之前加入一些东西。比如：加载完页面后，根据 HTML 的 title 标签来设置导航栏标题。
原生想要插手页面加载周期，只能靠代理方法。但是因为没法修改源码，所以只能找其它办法。主要思路是：使用 Method Swizzle 找出代理对象然后再换掉代理方法实现。
以 UIWebView 为例，具体操作如下：
第一步，通过交换 setDelegate 的实现，找到目标代理对象所属的类；
UIWebView+Intercepter.m - (void)p_setDelegate:(id&amp;lt;UIWebViewDelegate&amp;gt;)delegate { [self p_setDelegate:delegate]; Class delegateClass = [self.delegate class]; // 进一步交换 delegateClass 的代理方法 [UIWebViewDelegateHook exchangeUIWebViewDelegateMethod:delegateClass]; } #pragma mark - Method Swizzling + (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ Class class = [super class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(setDelegate:); SEL swizzledSelector = @selector(p_setDelegate:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } 第二步，把目标代理对象所属类的代理方法实现换成我们自己写的方法实现。</description></item><item><title>iOS 10 需要在 info.plist 中添加权限设置</title><link>https://redscarf.me/ios-ios10-user-privacy/</link><pubDate>Fri, 07 Oct 2016 22:35:29 +1000</pubDate><guid>https://redscarf.me/ios-ios10-user-privacy/</guid><description>iOS 10 开始对隐私权限更加严格, 如需使用隐私权限需要在工程的 info.plist 文件中声明,如果不声明程序在调用隐私权限（如相机）时应用程序会崩溃。
key 可以从下拉列表选择，value 为弹框提示文字（类型 String）
权限名称 Key 值 通讯录 NSContactsUsageDescription 麦克风 NSMicrophoneUsageDescription 相册 NSPhotoLibraryUsageDescription 相机 NSCameraUsageDescription 持续获取地理位置 NSLocationAlwaysUsageDescription 使用时获取地理位置 NSLocationWhenInUseUsageDescription 蓝牙 NSBluetoothPeripheralUsageDescription 语音转文字 NSSpeechRecognitionUsageDescription 日历 NSCalendarsUsageDescription</description></item><item><title>Grand Central Dispatch</title><link>https://redscarf.me/ios-gcd/</link><pubDate>Mon, 05 Jan 2015 20:13:18 +1000</pubDate><guid>https://redscarf.me/ios-gcd/</guid><description>GCD（Grand Central Dispatch）是异步执行任务的技术之一。
一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。
dispatch_queue_t queue = dispatch_queue_create(&amp;#34;myQueue&amp;#34;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ /** * 长时间处理 * 例如：AR用图像识别、数据库访问 */ /** * 长时间处理结束，主线程使用该处理结果 */ dispatch_async(dispatch_get_main_queue(), ^{ /** * 只在主线程可以执行的处理 * 例如用户界面刷新 */ }); }); 在导入 GCD 之前，Cocoa 框架提供了 NSObject 类的performSelectorInBackground:withObject实例方法和performSelectorOnMainThread实例方法等简单的多线程编程技术。
线程
线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 “一个 CPU 执行的 CPU 命令列为一条无分叉路径”即为“线程”。 现在一个物理的 CPU 芯片实际上有64个（64核）CPU，尽管如此，“一个 CPU 执行的 CPU 命令列为一条无分叉路径”仍然不变。 OS X 和 iOS 的核心 XNU 内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原 CPU 寄存器等信息，继续执行切换路径的 CPU 命令列。这称为“上下文切换”。 由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去好像1个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是“看上去像”了，而是真的提供了多个CPU核并行执行多个线程的技术。 使用多线程容易引发的常见问题</description></item><item><title>Auto Layout 知识点梳理</title><link>https://redscarf.me/ios-autolayout/</link><pubDate>Wed, 15 Oct 2014 22:29:37 +1000</pubDate><guid>https://redscarf.me/ios-autolayout/</guid><description>视图需要有确定的位置与大小才能正确显示在屏幕上。Auto Layout 使用对齐矩阵来确定视图的位置与大小，也就是所谓的约束。我们创建的每一条规则都规定了界面的一部分与另一部分的关系，某一部分可以由另一部分计算得出结果。
y = ax + b; 是一种线性关系。
创建约束的常见的方式：
Xib NSLayoutConstraint VFS 第一种，可以在(Interface Builder)IB中布局约束，并且根据需求自定义它们。
第二种，可以使用代码创建单个约束。NSLayoutConstraint 类提供constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:contant:方法，可以让你每次创建一个约束，它将某项的属性关联到另一项。
第三种，使用可视化格式语言来表示各项是如何沿着垂直和水平坐标轴布局的。
所有约束都是 NSLayoutConstraint 类的成员，无论你是以何种方式创建它们的。每个约束都在一个 Objective—C 对象中存储y = ax + b规则，并且通过 Auto Layout 引擎来表达该规则。可视化约束 是另一种实现相同效果的工具。</description></item><item><title>ARC</title><link>https://redscarf.me/ios-arc/</link><pubDate>Mon, 22 Sep 2014 21:22:25 +1000</pubDate><guid>https://redscarf.me/ios-arc/</guid><description>什么是自动引用计数 自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术。要使用 ARC，需要满足以下条件：
使用 Xcode4.2 或以上版本 使用 LLVM 编译器 3.0 或以上版本 编译器选项中设置 ARC 有效 生活例子：办公室开关灯
最早进入办公室的人开灯。 count = 1 之后进入办公室的人，需要照明。 count = 2 下班离开办公室的人，不需要照明。 count = 1 最后离开办公室的人关灯。（此时已无人需要照明） count = 0 内存管理 思考方式：
自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 表 1- 2 对象操作与 Objective-C 方法的对应
对象操作 Objective-C方法 生成并持有对象 alloc/new/copy/mutableCopy方法 持有对象 retain方法 释放对象 release方法 废弃对象 dealloc方法 区域(zone)
NSDefaultMallocZone、NSZoneMalloc 等名称中包含的NSZone是什么呢？它是为防止内存碎片化而引入的结构。对内存分配的区域本身进行多重化管理，根据使用对象的目的、对象的大小分配内存，从而提高了内存管理的效率。但是，如同苹果官方文档 Programming With ARC Release Notes 中所说，现在的运行时系统只是简单地忽略了区域的概念。运行时系统中的内存管理本身已极具效率，使用区域来管理内存反而会引起内存使用效率低下以及源代码复杂化问题。
修饰符
__strong 修饰符 __weak 修饰符 __unsafe_unretained 修饰符 __autoreleasing 修饰符 __unsafe_unretained 修饰符正如其名 unsafe 所示，是不安全的所有权修饰符。尽管 ARC 式的内存管理是编译器的工作，但附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象。同附有 __weak 修饰符的变量一样，因为自己生成并持有的对象不能继续为自己所有，所以生成的对象会立即被释放。</description></item><item><title>iOS Block</title><link>https://redscarf.me/ios-blocks/</link><pubDate>Sat, 20 Sep 2014 20:18:23 +1000</pubDate><guid>https://redscarf.me/ios-blocks/</guid><description>blocks 是 C 语言的扩充功能。blocks 是带有自动变量（局部变量）的匿名函数。
截获自动变量 int main() { int dmy = 256; int val = 10; const char *fmt = &amp;#34;val = %d\n&amp;#34;; void (^blk)(void) = ^{ printf(fmt,val); }; val = 2; fmt = &amp;#34;These value were changed. val = %d\n&amp;#34;; blk(); return 0; } 结果：val = 10
分析：block 语法的表达式使用的是它之前声明的自动变量 fmt 和 val。block 表达式截获所使用的自动变量的值为瞬间值。因为 block 表达式保存了自动变量的值（截获），所以在执行 block 语法后，即使改写了 block 中使用的自动变量的值也不会影响 block 执行的结果。
需要在 block 中修改一个变量的值，需要使用 __block 说明符。
block 的实质 block 实际上是作为极普通的 C 语言源代码来处理的。通过支持 block 的编译器，含有 block 语法的源代码转换为一般 C 语言编译器能够处理的源代码，并作为极为普通的 C 语言代码被编译。</description></item><item><title>Typeof()</title><link>https://redscarf.me/c-typeof/</link><pubDate>Sun, 27 Jul 2014 20:56:50 +1000</pubDate><guid>https://redscarf.me/c-typeof/</guid><description>看到项目中，有人这样写 __weak __typeof__(self) wself = self;。我查了一下资料，总结一下。
typeof关键字是C语言中的一个新扩展,在linux内核中应用非常广泛。
说明 typeof()的参数可以是表达式或一种类型。返回的结果是一种类型。
表达式 typeof(x[0](1));
这里假设 x 是一个函数指针数组，这样就可以得到这个函数返回值的类型了。如果将 typeof 用于表达式，则该表达式不会执行。只会得到该表达式的类型。以下示例声明了 int 类型的 var 变量，因为表达式 foo() 是 int 类型的。由于表达式不会被执行，所以不会调用 foo 函数。
extern int foo(); typeof(foo()) var; 一种类型 typeof(int *) a,b; 等价于：int *a,*b;
例子 把 y 定义成 x 指向的数据类型：
typeof(*x) y;
把 y 定义成 x 指向数据类型的数组：
typeof(*x) y[4];
把 y 定义成一个字符指针数组：
typeof(typeof(char *)[4]) y;
这与下面的定义等价： char *y[4];
typeof(int *) p1,p2; 等价于
int *p1, *p2;
typeof(int) *p3,p4;等价于</description></item><item><title>iOS 应用的 main.m 文件</title><link>https://redscarf.me/ios-main/</link><pubDate>Sun, 13 Jul 2014 21:15:12 +1000</pubDate><guid>https://redscarf.me/ios-main/</guid><description>在项目导航面板中选中 main.m ，可以看到
int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } 这是 iOS 应用的入口函数。UIApplicationMain 函数会创建一个 UIApplication 对象。每个 iOS 应用都有且只有一个 UIApplication 对象（单例），该对象的作用时维护运行循环。一旦程序创建了某个 UIApplication 对象，该对象的运行循环就会一直循环下去，main() 的执行也会因此阻塞。
此外，UIApplicationMain 函数还会创建某个指定类(此处为 AppDelegate)的对象，并将其设置为 UIApplication 对象的 delegate。UIApplicationMain 函数的第三个实参为 NSString 类型，指定了该对象所属的类。UIApplication 的 delegate 都需要遵守 UIApplicationDelegate 协议。
@interface AppDelegate : UIResponder &amp;lt;UIApplicationDelegate&amp;gt;
在应用启动运行循环时，UIApplication 对象会在应用出现相应状态变化时，向其 delegate 发送特定的消息。如：
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; - (void)applicationWillResignActive:(UIApplication *)application; - (void)applicationDidEnterBackground:(UIApplication *)application; - (void)applicationWillEnterForeground:(UIApplication *)application; - (void)applicationDidBecomeActive:(UIApplication *)application; - (void)applicationWillTerminate:(UIApplication *)application; UIApplication 负责建立应用程序的事件循环（Event Loop），事件循环中可以不断接收交互操作，比如屏幕触摸手势、各类传感器（重力加速器、陀螺仪等）等。</description></item></channel></rss>